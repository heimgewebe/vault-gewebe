

// --- Datei: Launchweb/init-events.js ---

import { EventEngine } from './engine-events.js';

import { renderKnoten } from './visual/render-knoten.js';
import { renderFäden } from './visual/render-faeden.js';
import { renderGarne } from './visual/render-garne.js';
import { renderAntraege } from './visual/render-antraege.js';
import { renderWebkasse } from './visual/render-webkasse.js';

export function registriereSymbolRenderEvents() {
  EventEngine.on('renderKnoten', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderKnoten(map._svgLayer, map._projection, daten.knoten);
  });

  EventEngine.on('renderFäden', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderFäden(map._svgLayer, map._projection, daten.faeden);
  });

  EventEngine.on('renderGarne', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderGarne(map._svgLayer, map._projection, daten.webungen);
  });

  EventEngine.on('renderAntraege', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderAntraege(map._svgLayer, map._projection, daten.webungen);
  });

  EventEngine.on('renderWebkasse', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderWebkasse(map._svgLayer, map._projection, daten, () => {}, () => {});
  });
}

// --- Datei: Launchweb/startup-loader.js ---

import { ladeKnotenDaten } from './render-knoten.js';
import { ladeDiskursDaten } from './render-diskurse.js';
import { ladeFinanzDaten } from './render-webkasse.js';
import { layerManager } from './layer-manager.js';
import { rolleService } from './rolle-service.js';
import { initialisiereZeitleiste } from './zeitleiste.js';

export async function startupLoader() {
  const [knoten, diskurse, finanzen] = await Promise.all([
    ladeKnotenDaten(),
    ladeDiskursDaten(),
    ladeFinanzDaten()
  ]);

  layerManager.updateData({ knoten, diskurse, finanzen });

  rolleService.restore();
  initialisiereZeitleiste();

  return { knoten, diskurse, finanzen };
}

// --- Datei: Launchweb/index.html ---

<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weltweberei</title>

  <!-- Styles -->
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
  <div id="map" class="leaflet-container"></div>

  <!-- UI-Container -->
  <div id="ui-root">
    <div id="zeitsteuerung"></div>
    <div id="themenfilter"></div>
    <div id="webkasse-container"></div>
    <div id="knotenfenster"></div>
    <div id="form-overlay"></div>
    <div id="form-container"></div>
    <div id="diskurs-container"></div>
    <div id="zeitreise-ui"></div>
    <div id="naehstuebchen-ui"></div>
    <div id="webrat-ui"></div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-d3-svg-overlay@3.0.0/leaflet-d3-svg-overlay.min.js"></script>
  <script type="module" src="./main.js"></script>
</body>
</html>

// --- Datei: Launchweb/engine-events.js ---

// engine-events.js — Version: Σ.v∞.event.bridge

export const EventEngine = {
    listeners: new Map(),

    on(eventName, callback) {
        if (!this.listeners.has(eventName)) {
            this.listeners.set(eventName, []);
        }
        this.listeners.get(eventName).push(callback);
    },

    emit(eventName, data) {
        const callbacks = this.listeners.get(eventName) || [];
        for (const fn of callbacks) {
            fn(data);
        }
    }
};

// --- Datei: Launchweb/system-meta.js ---

// system-meta.js — Version: Σ.v∞.setup.core

export const SystemMeta = {
    version: 'Σ.v∞.setup.core',
    entwicklungsmodus: true,
    aktiveModule: new Set([
        'knoten', 'faden', 'garn', 'antrag', 'verblassung', 'rollen', 'webkasse'
    ]),
    toggleModul(modulname) {
        if (this.aktiveModule.has(modulname)) {
            this.aktiveModule.delete(modulname);
        } else {
            this.aktiveModule.add(modulname);
        }
    },
    istAktiv(modulname) {
        return this.aktiveModule.has(modulname);
    }
};

// --- Datei: Launchweb/strukturbaum.txt ---

weltweberei/
├── index.html                    → Einstiegspunkt (Leaflet + UI-Struktur)
├── style.css                    → Grundlayout, farblich Weberei-konform
├── main.js                      → App-Starter: Kartenaufbau + Datenbindung
├── startup-loader.js            → Initialdaten, UI-Init, Layer-Setup
├── leaflet-setup.js             → Karte + Zeitachse + Keyevents

├── core/
│   ├── zeitlogik.js             → Blasszeiten, Garnhaltbarkeit, Zeitreise
│   ├── knotenerkennung.js       → Logik zur Auflösung und Persistenzprüfung
│   ├── verblasslogik.js         → Fadenverblassung etc.
│   └── manifest.js              → Manifest-Logik (aus `weltweb.txt`)

├── data/
│   ├── data-model.js            → Datenstrukturen: Knoten, Fäden, Garne
│   ├── data-knoten.js           → Knoten-spezifische Datenhaltung
│   ├── data-diskurs.js          → Diskursdaten: Gespräche, Beiträge, etc.
│   ├── data-finanz.js           → Webkassen-Datenhaltung
│   └── persistence-service.js (+.client, +.server)  → Datei-/Serverpersistenz (Filesystem/Backend)

├── services/
│   ├── api-service.js           → Generische API-Schicht
│   ├── api-diskurs.js           → Gesprächs-API
│   ├── api-knoten.js            → Knotendaten-API
│   ├── websocket-service.js     → Live-Daten
│   ├── websocket-integration.js → Events live synchronisieren
│   ├── auth-service.js          → Anmeldung & Rollenverknüpfung
│   └── file-storage.js          → Lokale Dateioperationen├── api-antrag.js           → API für Anträge
│   ├── api-verblassen.js       → API für Verblasslogik
│   ├── api-webung.js           → API für allgemeine Webungen


├── visual/
│   ├── render-knoten.js             → Visualisierung der Knoten
│   ├── render-faeden.js             → Darstellung aller Fäden
│   ├── render-garne.js              → Darstellung aller Garne
│   ├── render-antraege.js             → Darstellung Antragszyklen
│   ├── render-webkasse.js           → Darstellung Webkasse
│   └── colors.js                → Farbsemantik & Symbolfarben

├── ui/
│   ├── ui-core.js               → Grundinteraktionen & UI-Logik
│   ├── ui-interactions.js       → Buttons, Events, UI-Flows
│   ├── ui-themenfilter.js       → Filter für Knotentypen
│   ├── ui-login.js              → Loginmaske + Identifikation
│   ├── ui-ereignis.js           → Knoteninteraktionen
│   ├── ui-finanz.js             → Webkasseninterface

│   ├── knoten/
│   │   ├── ui-knoten.js         → Knotendarstellung (Info + Visu)
│   │   ├── knoten-engine.js     → Knotenanlage, Logik
│   │   └── knoten-form.js       → Formular zur Knotenerstellung

│   ├── diskurs/
│   │   ├── ui-diskurs.js        → Gesprächsfenster
│   │   ├── diskurs-engine.js    → Diskursverlauf + Webungslogik
│   │   └── diskurs-form.js      → Beiträge hinzufügen, Antrag starten

│   ├── antrag/
│   │   ├── ui-antrag.js         → Antrag-UI
│   │   ├── antrag-engine.js     → Zyklus-Logik
│   │   └── antrag-form.js       → Antragsformular

│   └── extras/
│       ├── ui-zeitreise.js      → Zeitleistensteuerung
│       ├── ui-webrat.js         → Ortunabhängige Debatte
│       ├── ui-naehstuebchen.js  → Plauderbereich
│       └── zeitleiste.js        → Visualisierung vergangener Webungen

├── utils/
│   ├── utility-core.js          → Allg. Hilfsfunktionen
│   ├── utility-tooltip.js       → Tooltip-System
│   ├── form-components.js       → Felder, Dropdowns etc.
│   ├── validation.js            → Formprüfungen
│   └── utils.js                 → Alles sonstige

└── models/
    ├── user-model.js            → Rollenstruktur, Fadenverhalten
    └── knotentypen.js           → Definition & Farben aller Knotentypen

// --- Datei: Launchweb/main.js ---

import { initKarte } from './leaflet-setup.js';
import { startupLoader } from './startup-loader.js';
import { EventEngine } from './engine-events.js';
import { registriereSymbolRenderEvents } from './init-events.js';
import { SystemMeta } from './system-meta.js';

registriereSymbolRenderEvents();

async function startApp() {
  const map = initKarte();
  const daten = await startupLoader();

  const moduleMap = {
    'knoten': 'renderKnoten',
    'fäden': 'renderFäden',
    'garne': 'renderGarne',
    'anträge': 'renderAntraege',
    'webkasse': 'renderWebkasse'
  };

  for (const [modul, eventName] of Object.entries(moduleMap)) {
    if (SystemMeta.istAktiv(modul)) {
      EventEngine.emit(eventName, { map, daten });
    } else {
      console.log(`⛔ Modul "${modul}" inaktiv – ${eventName} übersprungen`);
    }
  }

  console.log('✅ Startup abgeschlossen: Alle aktiven Layer ausgelöst');
}

startApp();

// --- Datei: Launchweb/merged-weltweb.txt ---



// --- Datei: Launchweb/init-events.js ---

// init-events.js — Version: Σ.v∞.event.link.symbols

import { EventEngine } from './engine-events.js';
import { renderGarne } from './visual/render-garne.js';
import { renderAntraege } from './visual/render-antraege.js';
import { renderWebkasse } from './visual/render-webkasse.js';

/**
 * Verbindet Symbol-Renderer (Garne, Anträge, Webkasse) mit der EventEngine
 */
export function registriereSymbolRenderEvents() {
  EventEngine.on('renderGarne', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderGarne(map._svgLayer, map._projection, daten.webungen);
  });

  EventEngine.on('renderAntraege', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderAntraege(map._svgLayer, map._projection, daten.webungen);
  });

  EventEngine.on('renderWebkasse', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderWebkasse(map._svgLayer, map._projection, daten, () => {}, () => {});
  });
}

// --- Datei: Launchweb/startup-loader.js ---

import { ladeKnotenDaten } from './render-knoten.js';
import { ladeDiskursDaten } from './render-diskurse.js';
import { ladeFinanzDaten } from './render-webkasse.js';
import { layerManager } from './layer-manager.js';
import { rolleService } from './rolle-service.js';
import { initialisiereZeitleiste } from './zeitleiste.js';

export async function startupLoader() {
  const [knoten, diskurse, finanzen] = await Promise.all([
    ladeKnotenDaten(),
    ladeDiskursDaten(),
    ladeFinanzDaten()
  ]);

  layerManager.updateData({ knoten, diskurse, finanzen });

  rolleService.restore();
  initialisiereZeitleiste();

  return { knoten, diskurse, finanzen };
}

// --- Datei: Launchweb/index.html ---

<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weltweberei</title>

  <!-- Styles -->
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
  <div id="map" class="leaflet-container"></div>

  <!-- UI-Container -->
  <div id="ui-root">
    <div id="zeitsteuerung"></div>
    <div id="themenfilter"></div>
    <div id="webkasse-container"></div>
    <div id="knotenfenster"></div>
    <div id="form-overlay"></div>
    <div id="form-container"></div>
    <div id="diskurs-container"></div>
    <div id="zeitreise-ui"></div>
    <div id="naehstuebchen-ui"></div>
    <div id="webrat-ui"></div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-d3-svg-overlay@3.0.0/leaflet-d3-svg-overlay.min.js"></script>
  <script type="module" src="./main.js"></script>
</body>
</html>

// --- Datei: Launchweb/engine-events.js ---

// engine-events.js — Version: Σ.v∞.event.bridge

export const EventEngine = {
    listeners: new Map(),

    on(eventName, callback) {
        if (!this.listeners.has(eventName)) {
            this.listeners.set(eventName, []);
        }
        this.listeners.get(eventName).push(callback);
    },

    emit(eventName, data) {
        const callbacks = this.listeners.get(eventName) || [];
        for (const fn of callbacks) {
            fn(data);
        }
    }
};

// --- Datei: Launchweb/system-meta.js ---

// system-meta.js — Version: Σ.v∞.setup.core

export const SystemMeta = {
    version: 'Σ.v∞.setup.core',
    entwicklungsmodus: true,
    aktiveModule: new Set([
        'knoten', 'faden', 'garn', 'antrag', 'verblassung', 'rollen', 'webkasse'
    ]),
    toggleModul(modulname) {
        if (this.aktiveModule.has(modulname)) {
            this.aktiveModule.delete(modulname);
        } else {
            this.aktiveModule.add(modulname);
        }
    },
    istAktiv(modulname) {
        return this.aktiveModule.has(modulname);
    }
};

// --- Datei: Launchweb/strukturbaum.txt ---

weltweberei/
├── index.html                    → Einstiegspunkt (Leaflet + UI-Struktur)
├── style.css                    → Grundlayout, farblich Weberei-konform
├── main.js                      → App-Starter: Kartenaufbau + Datenbindung
├── startup-loader.js            → Initialdaten, UI-Init, Layer-Setup
├── leaflet-setup.js             → Karte + Zeitachse + Keyevents

├── core/
│   ├── zeitlogik.js             → Blasszeiten, Garnhaltbarkeit, Zeitreise
│   ├── knotenerkennung.js       → Logik zur Auflösung und Persistenzprüfung
│   ├── verblasslogik.js         → Fadenverblassung etc.
│   └── manifest.js              → Manifest-Logik (aus `weltweb.txt`)

├── data/
│   ├── data-model.js            → Datenstrukturen: Knoten, Fäden, Garne
│   ├── data-knoten.js           → Knoten-spezifische Datenhaltung
│   ├── data-diskurs.js          → Diskursdaten: Gespräche, Beiträge, etc.
│   ├── data-finanz.js           → Webkassen-Datenhaltung
│   └── persistence-service.js (+.client, +.server)  → Datei-/Serverpersistenz (Filesystem/Backend)

├── services/
│   ├── api-service.js           → Generische API-Schicht
│   ├── api-diskurs.js           → Gesprächs-API
│   ├── api-knoten.js            → Knotendaten-API
│   ├── websocket-service.js     → Live-Daten
│   ├── websocket-integration.js → Events live synchronisieren
│   ├── auth-service.js          → Anmeldung & Rollenverknüpfung
│   └── file-storage.js          → Lokale Dateioperationen├── api-antrag.js           → API für Anträge
│   ├── api-verblassen.js       → API für Verblasslogik
│   ├── api-webung.js           → API für allgemeine Webungen


├── visual/
│   ├── render-knoten.js             → Visualisierung der Knoten
│   ├── render-faeden.js             → Darstellung aller Fäden
│   ├── render-garne.js              → Darstellung aller Garne
│   ├── render-antraege.js             → Darstellung Antragszyklen
│   ├── render-webkasse.js           → Darstellung Webkasse
│   └── colors.js                → Farbsemantik & Symbolfarben

├── ui/
│   ├── ui-core.js               → Grundinteraktionen & UI-Logik
│   ├── ui-interactions.js       → Buttons, Events, UI-Flows
│   ├── ui-themenfilter.js       → Filter für Knotentypen
│   ├── ui-login.js              → Loginmaske + Identifikation
│   ├── ui-ereignis.js           → Knoteninteraktionen
│   ├── ui-finanz.js             → Webkasseninterface

│   ├── knoten/
│   │   ├── ui-knoten.js         → Knotendarstellung (Info + Visu)
│   │   ├── knoten-engine.js     → Knotenanlage, Logik
│   │   └── knoten-form.js       → Formular zur Knotenerstellung

│   ├── diskurs/
│   │   ├── ui-diskurs.js        → Gesprächsfenster
│   │   ├── diskurs-engine.js    → Diskursverlauf + Webungslogik
│   │   └── diskurs-form.js      → Beiträge hinzufügen, Antrag starten

│   ├── antrag/
│   │   ├── ui-antrag.js         → Antrag-UI
│   │   ├── antrag-engine.js     → Zyklus-Logik
│   │   └── antrag-form.js       → Antragsformular

│   └── extras/
│       ├── ui-zeitreise.js      → Zeitleistensteuerung
│       ├── ui-webrat.js         → Ortunabhängige Debatte
│       ├── ui-naehstuebchen.js  → Plauderbereich
│       └── zeitleiste.js        → Visualisierung vergangener Webungen

├── utils/
│   ├── utility-core.js          → Allg. Hilfsfunktionen
│   ├── utility-tooltip.js       → Tooltip-System
│   ├── form-components.js       → Felder, Dropdowns etc.
│   ├── validation.js            → Formprüfungen
│   └── utils.js                 → Alles sonstige

└── models/
    ├── user-model.js            → Rollenstruktur, Fadenverhalten
    └── knotentypen.js           → Definition & Farben aller Knotentypen

// --- Datei: Launchweb/main.js ---

import { initKarte } from './leaflet-setup.js';
import { startupLoader } from './startup-loader.js';
import { EventEngine } from './engine-events.js';
import { registriereSymbolRenderEvents } from './init-events.js';
import { SystemMeta } from './system-meta.js';

registriereSymbolRenderEvents();

async function startApp() {
  const map = initKarte();
  const daten = await startupLoader();

  if (SystemMeta.istAktiv('knoten')) {
    EventEngine.emit('renderKnoten', { map, daten });
  }

  if (SystemMeta.istAktiv('fäden')) {
    EventEngine.emit('renderFäden', { map, daten });
  }

  if (SystemMeta.istAktiv('garne')) {
    EventEngine.emit('renderGarne', { map, daten });
  }

  if (SystemMeta.istAktiv('anträge')) {
    EventEngine.emit('renderAntraege', { map, daten });
  }

  if (SystemMeta.istAktiv('webkasse')) {
    EventEngine.emit('renderWebkasse', { map, daten });
  }

  console.log('✅ Weltweberei sichtbar: Alle aktiven Layer gerendert');
}

startApp();

// --- Datei: Launchweb/merged-weltweb.txt ---



// --- Datei: Launchweb/init-events.js ---

// init-events.js — Version: Σ.v∞.event.link.symbols

import { EventEngine } from './engine-events.js';
import { renderGarne } from './visual/render-garne.js';
import { renderAntraege } from './visual/render-antraege.js';
import { renderWebkasse } from './visual/render-webkasse.js';

/**
 * Verbindet Symbol-Renderer (Garne, Anträge, Webkasse) mit der EventEngine
 */
export function registriereSymbolRenderEvents() {
  EventEngine.on('renderGarne', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderGarne(map._svgLayer, map._projection, daten.webungen);
  });

  EventEngine.on('renderAntraege', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderAntraege(map._svgLayer, map._projection, daten.webungen);
  });

  EventEngine.on('renderWebkasse', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderWebkasse(map._svgLayer, map._projection, daten, () => {}, () => {});
  });
}

// --- Datei: Launchweb/startup-loader.js ---

import { ladeKnotenDaten } from './render-knoten.js';
import { ladeDiskursDaten } from './render-diskurse.js';
import { ladeFinanzDaten } from './render-webkasse.js';
import { layerManager } from './layer-manager.js';
import { rolleService } from './rolle-service.js';
import { initialisiereZeitleiste } from './zeitleiste.js';

export async function startupLoader() {
  const [knoten, diskurse, finanzen] = await Promise.all([
    ladeKnotenDaten(),
    ladeDiskursDaten(),
    ladeFinanzDaten()
  ]);

  layerManager.updateData({ knoten, diskurse, finanzen });

  rolleService.restore();
  initialisiereZeitleiste();

  return { knoten, diskurse, finanzen };
}

// --- Datei: Launchweb/index.html ---

<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weltweberei</title>

  <!-- Styles -->
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
  <div id="map" class="leaflet-container"></div>

  <!-- UI-Container -->
  <div id="ui-root">
    <div id="zeitsteuerung"></div>
    <div id="themenfilter"></div>
    <div id="webkasse-container"></div>
    <div id="knotenfenster"></div>
    <div id="form-overlay"></div>
    <div id="form-container"></div>
    <div id="diskurs-container"></div>
    <div id="zeitreise-ui"></div>
    <div id="naehstuebchen-ui"></div>
    <div id="webrat-ui"></div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-d3-svg-overlay@3.0.0/leaflet-d3-svg-overlay.min.js"></script>
  <script type="module" src="./main.js"></script>
</body>
</html>

// --- Datei: Launchweb/engine-events.js ---

// engine-events.js — Version: Σ.v∞.event.bridge

export const EventEngine = {
    listeners: new Map(),

    on(eventName, callback) {
        if (!this.listeners.has(eventName)) {
            this.listeners.set(eventName, []);
        }
        this.listeners.get(eventName).push(callback);
    },

    emit(eventName, data) {
        const callbacks = this.listeners.get(eventName) || [];
        for (const fn of callbacks) {
            fn(data);
        }
    }
};

// --- Datei: Launchweb/system-meta.js ---

// system-meta.js — Version: Σ.v∞.setup.core

export const SystemMeta = {
    version: 'Σ.v∞.setup.core',
    entwicklungsmodus: true,
    aktiveModule: new Set([
        'knoten', 'faden', 'garn', 'antrag', 'verblassung', 'rollen', 'webkasse'
    ]),
    toggleModul(modulname) {
        if (this.aktiveModule.has(modulname)) {
            this.aktiveModule.delete(modulname);
        } else {
            this.aktiveModule.add(modulname);
        }
    },
    istAktiv(modulname) {
        return this.aktiveModule.has(modulname);
    }
};

// --- Datei: Launchweb/strukturbaum.txt ---

weltweberei/
├── index.html                    → Einstiegspunkt (Leaflet + UI-Struktur)
├── style.css                    → Grundlayout, farblich Weberei-konform
├── main.js                      → App-Starter: Kartenaufbau + Datenbindung
├── startup-loader.js            → Initialdaten, UI-Init, Layer-Setup
├── leaflet-setup.js             → Karte + Zeitachse + Keyevents

├── core/
│   ├── zeitlogik.js             → Blasszeiten, Garnhaltbarkeit, Zeitreise
│   ├── knotenerkennung.js       → Logik zur Auflösung und Persistenzprüfung
│   ├── verblasslogik.js         → Fadenverblassung etc.
│   └── manifest.js              → Manifest-Logik (aus `weltweb.txt`)

├── data/
│   ├── data-model.js            → Datenstrukturen: Knoten, Fäden, Garne
│   ├── data-knoten.js           → Knoten-spezifische Datenhaltung
│   ├── data-diskurs.js          → Diskursdaten: Gespräche, Beiträge, etc.
│   ├── data-finanz.js           → Webkassen-Datenhaltung
│   └── persistence-service.js (+.client, +.server)  → Datei-/Serverpersistenz (Filesystem/Backend)

├── services/
│   ├── api-service.js           → Generische API-Schicht
│   ├── api-diskurs.js           → Gesprächs-API
│   ├── api-knoten.js            → Knotendaten-API
│   ├── websocket-service.js     → Live-Daten
│   ├── websocket-integration.js → Events live synchronisieren
│   ├── auth-service.js          → Anmeldung & Rollenverknüpfung
│   └── file-storage.js          → Lokale Dateioperationen├── api-antrag.js           → API für Anträge
│   ├── api-verblassen.js       → API für Verblasslogik
│   ├── api-webung.js           → API für allgemeine Webungen


├── visual/
│   ├── render-knoten.js             → Visualisierung der Knoten
│   ├── render-faeden.js             → Darstellung aller Fäden
│   ├── render-garne.js              → Darstellung aller Garne
│   ├── render-antraege.js             → Darstellung Antragszyklen
│   ├── render-webkasse.js           → Darstellung Webkasse
│   └── colors.js                → Farbsemantik & Symbolfarben

├── ui/
│   ├── ui-core.js               → Grundinteraktionen & UI-Logik
│   ├── ui-interactions.js       → Buttons, Events, UI-Flows
│   ├── ui-themenfilter.js       → Filter für Knotentypen
│   ├── ui-login.js              → Loginmaske + Identifikation
│   ├── ui-ereignis.js           → Knoteninteraktionen
│   ├── ui-finanz.js             → Webkasseninterface

│   ├── knoten/
│   │   ├── ui-knoten.js         → Knotendarstellung (Info + Visu)
│   │   ├── knoten-engine.js     → Knotenanlage, Logik
│   │   └── knoten-form.js       → Formular zur Knotenerstellung

│   ├── diskurs/
│   │   ├── ui-diskurs.js        → Gesprächsfenster
│   │   ├── diskurs-engine.js    → Diskursverlauf + Webungslogik
│   │   └── diskurs-form.js      → Beiträge hinzufügen, Antrag starten

│   ├── antrag/
│   │   ├── ui-antrag.js         → Antrag-UI
│   │   ├── antrag-engine.js     → Zyklus-Logik
│   │   └── antrag-form.js       → Antragsformular

│   └── extras/
│       ├── ui-zeitreise.js      → Zeitleistensteuerung
│       ├── ui-webrat.js         → Ortunabhängige Debatte
│       ├── ui-naehstuebchen.js  → Plauderbereich
│       └── zeitleiste.js        → Visualisierung vergangener Webungen

├── utils/
│   ├── utility-core.js          → Allg. Hilfsfunktionen
│   ├── utility-tooltip.js       → Tooltip-System
│   ├── form-components.js       → Felder, Dropdowns etc.
│   ├── validation.js            → Formprüfungen
│   └── utils.js                 → Alles sonstige

└── models/
    ├── user-model.js            → Rollenstruktur, Fadenverhalten
    └── knotentypen.js           → Definition & Farben aller Knotentypen

// --- Datei: Launchweb/main.js ---

// main.js — Version: Σ.v∞.main.symbol.aktiviert+fix

import { initKarte } from './leaflet-setup.js';
import { startupLoader } from './startup-loader.js'; // ✅ FIX
import { SystemMeta } from './system-meta.js';
import { EventEngine } from './engine-events.js';
import { registriereSymbolRenderEvents } from './init-events.js';

registriereSymbolRenderEvents();

async function startApp() {
    const map = initKarte();
    const daten = await startupLoader(); // ✅ FIX

    EventEngine.emit('datenGeladen', daten);

    if (SystemMeta.istAktiv('knoten')) {
        EventEngine.emit('renderKnoten', { map, daten });
    }

    if (SystemMeta.istAktiv('faden')) {
        EventEngine.emit('renderFäden', { map, daten });
    }

    if (SystemMeta.istAktiv('garn')) {
        EventEngine.emit('renderGarne', { map, daten });
    }

    if (SystemMeta.istAktiv('antraege')) {
        EventEngine.emit('renderAntraege', { map, daten });
    }

    if (SystemMeta.istAktiv('webkasse')) {
        EventEngine.emit('renderWebkasse', { map, daten });
    }

    if (SystemMeta.entwicklungsmodus) {
        console.log('🧶 Weltweberei gestartet im Entwicklungsmodus', SystemMeta.version);
    }
}

startApp();

// --- Datei: Launchweb/merged-weltweb.txt ---



// --- Datei: Launchweb/init-events.js ---

// init-events.js — Version: Σ.v∞.event.link.symbols

import { EventEngine } from './engine-events.js';
import { renderGarne } from './visual/render-garne.js';
import { renderAntraege } from './visual/render-antraege.js';
import { renderWebkasse } from './visual/render-webkasse.js';

/**
 * Verbindet Symbol-Renderer (Garne, Anträge, Webkasse) mit der EventEngine
 */
export function registriereSymbolRenderEvents() {
  EventEngine.on('renderGarne', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderGarne(map._svgLayer, map._projection, daten.webungen);
  });

  EventEngine.on('renderAntraege', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderAntraege(map._svgLayer, map._projection, daten.webungen);
  });

  EventEngine.on('renderWebkasse', ({ map, daten }) => {
    if (!map._svgLayer || !map._projection) return;
    renderWebkasse(map._svgLayer, map._projection, daten, () => {}, () => {});
  });
}

// --- Datei: Launchweb/startup-loader.js ---

// startup-loader.js — Version: Σ.v1.init.startup

import { ladeKnotenDaten } from './data/data-knoten.js';
import { ladeDiskursDaten } from './data/data-diskurs.js';
import { ladeFinanzDaten } from './data/data-finanz.js';
import { initialisiereZeitleiste } from './core/zeitlogik.js';
import { rolleService } from './models/user-model.js';
import { LayerManager } from './ui/layer/layer-manager.js';
layerManager.registerLayer('knoten', renderKnoten);
layerManager.registerLayer('faeden', renderFaeden);
// usw.

export async function startupLoader() {
    const [knoten, diskurse, finanzen] = await Promise.all([
        ladeKnotenDaten(),
        ladeDiskursDaten(),
        ladeFinanzDaten()
    ]);

    LayerManager.getInstance().updateData({ knoten, diskurse, finanzen });

    rolleService.restore(); // z. B. aus localStorage

    initialisiereZeitleiste();
}

// --- Datei: Launchweb/index.html ---

<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weltweberei</title>

  <!-- Styles -->
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
  <div id="map" class="leaflet-container"></div>

  <!-- UI-Container -->
  <div id="ui-root">
    <div id="zeitsteuerung"></div>
    <div id="themenfilter"></div>
    <div id="webkasse-container"></div>
    <div id="knotenfenster"></div>
    <div id="form-overlay"></div>
    <div id="form-container"></div>
    <div id="diskurs-container"></div>
    <div id="zeitreise-ui"></div>
    <div id="naehstuebchen-ui"></div>
    <div id="webrat-ui"></div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-d3-svg-overlay@3.0.0/leaflet-d3-svg-overlay.min.js"></script>
  <script type="module" src="./main.js"></script>
</body>
</html>

// --- Datei: Launchweb/engine-events.js ---

// engine-events.js — Version: Σ.v∞.event.bridge

export const EventEngine = {
    listeners: new Map(),

    on(eventName, callback) {
        if (!this.listeners.has(eventName)) {
            this.listeners.set(eventName, []);
        }
        this.listeners.get(eventName).push(callback);
    },

    emit(eventName, data) {
        const callbacks = this.listeners.get(eventName) || [];
        for (const fn of callbacks) {
            fn(data);
        }
    }
};

// --- Datei: Launchweb/system-meta.js ---

// system-meta.js — Version: Σ.v∞.setup.core

export const SystemMeta = {
    version: 'Σ.v∞.setup.core',
    entwicklungsmodus: true,
    aktiveModule: new Set([
        'knoten', 'faden', 'garn', 'antrag', 'verblassung', 'rollen', 'webkasse'
    ]),
    toggleModul(modulname) {
        if (this.aktiveModule.has(modulname)) {
            this.aktiveModule.delete(modulname);
        } else {
            this.aktiveModule.add(modulname);
        }
    },
    istAktiv(modulname) {
        return this.aktiveModule.has(modulname);
    }
};

// --- Datei: Launchweb/strukturbaum.txt ---

weltweberei/
├── index.html                    → Einstiegspunkt (Leaflet + UI-Struktur)
├── style.css                    → Grundlayout, farblich Weberei-konform
├── main.js                      → App-Starter: Kartenaufbau + Datenbindung
├── startup-loader.js            → Initialdaten, UI-Init, Layer-Setup
├── leaflet-setup.js             → Karte + Zeitachse + Keyevents

├── core/
│   ├── zeitlogik.js             → Blasszeiten, Garnhaltbarkeit, Zeitreise
│   ├── knotenerkennung.js       → Logik zur Auflösung und Persistenzprüfung
│   ├── verblasslogik.js         → Fadenverblassung etc.
│   └── manifest.js              → Manifest-Logik (aus `weltweb.txt`)

├── data/
│   ├── data-model.js            → Datenstrukturen: Knoten, Fäden, Garne
│   ├── data-knoten.js           → Knoten-spezifische Datenhaltung
│   ├── data-diskurs.js          → Diskursdaten: Gespräche, Beiträge, etc.
│   ├── data-finanz.js           → Webkassen-Datenhaltung
│   └── persistence-service.js (+.client, +.server)  → Datei-/Serverpersistenz (Filesystem/Backend)

├── services/
│   ├── api-service.js           → Generische API-Schicht
│   ├── api-diskurs.js           → Gesprächs-API
│   ├── api-knoten.js            → Knotendaten-API
│   ├── websocket-service.js     → Live-Daten
│   ├── websocket-integration.js → Events live synchronisieren
│   ├── auth-service.js          → Anmeldung & Rollenverknüpfung
│   └── file-storage.js          → Lokale Dateioperationen├── api-antrag.js           → API für Anträge
│   ├── api-verblassen.js       → API für Verblasslogik
│   ├── api-webung.js           → API für allgemeine Webungen


├── visual/
│   ├── render-knoten.js             → Visualisierung der Knoten
│   ├── render-faeden.js             → Darstellung aller Fäden
│   ├── render-garne.js              → Darstellung aller Garne
│   ├── render-antraege.js             → Darstellung Antragszyklen
│   ├── render-webkasse.js           → Darstellung Webkasse
│   └── colors.js                → Farbsemantik & Symbolfarben

├── ui/
│   ├── ui-core.js               → Grundinteraktionen & UI-Logik
│   ├── ui-interactions.js       → Buttons, Events, UI-Flows
│   ├── ui-themenfilter.js       → Filter für Knotentypen
│   ├── ui-login.js              → Loginmaske + Identifikation
│   ├── ui-ereignis.js           → Knoteninteraktionen
│   ├── ui-finanz.js             → Webkasseninterface

│   ├── knoten/
│   │   ├── ui-knoten.js         → Knotendarstellung (Info + Visu)
│   │   ├── knoten-engine.js     → Knotenanlage, Logik
│   │   └── knoten-form.js       → Formular zur Knotenerstellung

│   ├── diskurs/
│   │   ├── ui-diskurs.js        → Gesprächsfenster
│   │   ├── diskurs-engine.js    → Diskursverlauf + Webungslogik
│   │   └── diskurs-form.js      → Beiträge hinzufügen, Antrag starten

│   ├── antrag/
│   │   ├── ui-antrag.js         → Antrag-UI
│   │   ├── antrag-engine.js     → Zyklus-Logik
│   │   └── antrag-form.js       → Antragsformular

│   └── extras/
│       ├── ui-zeitreise.js      → Zeitleistensteuerung
│       ├── ui-webrat.js         → Ortunabhängige Debatte
│       ├── ui-naehstuebchen.js  → Plauderbereich
│       └── zeitleiste.js        → Visualisierung vergangener Webungen

├── utils/
│   ├── utility-core.js          → Allg. Hilfsfunktionen
│   ├── utility-tooltip.js       → Tooltip-System
│   ├── form-components.js       → Felder, Dropdowns etc.
│   ├── validation.js            → Formprüfungen
│   └── utils.js                 → Alles sonstige

└── models/
    ├── user-model.js            → Rollenstruktur, Fadenverhalten
    └── knotentypen.js           → Definition & Farben aller Knotentypen

// --- Datei: Launchweb/main.js ---

// main.js — Version: Σ.v∞.main.symbol.aktiviert+fix

import { initKarte } from './leaflet-setup.js';
import { startupLoader } from './startup-loader.js'; // ✅ FIX
import { SystemMeta } from './system-meta.js';
import { EventEngine } from './engine-events.js';
import { registriereSymbolRenderEvents } from './init-events.js';

registriereSymbolRenderEvents();

async function startApp() {
    const map = initKarte();
    const daten = await startupLoader(); // ✅ FIX

    EventEngine.emit('datenGeladen', daten);

    if (SystemMeta.istAktiv('knoten')) {
        EventEngine.emit('renderKnoten', { map, daten });
    }

    if (SystemMeta.istAktiv('faden')) {
        EventEngine.emit('renderFäden', { map, daten });
    }

    if (SystemMeta.istAktiv('garn')) {
        EventEngine.emit('renderGarne', { map, daten });
    }

    if (SystemMeta.istAktiv('antraege')) {
        EventEngine.emit('renderAntraege', { map, daten });
    }

    if (SystemMeta.istAktiv('webkasse')) {
        EventEngine.emit('renderWebkasse', { map, daten });
    }

    if (SystemMeta.entwicklungsmodus) {
        console.log('🧶 Weltweberei gestartet im Entwicklungsmodus', SystemMeta.version);
    }
}

startApp();

// --- Datei: Launchweb/leaflet-setup.js ---

// leaflet-setup.js — Version: Σ.v∞.2.event-kompatibel

import { renderKnoten } from './visual/render-knoten.js';
import { renderFaeden } from './visual/render-faeden.js';
import { renderGarne } from './visual/render-garne.js';
import { renderAntraege } from './visual/render-antraege.js';
import { renderWebkasse } from './visual/render-webkasse.js';

/**
 * Initialisiert die Leaflet-Karte und legt das SVG-Overlay an.
 */
export function initKarte() {
  const map = L.map('map').setView([53.55, 10.0], 6);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);

  const svgLayer = L.d3SvgOverlay((selection, projection) => {
    map._svgLayer = selection;
    map._projection = projection;
  });

  svgLayer.addTo(map);
  svgLayer.requestRender();

  return map;
}

// --- Datei: Launchweb/style.css ---

/* style.css — Version: Σ.v1.0.webstruktur */

html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: system-ui, sans-serif;
    background-color: #fdfaf6;
}

#map {
    height: 100%;
    width: 100%;
}

.overlay {
    position: absolute;
    top: 10%;
    left: 10%;
    width: 80%;
    max-height: 80%;
    background: white;
    border: 2px solid #ccc;
    border-radius: 8px;
    padding: 1em;
    box-shadow: 0 0 10px rgba(0,0,0,0.2);
    overflow-y: auto;
    z-index: 1000;
}

.overlay.hidden {
    display: none;
}

.info-panel {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background: rgba(255,255,255,0.95);
    padding: 1em;
    border-top: 2px solid #ccc;
    display: none;
    z-index: 900;
}

.info-panel.visible {
    display: block;
}

#ui-controls {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 1100;
}

#ui-controls button {
    padding: 0.5em 1em;
    font-size: 1em;
    border-radius: 4px;
    border: none;
    background-color: #333;
    color: white;
    cursor: pointer;
    transition: background 0.2s;
}

#ui-controls button:hover {
    background-color: #555;
}

/* Tooltip-Styling (für utility-tooltip.js) */
.tooltip {
    position: absolute;
    background: #fff;
    padding: 0.5em 0.8em;
    border-radius: 4px;
    border: 1px solid #ccc;
    font-size: 0.9em;
    pointer-events: none;
    box-shadow: 0 0 5px rgba(0,0,0,0.1);
    z-index: 2000;
}

/* Farben aus visual/colors.js könnten per Klasse nachgeladen werden */

.layer-controls {
    position: absolute;
    top: 1em;
    right: 1em;
    background: rgba(255, 255, 255, 0.8);
    padding: 0.5em;
    border-radius: 5px;
    font-size: 0.9em;
}

.layer-toggle-label {
    display: block;
    margin: 0.2em 0;
}

// --- Datei: Launchweb/weltweb.txt ---



⸻

Manifest der Weltweberei


⸻

🧶 Webung

Webung bezeichnet jede Handlung, mit der ein Weber über seine Rolle in die Welt eingreift.
	•	Die Rolle ist visuell verankert an einem festen Ort auf der Leaflet-Karte, identifiziert über eine ID bei Registrierung.
	•	Eine Webung erzeugt eine Verbindung von der Rolle zu einem beliebigen Punkt auf der Karte – entweder:
	•	als Faden: temporär (verblasst innerhalb von 7 Tagen)
	•	als Garn: dauerhaft (bis zur aktiven Auflösung)

Eine Webung entsteht z. B. durch:
	•	Erstellen eines Knotens (Informationspunkt mit Kontext)
	•	Teilnahme an einem Gespräch
	•	Stellung eines Antrags
	•	Abgabe einer Zusage

	der Weber entscheidet selbst, ob er Faden oder Garn benutzt. Garn gilt als verbindliche Zusage.
	auch im Nachhinein kann ein Weber seine Rolle mit einem Knoten verbinden, wenn er beispielsweise physisch an einem Ereignis zugegen war und seine Mitwirkung nun dokumentieren möchte
⸻

🪢 Knoten

Ein Knoten entsteht, wenn ein Weber eine neue Webung mit Informationsinhalt an einem Ort auf der Karte vornimmt.
	•	Der Knoten ist Träger:
	•	von Informationen (z. B. Ankündigungen, Hinweise)
	•	von Gesprächsmöglichkeiten (Diskurs)
	•	von Anträgen (siehe unten)
	•	Weitere Webungen anderer Weber verknüpfen sich automatisch mit dem Knoten.
	•	Ein Knoten löst sich auf, wenn kein Faden und kein Garn mehr mit ihm verbunden ist.

Darstellung:
	•	Standardmäßig als visueller Knoten dargestellt
	•	Material: abgeleitet aus den verbundenen Fäden und Garne
	•	Visualisierung kann vom ursprünglichen Weber selbst angepasst werden

⸻

🧭 Webkasse

Die Webkasse ist das Gemeinschaftskonto der Ortsweberei.
Sie ist der exklusive Ort für Geldauszahlungsanträge.

⸻

🧾 Anträge
	•	Können gestellt werden auf:
	•	Geldauszahlung (→ nur über Knotenknüpfung auf Webkasse, heißen Goldantrag und sind mit goldenem Rand versehen)
	•	Veränderung
	•	Anschaffung
	•	alles mögliche

Visualisierung:
	•	Blauer Faden bei Stellung
	•	Lila Faden bei Einspruch (binnen 7 Tagen möglich)
	•	Grüner Faden bei Annahme
– automatisch 7 Tage nach Antragstellung (ohne Einspruch)
– bei Einspruch: Abstimmung 7 Tage nach Einspruch
	•	Roter Faden bei Ablehnung
	•	Goldener Rand bei Goldanträgen
	•	Jeder Antragsfaden verblasst 7 Tage nach Entscheidung

⸻

🧵 Extraräume
	•	Nähstübchen → Raum zum freien Plaudern
	•	Webrat → Diskussionen zu orts- und ereignisunabhängigen Themen

⸻

🗓️ Zeitleiste / Auditfunktion
	•	Navigierbare Zeitleiste, um vergangene Webungen auditierbar zu halten
	•	Zeitreise: Tag-für-Tag, einstellbare Geschwindigkeit
	•	Statische Zeitfenster: frei wählbare Intervalle (z. B. 1 Woche, 1 Monat etc.)

⸻

📱 Mobile first!

Alle Funktionalitäten und Interfaces sind von Grund auf für mobile Nutzung optimiert.


Wenn ein Weber an einem Gespräch teilnimmt, dann webt sich automatisch ein Faden von seiner Rolle in den Gesprächsraum. Solch ein Faden verschwindet ja sukzessive wieder innerhalb einer Woche. Wenn ein Weber dann aber in diesem Zeitraum weitere Beiträge in demselben Knoten tätigt, dann wird der Faden dicker (immer proportional zu der zeitlich überlappenden Anzahl der Beiträge. Dabei ist jeder Faden (zumindest anteilig) visuell vertreten (mit seiner jeweiligen Farbe und Transparenz))
Garn wiederum steht ja für verbindliche Zusagen und bleibt als stabile Verbindung zwischen Rolle und knoten, bis entweder der knoten Aufgelöst wird oder die Zusage abgebrochen wird. Garn erkennt man an der gezwirnten Optik (oder welche Optik Garn auch immer hat). Ist ein Ereignis vergangen (und hat sich also die Zusage in Tat umgewandelt) wird der knoten und die zu ihm führenden Fäden und Garne grau und verschwindet im laufe einer Woche sukzessive.

weltweberei/
├── index.html                    → Einstiegspunkt (Leaflet + UI-Struktur)
├── style.css                    → Grundlayout, farblich Weberei-konform
├── main.js                      → App-Starter: Kartenaufbau + Datenbindung
├── startup-loader.js            → Initialdaten, UI-Init, Layer-Setup
├── leaflet-setup.js             → Karte + Zeitachse + Keyevents

├── core/
    --- webung-engine.js
│   ├── zeitlogik.js             → Blasszeiten, Garnhaltbarkeit, Zeitreise
│   ├── knotenerkennung.js       → Logik zur Auflösung und Persistenzprüfung
│   ├── verblasslogik.js         → Fadenverblassung etc.
│   └── manifest.js              → Manifest-Logik (aus `weltweb.txt`)

├── data/
│   ├── data-model.js            → Datenstrukturen: Knoten, Fäden, Garne
│   ├── data-knoten.js           → Knoten-spezifische Datenhaltung
│   ├── data-diskurs.js          → Diskursdaten: Gespräche, Beiträge, etc.
│   ├── data-finanz.js           → Webkassen-Datenhaltung
│   └── persistence-service.js (+.client, +.server)  → Datei-/Serverpersistenz (Filesystem/Backend)

├── services/
│   ├── api-service.js           → Generische API-Schicht
│   ├── api-diskurs.js           → Gesprächs-API
│   ├── api-knoten.js            → Knotendaten-API
│   ├── websocket-service.js     → Live-Daten
│   ├── websocket-integration.js → Events live synchronisieren
│   ├── auth-service.js          → Anmeldung & Rollenverknüpfung
│   └── file-storage.js          → Lokale Dateioperationen├── api-antrag.js           → API für Anträge
│   ├── api-verblassen.js       → API für Verblasslogik
│   ├── api-webung.js           → API für allgemeine Webungen

├── visual/
│   ├── render-knoten.js             → Visualisierung der Knoten
│   ├── render-faeden.js             → Darstellung aller Fäden
│   ├── render-garne.js              → Darstellung aller Garne
│   ├── render-antraege.js             → Darstellung Antragszyklen
│   ├── render-webkasse.js           → Darstellung Webkasse
│   └── colors.js                → Farbsemantik & Symbolfarben

├── ui/
│   ├── ui-core.js               → Grundinteraktionen & UI-Logik
│   ├── ui-interactions.js       → Buttons, Events, UI-Flows
│   ├── ui-themenfilter.js       → Filter für Knotentypen
│   ├── ui-login.js              → Loginmaske + Identifikation
│   ├── ui-ereignis.js           → Knoteninteraktionen
│   ├── ui-finanz.js             → Webkasseninterface

│   ├── knoten/
│   │   ├── ui-knoten.js         → Knotendarstellung (Info + Visu)
│   │   ├── knoten-engine.js     → Knotenanlage, Logik
│   │   └── knoten-form.js       → Formular zur Knotenerstellung

│   ├── diskurs/
│   │   ├── ui-diskurs.js        → Gesprächsfenster
│   │   ├── diskurs-engine.js    → Diskursverlauf + Webungslogik
│   │   └── diskurs-form.js      → Beiträge hinzufügen, Antrag starten

│   ├── antrag/
│   │   ├── ui-antrag.js         → Antrag-UI
│   │   ├── antrag-engine.js     → Zyklus-Logik
│   │   └── antrag-form.js       → Antragsformular

│   └── extras/
│       ├── ui-zeitreise.js      → Zeitleistensteuerung
│       ├── ui-webrat.js         → Ortunabhängige Debatte
│       ├── ui-naehstuebchen.js  → Plauderbereich
│       └── zeitleiste.js        → Visualisierung vergangener Webungen

├── utils/
│   ├── utility-core.js          → Allg. Hilfsfunktionen
│   ├── utility-tooltip.js       → Tooltip-System
│   ├── form-components.js       → Felder, Dropdowns etc.
│   ├── validation.js            → Formprüfungen
│   └── utils.js                 → Alles sonstige

└── models/
    ├── user-model.js            → Rollenstruktur, Fadenverhalten
    └── knotentypen.js           → Definition & Farben aller Knotentypen

// --- Datei: Launchweb/ui/ui-ereignis.js ---

// ui-ereignis.js — Interaktion mit einzelnen Knotenpunkten

import { showKnotenInfo } from './knoten/ui-knoten.js';

export function setupEreignisInteraktion() {
    document.addEventListener('click', (e) => {
        const target = e.target.closest('.knotenpunkt');
        if (target) {
            const knotenId = target.dataset.knotenId;
            if (knotenId) {
                showKnotenInfo(knotenId);
            }
        }
    });
}

// --- Datei: Launchweb/ui/ui-interactions.js ---

// ui-interactions.js — Steuerung von Buttons und UI-Aktionen

export function setupUIInteractions() {
    const knotenButton = document.getElementById('neuer-knoten');
    const zeitreiseButton = document.getElementById('zeitreise-button');
	
	document.getElementById('toggle-faeden').addEventListener('click', () => {
    layerManager.toggleLayer('faeden');
    svgLayer.requestRender();
});

    if (knotenButton) {
        knotenButton.addEventListener('click', () => {
            alert('Knotenerstellung folgt.');
        });
    }

    if (zeitreiseButton) {
        zeitreiseButton.addEventListener('click', () => {
            alert('Zeitleiste wird aktiviert.');
        });
    }
}

// --- Datei: Launchweb/ui/ui-finanz.js ---

// ui-finanz.js — Webkassenanzeige & Interaktion

export function renderWebkasse(data) {
    const container = document.getElementById('webkasse-container');
    if (!container) return;

    const eintraege = data.map(eintrag => `
        <div class="buchung">
            <span class="betrag">${eintrag.betrag.toFixed(2)}€</span>
            <span class="zweck">${eintrag.zweck}</span>
            <span class="datum">${eintrag.datum}</span>
        </div>
    `).join('');

    container.innerHTML = `
        <h3>Webkasse</h3>
        <div class="eintraege">${eintraege}</div>
    `;
}

// --- Datei: Launchweb/ui/ui-themenfilter.js ---

// ui-themenfilter.js — Filterung nach Knotentypen (Farben, Kategorien)

export function initializeThemenfilter() {
    const filterElement = document.getElementById('themenfilter');

    if (!filterElement) return;

    filterElement.addEventListener('change', () => {
        const selected = filterElement.value;
        const event = new CustomEvent('filterChange', { detail: { selected } });
        window.dispatchEvent(event);
    });
}

// --- Datei: Launchweb/ui/ui-core.js ---

// ui-core.js — Version: uiΣ.v1.0.basismodul

export function initializeUICore() {
    const overlay = document.getElementById('webungs-overlay');
    const infoPanel = document.getElementById('knoten-info');

    function showOverlay(contentHtml) {
        overlay.innerHTML = contentHtml;
        overlay.classList.remove('hidden');
    }

    function hideOverlay() {
        overlay.classList.add('hidden');
        overlay.innerHTML = '';
    }

    function showInfo(contentHtml) {
        infoPanel.innerHTML = contentHtml;
        infoPanel.classList.remove('hidden');
    }

    function hideInfo() {
        infoPanel.classList.add('hidden');
        infoPanel.innerHTML = '';
    }

    function toggleOverlay(contentHtml) {
        if (overlay.classList.contains('hidden')) {
            showOverlay(contentHtml);
        } else {
            hideOverlay();
        }
    }

    function toggleInfo(contentHtml) {
        if (infoPanel.classList.contains('hidden')) {
            showInfo(contentHtml);
        } else {
            hideInfo();
        }
    }

    return {
        showOverlay,
        hideOverlay,
        showInfo,
        hideInfo,
        toggleOverlay,
        toggleInfo
    };
}

// --- Datei: Launchweb/ui/ui-login.js ---

// ui-login.js — Version: Σ.v1.auth.ui

import { rolleService } from '../models/user-model.js';

export function setupLoginUI() {
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('login-name');

    loginForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const name = nameInput.value.trim();
        if (name) {
            rolleService.login(name);
            document.getElementById('login-panel').style.display = 'none';
        }
    });

    if (rolleService.isLoggedIn()) {
        document.getElementById('login-panel').style.display = 'none';
    }
}

// --- Datei: Launchweb/ui/knoten/knoten-engine.js ---

// knoten-engine.js — Logik zum Erstellen und Speichern neuer Knoten

import { speichereKnoten } from '../../data/data-knoten.js';

export async function erstelleKnoten(knotenDaten) {
    const neuerKnoten = {
        id: Date.now().toString(),
        ...knotenDaten
    };

    await speichereKnoten(neuerKnoten);
    alert('Knoten erfolgreich erstellt.');
}

// --- Datei: Launchweb/ui/knoten/ui-knoten.js ---

// ui-knoten.js — Anzeige eines Knotens + Optionen

import { getKnotenById } from '../../data/data-knoten.js';

export function showKnotenInfo(knotenId) {
    const knoten = getKnotenById(knotenId);
    if (!knoten) return;

    const info = `
        <h2>${knoten.titel}</h2>
        <p>${knoten.beschreibung}</p>
        <button id="beitreten-btn">Beitreten</button>
    `;

    window.showInfoPanel(info);

    const btn = document.getElementById('beitreten-btn');
    if (btn) {
        btn.addEventListener('click', () => {
            alert('Webung mit diesem Knoten folgt.');
        });
    }
}

// --- Datei: Launchweb/ui/knoten/knoten-form.js ---

// knoten-form.js — Formular zur Knotenerstellung

import { erstelleKnoten } from './knoten-engine.js';

export function initKnotenForm() {
    const form = document.getElementById('knoten-form');
    if (!form) return;

    form.addEventListener('submit', async (e) => {
        e.preventDefault();

        const titel = form.querySelector('#titel').value;
        const beschreibung = form.querySelector('#beschreibung').value;

        await erstelleKnoten({ titel, beschreibung });
        form.reset();
    });
}

// --- Datei: Launchweb/ui/antrag/antrag-form.js ---

// antrag-form.js — v1

import { AntragEngine } from './antrag-engine.js';
import { generateId, todayISO } from '../../utils/utility-core.js';

export function erstelleAntragsformular(knotenId) {
    const form = document.createElement('form');
    form.innerHTML = `
        <h3>Neuer Antrag</h3>
        <label>Typ:
            <select name="typ">
                <option value="anschaffung">Anschaffung</option>
                <option value="veraenderung">Veränderung</option>
                <option value="goldantrag">Goldantrag</option>
            </select>
        </label>
        <label>Beschreibung:
            <textarea name="beschreibung" required></textarea>
        </label>
        <button type="submit">Antrag stellen</button>
    `;

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = new FormData(form);
        const neuerAntrag = {
            id: generateId(),
            typ: formData.get('typ'),
            beschreibung: formData.get('beschreibung'),
            knotenId,
            status: 'gestellt',
            gestelltAm: todayISO()
        };
        await AntragEngine.speichere(neuerAntrag);
        alert('Antrag gestellt.');
    });

    return form;
}

// --- Datei: Launchweb/ui/antrag/render-antraege.js ---

// render-antraege.js — v1

import { getFarbeFürAntrag } from './colors.js';

export function renderAntragsfaden(antrag) {
    const farbe = getFarbeFürAntrag(antrag);
    const faden = L.polyline([antrag.start, antrag.ziel], {
        color: farbe,
        weight: 3,
        className: antrag.typ === 'goldantrag' ? 'goldrand' : ''
    });
    faden.addTo(window.map); // globale Referenz
}

// --- Datei: Launchweb/ui/antrag/antrag-engine.js ---

// antrag-engine.js — v1

import { Speicher } from '../../data/persistence-service.js';
import { differenceInDays, parseISO } from 'date-fns';

export const AntragEngine = {
    async finde(id) {
        const alle = await Speicher.ladeAlle('antraege');
        return alle.find(a => a.id === id);
    },

    async speichere(antrag) {
        await Speicher.speichere('antraege', antrag);
    },

    async aktualisiereStatus() {
        const antraege = await Speicher.ladeAlle('antraege');
        const heute = new Date();

        for (let a of antraege) {
            const gestellt = parseISO(a.gestelltAm);
            if (a.status === 'gestellt') {
                if (differenceInDays(heute, gestellt) >= 7) {
                    a.status = 'angenommen';
                }
            } else if (a.status === 'einspruch') {
                const einspruch = parseISO(a.einspruchAm);
                if (differenceInDays(heute, einspruch) >= 7) {
                    a.status = 'abgelehnt';
                }
            }
        }

        await Speicher.schreibe('antraege', antraege);
    },

    async einspruchEinlegen(id) {
        const antraege = await Speicher.ladeAlle('antraege');
        const a = antraege.find(e => e.id === id);
        if (a && a.status === 'gestellt') {
            a.status = 'einspruch';
            a.einspruchAm = new Date().toISOString();
        }
        await Speicher.schreibe('antraege', antraege);
    }
};

// --- Datei: Launchweb/ui/antrag/ui-antrag.js ---

// ui-antrag.js — v1

import { AntragEngine } from './antrag-engine.js';
import { renderAntragsfaden } from '../../visual/render-antraege.js';

export function setupAntragUI() {
    document.addEventListener('click', async (e) => {
        if (e.target.matches('[data-antrag-id]')) {
            const id = e.target.dataset.antragId;
            const antrag = await AntragEngine.finde(id);
            if (antrag) {
                renderAntragsfaden(antrag);
            }
        }
    });
}

// --- Datei: Launchweb/ui/diskurs/diskurs-engine.js ---

// diskurs-engine.js — Logik zur Beitragserstellung und Fadenverknüpfung

import { speichereBeitrag } from '../../data/data-diskurs.js';
import { verknuepfeFaden } from '../../core/verblasslogik.js';

export async function hinzufuegenBeitrag(knotenId, autor, text) {
    const beitrag = {
        id: Date.now().toString(),
        knotenId,
        autor,
        text,
        zeitpunkt: new Date().toISOString()
    };

    await speichereBeitrag(beitrag);
    await verknuepfeFaden(autor, knotenId, 'beitrag');
}

// --- Datei: Launchweb/ui/diskurs/diskurs-form.js ---

// diskurs-form.js — Formular zur Erstellung eines Diskursbeitrags

import { hinzufuegenBeitrag } from './diskurs-engine.js';

export function startBeitragFormular(knotenId) {
    const html = `
        <form id="diskurs-eingabe">
            <input type="text" id="autor" placeholder="Dein Name" required />
            <textarea id="text" placeholder="Dein Beitrag" required></textarea>
            <button type="submit">Absenden</button>
        </form>
    `;

    const ziel = document.getElementById('diskurs-formular');
    if (ziel) ziel.innerHTML = html;

    const form = document.getElementById('diskurs-eingabe');
    if (form) {
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const autor = form.querySelector('#autor').value;
            const text = form.querySelector('#text').value;
            await hinzufuegenBeitrag(knotenId, autor, text);
            form.reset();
        });
    }
}

// --- Datei: Launchweb/ui/diskurs/ui-diskurs.js ---

// ui-diskurs.js — Anzeige des Gesprächsverlaufs innerhalb eines Knotens

import { getBeitraegeFuerKnoten } from '../../data/data-diskurs.js';
import { startBeitragFormular } from './diskurs-form.js';

export function zeigeDiskurs(knotenId) {
    const beitraege = getBeitraegeFuerKnoten(knotenId);

    const html = `
        <div class="diskurs-header">
            <h3>Gespräch zum Knoten</h3>
            <button id="beitrag-hinzufuegen">Beitrag verfassen</button>
        </div>
        <ul class="diskurs-liste">
            ${beitraege.map(b => `<li><strong>${b.autor}:</strong> ${b.text}</li>`).join('')}
        </ul>
        <div id="diskurs-formular"></div>
    `;

    const container = document.getElementById('diskurs-container');
    if (container) container.innerHTML = html;

    document.getElementById('beitrag-hinzufuegen')?.addEventListener('click', () => {
        startBeitragFormular(knotenId);
    });
}

// --- Datei: Launchweb/ui/layer/ui-layer-toggle.js ---

// ui-layer-toggle.js — Version: Σ.v1.layer.ui.toggle

export function setupLayerToggle(layerManager) {
    const container = document.getElementById('layer-controls');
    if (!container) return;

    const layerLabels = {
        knoten: 'Knoten',
        faeden: 'Fäden',
        garne: 'Garne',
        antraege: 'Anträge',
        webkasse: 'Webkasse'
    };

    Object.keys(layerLabels).forEach(layerKey => {
        const label = document.createElement('label');
        label.classList.add('layer-toggle-label');

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = layerManager.isLayerVisible(layerKey);
        checkbox.addEventListener('change', () => {
            layerManager.setLayerVisibility(layerKey, checkbox.checked);
        });

        label.appendChild(checkbox);
        label.append(` ${layerLabels[layerKey]}`);
        container.appendChild(label);
    });
}

// --- Datei: Launchweb/ui/layer/layer-manager.js ---

// ui/layer-manager.js — Version: Σ.v1.toggle-ready

export class LayerManager {
    constructor(map) {
        this.map = map;
        this.layerStates = new Map(); // z. B. "knoten" → true/false
        this.renderCallbacks = new Map(); // z. B. "knoten" → () => renderKnoten(...)
    }

    /**
     * Registriert eine neue Ebene mit zugehöriger Renderfunktion
     */
    registerLayer(name, renderFn) {
        this.layerStates.set(name, true); // standardmäßig sichtbar
        this.renderCallbacks.set(name, renderFn);
    }

    /**
     * Rendert alle derzeit aktivierten Layer
     */
    renderActiveLayers(selection, projection, data) {
        for (const [name, isActive] of this.layerStates.entries()) {
            if (isActive) {
                const renderFn = this.renderCallbacks.get(name);
                if (renderFn) renderFn(selection, projection, data);
            }
        }
    }

    /**
     * Toggelt eine bestimmte Ebene (z. B. per UI-Klick)
     */
    toggleLayer(name) {
        const current = this.layerStates.get(name);
        if (current === undefined) return;
        this.layerStates.set(name, !current);
    }

    /**
     * Gibt an, ob ein Layer derzeit aktiv ist
     */
    isLayerActive(name) {
        return !!this.layerStates.get(name);
    }

    /**
     * Setzt explizit den Zustand eines Layers
     */
    setLayerState(name, active) {
        if (this.layerStates.has(name)) {
            this.layerStates.set(name, active);
        }
    }

    /**
     * Gibt die vollständige Liste der Layer zurück
     */
    getLayerNames() {
        return Array.from(this.layerStates.keys());
    }
}


// --- Datei: Launchweb/ui/layer/ui-layer-advanced.js ---

// ui-layer-advanced.js — Version: Σ.v1.adapted-to-toggle

export function setupLayerControls(layerManager) {
    const controlContainer = document.getElementById('layer-controls');
    if (!controlContainer) return;

    const layerNames = layerManager.getLayerNames();

    layerNames.forEach(layerName => {
        const label = document.createElement('label');
        label.textContent = ` ${layerName}`;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = layerManager.isLayerActive(layerName);

        checkbox.addEventListener('change', () => {
            layerManager.toggleLayer(layerName);
            // optional: trigger Map-Neurender
        });

        label.prepend(checkbox);
        controlContainer.appendChild(label);
    });
}

// --- Datei: Launchweb/ui/extras/ui-naehstuebchen.js ---

// ui-naehstuebchen.js — v1

import { diskursEngine } from '../diskurs/diskurs-engine.js';
import { uiDiskursFenster } from '../diskurs/ui-diskurs.js';

export function öffneNaehstuebchen() {
    const fenster = uiDiskursFenster.erzeuge('naehstuebchen');
    diskursEngine.öffneRaum('naehstuebchen', fenster);
}

// --- Datei: Launchweb/ui/extras/zeitleiste.js ---

// zeitleiste.js — v1

import { renderKnoten } from '../../visual/render-knoten.js';
import { renderFaeden } from '../../visual/render-faeden.js';

export const zeitleiste = {
    alleDaten: [],
    aktuelleZeit: null,

    init(data) {
        this.alleDaten = data;
    },

    zeigeTag(tagIndex) {
        const tag = this.alleDaten[tagIndex];
        if (!tag) return;
        this.aktuelleZeit = tag.datum;
        renderKnoten(tag.knoten);
        renderFaeden(tag.faeden);
    }
};

// --- Datei: Launchweb/ui/extras/ui-webrat.js ---

// ui-webrat.js — v1

import { diskursEngine } from '../diskurs/diskurs-engine.js';
import { uiDiskursFenster } from '../diskurs/ui-diskurs.js';

export function öffneWebrat() {
    const fenster = uiDiskursFenster.erzeuge('webrat');
    diskursEngine.öffneRaum('webrat', fenster);
}

// --- Datei: Launchweb/ui/extras/ui-zeitreise.js ---

// ui-zeitreise.js — v1

import { zeitleiste } from './zeitleiste.js';

export function setupZeitreiseUI() {
    const controls = document.getElementById('zeitreise-controls');
    const startBtn = controls.querySelector('#start-zeitreise');
    const stopBtn = controls.querySelector('#stop-zeitreise');
    const slider = controls.querySelector('#zeitreise-slider');

    let interval = null;

    startBtn.addEventListener('click', () => {
        let tag = parseInt(slider.value, 10);
        interval = setInterval(() => {
            zeitleiste.zeigeTag(tag++);
            slider.value = tag;
        }, 1000);
    });

    stopBtn.addEventListener('click', () => {
        clearInterval(interval);
        interval = null;
    });

    slider.addEventListener('input', () => {
        zeitleiste.zeigeTag(parseInt(slider.value, 10));
    });
}

// --- Datei: Launchweb/core/manifest.js ---

// manifest.js — Version: Σ.v1.systembegriffe

export const Typen = {
    webung: {
        faden: 'faden',
        garn: 'garn',
        antrag: 'antrag'
    },

    antrag: {
        gold: 'gold',
        veraenderung: 'veraenderung',
        anschaffung: 'anschaffung'
    },

    status: {
        aktiv: 'aktiv',
        verblasst: 'verblasst',
        angenommen: 'angenommen',
        abgelehnt: 'abgelehnt',
        einspruch: 'einspruch'
    }
};

// --- Datei: Launchweb/core/zeitlogik.js ---

// zeitlogik.js — Version: Σ.v1.verblassung

export const Zeitlogik = {
    verblassungsTage: 7,

    istVerblassend(webung, jetzt = new Date()) {
        if (!webung.verblasstAm) return false;
        return new Date(webung.verblasstAm) < jetzt;
    },

    berechneVerblassung(typ, ereigniszeitpunkt = null) {
        const basis = ereigniszeitpunkt
            ? new Date(ereigniszeitpunkt)
            : new Date();

        if (typ === 'garn') return null; // bleibt permanent
        const verblass = new Date(basis);
        verblass.setDate(verblass.getDate() + Zeitlogik.verblassungsTage);
        return verblass.toISOString();
    }
};

// --- Datei: Launchweb/core/knotenerkennung.js ---

// knotenerkennung.js — Version: Σ.v1.knotenlogik

import { Knoten } from '../models/knotenmodell.js';
import { generateUUID } from '../utils.js';

export class Knotenerkennung {
    static erstelleKnoten({ koordinaten, erstellerId, beschreibung, typ = "standard", darstellung = "default" }) {
        const neuerKnoten = new Knoten({
            id: generateUUID(),
            koordinaten,
            erstellerId,
            beschreibung,
            typ,
            darstellung
        });

        return neuerKnoten;
    }

    static loescheWennVerwaist(knoten, webungListe) {
        const aktiveVerbindungen = webungListe.filter(w => w.zuKnotenId === knoten.id && w.zustand === 'aktiv');
        return aktiveVerbindungen.length === 0;
    }
}

// --- Datei: Launchweb/core/verblasslogik.js ---

// core/verblasslogik.js — Version: Σ.v2.fadenverfall.vollständig

import { parseISO, differenceInDays } from 'date-fns';

export class Verblasslogik {
    static pruefeVerblassen(webung, knotenHatEreigniszeitpunkt = false) {
        const erstellt = parseISO(webung.entstandenAm);
        const now = new Date();
        const tageVergangen = differenceInDays(now, erstellt);

        if (webung.typ === 'garn') return false;

        // Wenn ein Ereigniszeitpunkt existiert, zählt ab diesem + 7 Tage
        return tageVergangen > 7;
    }

    static setzeVerblasstStatus(webung, knotenHatEreigniszeitpunkt = false) {
        if (this.pruefeVerblassen(webung, knotenHatEreigniszeitpunkt)) {
            webung.zustand = 'verblasst';
        }
    }

    static tageBisVerblassen(webung, knotenHatEreigniszeitpunkt = false) {
        const erstellt = parseISO(webung.entstandenAm);
        const now = new Date();
        const verbleibend = 7 - differenceInDays(now, erstellt);
        return Math.max(0, verbleibend);
    }

    static istVerblasst(webung) {
        return webung.zustand === 'verblasst';
    }
}

// --- Datei: Launchweb/core/antragszyklus.js ---

// antragslogik.js — Version: Σ.v1.antragszyklus

import { parseISO, differenceInDays } from 'date-fns';

export class Antragslogik {
    static pruefeEntscheidung(antrag, einspruchsDatum = null) {
        const erstellt = parseISO(antrag.entstandenAm);
        const now = new Date();

        if (antrag.zustand !== 'aktiv') return;

        if (!einspruchsDatum) {
            const tage = differenceInDays(now, erstellt);
            if (tage >= 7) {
                antrag.zustand = 'angenommen';
                antrag.farbsignal = 'grün';
            }
        } else {
            const einspruch = parseISO(einspruchsDatum);
            const tageNachEinspruch = differenceInDays(now, einspruch);
            if (tageNachEinspruch >= 7) {
                antrag.zustand = 'abgelehnt';
                antrag.farbsignal = 'rot';
            }
        }
    }

    static initialisiereAntrag(antrag) {
        antrag.farbsignal = 'blau';
    }

    static markiereEinspruch(antrag) {
        antrag.farbsignal = 'lila';
    }

    static kennzeichneGoldantrag(antrag) {
        antrag.goldrand = true;
    }
}

// --- Datei: Launchweb/core/webung-engine.js ---

// webungsengine.js — Version: Σ.v1.core

import { Rolle } from './rolle.js';
import { Faden } from './fadenmodell.js';
import { Knoten } from './knoten-modell.js';
import { Verblasslogik } from './verblasslogik.js';
import { Knotenerkennung } from './knotenerkennung.js';
import { persistenceService } from './persistence-service.js';
import { WebSocketServiceSingleton as ws } from './websocket-service.js';

export const WebungsEngine = {
    async neueWebung({ rollenId, koordinaten, inhalt, typ = 'faden', optional = {} }) {
        const rolle = await persistenceService.find('rollen', rollenId);
        if (!rolle) throw new Error('Rolle nicht gefunden');

        // 1. Knoten prüfen oder erzeugen
        let knoten = await Knotenerkennung.findeOderErzeugeKnoten(koordinaten, inhalt);

        // 2. Webung erzeugen
        const webung = new Faden({
            rolleId: rollenId,
            knotenId: knoten.id,
            typ,
            inhalt,
            ...optional
        });

        // 3. Verknüpfen
        rolle.webungen.push(webung.id);
        knoten.webungen.push(webung.id);

        // 4. Verblasslogik anwenden
        Verblasslogik.setzeVerblasstStatus(webung);

        // 5. Speichern
        await persistenceService.save('rollen', rolle);
        await persistenceService.save('knoten', knoten);
        await persistenceService.save('webungen', webung);

        // 6. WebSocket-Broadcast
        ws.send({ type: 'webung_neu', payload: { webungId: webung.id } });

        return webung;
    },

    async prüfeVerblassungFürAlle() {
        const webungen = await persistenceService.getAll('webungen');
        const knotenMap = await persistenceService.getMap('knoten');

        for (const webung of webungen) {
            const knoten = knotenMap[webung.knotenId];
            Verblasslogik.setzeVerblasstStatus(webung, !!knoten?.ereigniszeitpunkt);
            await persistenceService.save('webungen', webung);
        }
    }
};

// --- Datei: Launchweb/utils/utility-tooltip.js ---

// utility-tooltip.js — Version: Σ.v1.tooltip.system

export function createTooltip(content, position) {
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    tooltip.innerText = content;
    tooltip.style.top = `${position.y}px`;
    tooltip.style.left = `${position.x}px`;
    document.body.appendChild(tooltip);
    return tooltip;
}

export function removeTooltip() {
    const tooltips = document.querySelectorAll('.tooltip');
    tooltips.forEach(t => t.remove());
}

// --- Datei: Launchweb/utils/validation.js ---

// validation.js — Version: Σ.v1.form.validation

export const Validators = {
    required(value) {
        return value?.trim() ? null : 'Pflichtfeld';
    },

    minLength(min) {
        return (value) => {
            return value.length >= min ? null : `Mindestens ${min} Zeichen`;
        };
    },

    isNumber(value) {
        return isNaN(value) ? 'Muss eine Zahl sein' : null;
    }
};

// --- Datei: Launchweb/utils/utility-core.js ---

// utility-core.js — Version: Σ.v1.core.util

export const UtilityCore = {
    generateUUID() {
        return crypto.randomUUID();
    },

    formatDate(date) {
        return new Intl.DateTimeFormat('de-DE', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        }).format(new Date(date));
    },

    clone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
};

// --- Datei: Launchweb/utils/form-components.js ---

// form-components.js — Version: Σ.v1.formteile

export function createInputField({ id, label, type = 'text', placeholder = '', value = '' }) {
    const wrapper = document.createElement('div');
    const labelEl = document.createElement('label');
    labelEl.setAttribute('for', id);
    labelEl.textContent = label;

    const input = document.createElement('input');
    input.type = type;
    input.id = id;
    input.placeholder = placeholder;
    input.value = value;

    wrapper.appendChild(labelEl);
    wrapper.appendChild(input);
    return wrapper;
}

export function createSelect({ id, label, options }) {
    const wrapper = document.createElement('div');
    const labelEl = document.createElement('label');
    labelEl.setAttribute('for', id);
    labelEl.textContent = label;

    const select = document.createElement('select');
    select.id = id;

    options.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.label;
        select.appendChild(option);
    });

    wrapper.appendChild(labelEl);
    wrapper.appendChild(select);
    return wrapper;
}

// --- Datei: Launchweb/utils/utils.js ---

// utils.js — Version: Σ.v1.misc.tools

export function debounce(fn, delay) {
    let timer = null;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), delay);
    };
}

export function throttle(fn, limit) {
    let inThrottle;
    return function (...args) {
        if (!inThrottle) {
            fn(...args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
        }
    };
}

// --- Datei: Launchweb/models/webung.js ---

// fadenmodell.js — Version: Σ.v1.fadenstruktur

export class Webung {
    constructor({ id, typ = "faden", vonRolleId, zuKnotenId }) {
        this.id = id;
        this.typ = typ; // "faden", "garn", "antrag", "goldantrag"
        this.vonRolleId = vonRolleId;
        this.zuKnotenId = zuKnotenId;
        this.entstandenAm = new Date().toISOString();
        this.zustand = "aktiv"; // oder "verblasst", "abgelehnt", "angenommen"
        this.farbsignal = null; // z. B. "blau", "lila", "grün", "rot", "goldrand"
    }
}

// --- Datei: Launchweb/models/user-model.js ---

// models/user-model.js — Version: Σ.v1.rolle.core

export const rolleService = {
    rolleId: null,

    set(id) {
        this.rolleId = id;
        localStorage.setItem('rolleId', id);
    },

    get() {
        return this.rolleId || localStorage.getItem('rolleId');
    },

    restore() {
        this.rolleId = localStorage.getItem('rolleId');
    }
};

// --- Datei: Launchweb/models/knotentypen.js ---

// models/knotentypen.js — Definition symbolischer Knotentypen

export const Knotentypen = {
    standard: {
        farbe: '#7F8C8D',
        symbol: '●',
        beschreibung: 'Standardknoten ohne Spezifizierung'
    },
    goldantrag: {
        farbe: '#F1C40F',
        symbol: '◎',
        beschreibung: 'Geldantrag in der Webkasse'
    },
    zusage: {
        farbe: '#2ECC71',
        symbol: '✓',
        beschreibung: 'Verbindliche Zusage (Garn)'
    },
    faden: {
        farbe: '#3498DB',
        symbol: '➝',
        beschreibung: 'Temporäre Beteiligung (Faden)'
    },
    einspruch: {
        farbe: '#9B59B6',
        symbol: '⚠️',
        beschreibung: 'Einspruch gegen Antrag'
    },
    abgelehnt: {
        farbe: '#E74C3C',
        symbol: '✗',
        beschreibung: 'Abgelehnter Antrag'
    },
    angenommen: {
        farbe: '#27AE60',
        symbol: '✓',
        beschreibung: 'Angenommener Antrag'
    }
};

// --- Datei: Launchweb/visuals/render-garne.js ---

// visual/render-garne.js — Version: Σ.v∞.garn.verbindung.symbolisch

import * as d3 from 'd3';
import { Farben } from './colors.js';

/**
 * Zeichnet dauerhafte Garnverbindungen zwischen Knoten (z. B. durch Zusagen)
 */
export function renderGarne(svg, projection, daten) {
  const garne = daten.filter(w => w.typ === 'garn' && w.zustand !== 'verblasst');

  const verbindungen = svg.selectAll('.garn').data(garne, d => d.id);
  verbindungen.exit().remove();

  const neu = verbindungen.enter()
    .append('path')
    .attr('class', 'garn');

  neu.merge(verbindungen)
    .attr('d', d => {
      const [x1, y1] = projection([d.quelle.lng, d.quelle.lat]);
      const [x2, y2] = projection([d.ziel.lng, d.ziel.lat]);
      return `M${x1},${y1} L${x2},${y2}`;
    })
    .attr('stroke', d => {
      const farbe = Farben.garn[d.zustand] || Farben.garn.zusage;
      return farbe;
    })
    .attr('stroke-width', d => 3 + (d.intensität || 0))
    .attr('stroke-dasharray', '1,3') // Zwirn-Stil
    .attr('opacity', 0.9)
    .attr('fill', 'none');
}

// --- Datei: Launchweb/visuals/render-webkasse.js ---

// visual/render-webkasse.js — Version: Σ.v∞.symbol.gold.circle

import { Farben } from './colors.js';

/**
 * Zeichnet die kollektive Webkasse als Kreis mit Goldfarbe
 */
export function renderWebkasse(selection, projection, data, showTooltip, hideTooltip) {
  const pos = projection({ lat: 53.56, lng: 10.03 }); // feste Position
  const stand = data.webkasse?.kontostand || 0;
  const radius = Math.sqrt(stand) * 0.05 + 10;

  const topf = selection.selectAll('.webkasse').data([stand]);

  topf.enter()
    .append('circle')
    .attr('class', 'webkasse')
    .merge(topf)
    .attr('cx', pos.x)
    .attr('cy', pos.y)
    .attr('r', radius)
    .attr('fill', Farben.webkasse)
    .attr('fill-opacity', 0.8)
    .attr('stroke', '#222')
    .attr('stroke-width', 1.5)
    .on('mouseover', e => showTooltip(`Webkasse: ${stand.toFixed(2)} €`, e.pageX, e.pageY))
    .on('mouseout', hideTooltip);

  topf.exit().remove();
}

// --- Datei: Launchweb/visuals/render-base.js ---

// render-base.js — Version: Σ.v∞.style.core

export const RenderBase = {
    fadenStyle(farbe, dicke = 2, transparenz = 0.5) {
        return {
            stroke: farbe,
            'stroke-width': dicke,
            'stroke-opacity': transparenz,
            fill: 'none'
        };
    },
    garnStyle(farbe) {
        return {
            stroke: farbe,
            'stroke-dasharray': '5,2',
            'stroke-width': 3,
            'stroke-opacity': 0.9,
            fill: 'none'
        };
    },
    antragRandStyle(farbe) {
        return {
            stroke: farbe,
            'stroke-width': 3,
            fill: 'none'
        };
    }
};

// --- Datei: Launchweb/visuals/render-antraege.js ---

// visual/render-antraege.js — Version: Σ.v∞.antrag.statusfarben.klar

import * as d3 from 'd3';
import { Farben } from './colors.js';

/**
 * Zeichnet alle Anträge mit Farbcodierung je nach Status
 */
export function renderAntraege(svg, projection, daten) {
  const antraege = daten.filter(w => w.typ === 'antrag' && w.zustand !== 'verblasst');

  const verbindungen = svg.selectAll('.antrag')
    .data(antraege, d => d.id);

  verbindungen.exit().remove();

  const neu = verbindungen.enter()
    .append('path')
    .attr('class', 'antrag');

  neu.merge(verbindungen)
    .attr('d', d => {
      const [x1, y1] = projection([d.quelle.lng, d.quelle.lat]);
      const [x2, y2] = projection([d.ziel.lng, d.ziel.lat]);
      return `M${x1},${y1} L${x2},${y2}`;
    })
    .attr('stroke', d => Farben.antrag[d.status] || Farben.antrag.gestellt)
    .attr('stroke-width', 3)
    .attr('stroke-dasharray', '2,4')
    .attr('opacity', 0.9)
    .attr('fill', 'none')
    .attr('filter', d => d.kategorie === 'goldantrag' ? 'url(#goldrand)' : null);
}

// --- Datei: Launchweb/visuals/colors.js ---

// visual/colors.js – Version: Σ.v2.klare-farben

export const Farben = {
  // Fäden
  faden: {
    wortbeitrag: '#888',
    antrag: '#0077cc',
    einspruch: '#8e44ad',
    angenommen: '#27ae60',
    abgelehnt: '#c0392b',
    verblasst: '#ccc'
  },

  // Garne
  garn: {
    zusage: '#d35400',
    vergangen: '#95a5a6'
  },

  // Knoten
  knoten: {
    standard: '#000',
    individuell: '#444'
  },

  // Anträge mit Goldrand
  rand: {
    gold: '#ffd700'
  },

  // UI / Hilfselemente
  ui: {
    highlight: '#f39c12',
    hintergrund: '#fefefe'
  }
};

// --- Datei: Launchweb/visuals/render-faeden.js ---

// visual/render-faeden.js — Version: Σ.v∞.faeden.typisiert

import { select } from 'd3-selection';
import { Farben } from './colors.js';
import { SystemMeta } from '../system-meta.js';

/**
 * Zeichnet temporäre Verbindungen („Fäden“) z. B. Wortbeiträge, Anträge etc.
 */
export function renderFaeden(svg, projection, daten) {
  if (!SystemMeta.istLayerAktiv('faeden')) return;

  const faeden = daten.webungen.filter(w => w.typ === 'faden' && w.zustand !== 'verblasst');

  const layer = svg.selectAll('.faden').data(faeden, d => d.id);

  layer.enter()
    .append('line')
    .attr('class', 'faden')
    .attr('x1', d => projection(d.von)[0])
    .attr('y1', d => projection(d.von)[1])
    .attr('x2', d => projection(d.zu)[0])
    .attr('y2', d => projection(d.zu)[1])
    .style('stroke', d => Farben.faden[d.subtyp] || Farben.faden.wortbeitrag)
    .style('stroke-width', d => Math.max(1, d.stärke || 1))
    .style('opacity', d => d.transparenz || 0.4);

  layer.exit().remove();
}

// --- Datei: Launchweb/visuals/render-knoten.js ---

// render-knoten.js — Version: Σ.v∞.svg.symbol.farbenbasiert

import { Farben } from './colors.js';

export function renderKnoten(selection, projection, bounds, data, showTooltip, hideTooltip) {
  const getLatLng = e =>
    Array.isArray(e.koordinaten)
      ? [e.koordinaten[0], e.koordinaten[1]]
      : [e.koordinaten.lat, e.koordinaten.lng];

  const visible = data.knoten.filter(e => bounds.contains(getLatLng(e)));

  const groups = selection.selectAll('.knoten').data(visible, d => d.id);

  const enter = groups.enter().append('g').attr('class', 'knoten');

  enter.merge(groups)
    .attr('transform', d => {
      const [lat, lng] = getLatLng(d);
      const p = projection({ lat, lng });
      return `translate(${p.x},${p.y})`;
    })
    .each(function (d) {
      const g = d3.select(this);
      const r = d.typ === 'person' ? 10 : 12;
      const fill = Farben.knoten[d.typ] || Farben.knoten.standard;

      g.selectAll('circle')
        .data([d])
        .join('circle')
        .attr('r', r)
        .attr('fill', fill)
        .attr('stroke', '#000')
        .attr('stroke-width', 1.5);

      g.on('mouseover', e => showTooltip(d.titel || 'Knoten', e.pageX, e.pageY))
       .on('mouseout', hideTooltip);
    });

  groups.exit().remove();
}

// --- Datei: Launchweb/visuals/render-fadenlegende.js ---

// render-fadenlegende.js — Version: Σ.v1.fadenlegende

import * as d3 from 'd3';
import { FADENFARBEN, FADENSTILE } from './colors.js';

export function renderFadenlegende(containerId) {
    const fadenTypen = [
        { label: 'Gesprächsbeitrag', farbe: FADENFARBEN.gespräch, stil: FADENSTILE.normal },
        { label: 'Gesprächseröffnung', farbe: FADENFARBEN.gesprächStart, stil: FADENSTILE.normal },
        { label: 'Zusage (Garn)', farbe: FADENFARBEN.garn, stil: FADENSTILE.garn },
        { label: 'Antrag', farbe: FADENFARBEN.antrag, stil: FADENSTILE.normal },
        { label: 'Einspruch', farbe: FADENFARBEN.einspruch, stil: FADENSTILE.normal },
        { label: 'Abgelehnt', farbe: FADENFARBEN.abgelehnt, stil: FADENSTILE.normal },
        { label: 'Angenommen', farbe: FADENFARBEN.angenommen, stil: FADENSTILE.normal },
        { label: 'Goldantrag', farbe: FADENFARBEN.antrag, stil: FADENSTILE.gold },
        { label: 'Vergangen', farbe: FADENFARBEN.vergangen, stil: FADENSTILE.verblassend }
    ];

    const container = d3.select(`#${containerId}`);
    container.html(''); // Reset

    const svg = container.append('svg')
        .attr('width', 300)
        .attr('height', fadenTypen.length * 30);

    const einträge = svg.selectAll('g')
        .data(fadenTypen)
        .enter()
        .append('g')
        .attr('transform', (_, i) => `translate(10, ${i * 30 + 10})`);

    einträge.append('line')
        .attr('x1', 0)
        .attr('y1', 5)
        .attr('x2', 60)
        .attr('y2', 5)
        .attr('stroke', d => d.farbe)
        .attr('stroke-width', d => d.stil === 'garn' ? 4 : 2)
        .attr('stroke-dasharray', d => d.stil === 'verblassend' ? '2,2' : (d.stil === 'gold' ? '4,1' : ''))
        .attr('opacity', d => d.stil === 'verblassend' ? 0.3 : 1);

    einträge.append('text')
        .attr('x', 70)
        .attr('y', 9)
        .text(d => d.label)
        .attr('font-size', '12px')
        .attr('fill', '#333');
}

// --- Datei: Launchweb/data/persistence-services.server.js ---

// persistence-service.server.js — Version: Σ.server.fs

import fs from 'fs/promises';
import path from 'path';

export const PersistenceServer = {
    basePath: './weltweberei-data',

    async ensureDir() {
        await fs.mkdir(this.basePath, { recursive: true });
    },

    filePath(name) {
        return path.join(this.basePath, `${name}.json`);
    },

    async loadAll(name) {
        try {
            const content = await fs.readFile(this.filePath(name), 'utf-8');
            return JSON.parse(content);
        } catch (err) {
            if (err.code === 'ENOENT') return [];
            throw err;
        }
    },

    async write(name, data) {
        await this.ensureDir();
        await fs.writeFile(this.filePath(name), JSON.stringify(data, null, 2));
    },

    async store(name, entry) {
        const data = await this.loadAll(name);
        data.push(entry);
        await this.write(name, data);
    },

    async delete(name, id) {
        const data = await this.loadAll(name);
        const filtered = data.filter(e => e.id !== id);
        await this.write(name, filtered);
    }
};

// --- Datei: Launchweb/data/data-model.js ---

// data-model.js — Version: Σ.v1.modelstruktur

export const Model = {
    webung: {
        id: null,
        vonRollenId: null,
        typ: 'faden' | 'garn' | 'antrag',
        zuKnotenId: null,
        text: '',
        erstelltAm: null,
        verblasstAm: null,
        farbe: '', // optisch gesteuert über Typ & Status
        status: '', // aktiv | verblasst | angenommen | abgelehnt
    },

    knoten: {
        id: null,
        erstelltVon: null,
        erstelltAm: null,
        koordinaten: { lat: 0, lng: 0 },
        text: '',
        visual: 'knotenstandard',
        ereigniszeitpunkt: null // optional
    },

    antrag: {
        id: null,
        vonRollenId: null,
        knotenId: null,
        gestelltAm: null,
        typ: '', // 'gold' | 'veränderung' | 'anschaffung'
        text: '',
        status: 'offen' | 'einspruch' | 'abgelehnt' | 'angenommen',
        einspruchsDatum: null,
        entscheidungsDatum: null
    },

    rolle: {
        id: null,
        name: '',
        wohnort: { lat: 0, lng: 0 }
    }
};

// --- Datei: Launchweb/data/data-finanz.js ---

// data/data-finanz.js — Version: Σ.v∞.1.webkasse.core

import { generateUID } from '../utils.js';

let webkasse = {
    kontostand: 0,
    buchungen: [] // { id, betrag, von, zweck, zeitpunkt, quelle }
};

// Buchungstypen: spende, zusage, auszahlung, umbuchung, goldfaden

export function aktuelleWebkasse() {
    return {
        kontostand: webkasse.kontostand,
        buchungen: [...webkasse.buchungen]
    };
}

export function fuegeBuchungHinzu({ betrag, von, zweck, quelle = 'unbekannt' }) {
    const buchung = {
        id: generateUID(),
        betrag,
        von,
        zweck,
        quelle,
        zeitpunkt: new Date().toISOString()
    };
    webkasse.buchungen.push(buchung);
    webkasse.kontostand += betrag;
    return buchung;
}

export function macheAuszahlung({ betrag, an, zweck = 'auszahlung' }) {
    if (webkasse.kontostand >= betrag) {
        return fuegeBuchungHinzu({ betrag: -betrag, von: 'webkasse', zweck, quelle: 'auszahlung:' + an });
    } else {
        throw new Error("Nicht genügend Mittel in der Webkasse");
    }
}

export function filtereBuchungen(filterFn) {
    return webkasse.buchungen.filter(filterFn);
}

export function resetWebkasse() {
    webkasse = {
        kontostand: 0,
        buchungen: []
    };
}

// --- Datei: Launchweb/data/data-diskurs.js ---

// data/data-diskurs.js — Version: Σ.v2.diskursstruktur.raumgestützt

export const diskursData = {
    räume: [], // Jeder Raum: { id, typ, referenzId, gespräche: [ { id, beitrag, typ, autor, zeit } ] }

    addRaum(raum) {
        this.räume.push(raum);
    },

    findRaum(id) {
        return this.räume.find(r => r.id === id);
    },

    addGespräch(raumId, gespräch) {
        const raum = this.findRaum(raumId);
        if (raum) {
            raum.gespräche.push(gespräch);
        }
    },

    getGespräche(raumId) {
        const raum = this.findRaum(raumId);
        return raum ? raum.gespräche : [];
    },

    getGesprächeMitTyp(raumId, typ) {
        const raum = this.findRaum(raumId);
        return raum ? raum.gespräche.filter(g => g.typ === typ) : [];
    },

    deleteGespräch(raumId, gesprächId) {
        const raum = this.findRaum(raumId);
        if (raum) {
            raum.gespräche = raum.gespräche.filter(g => g.id !== gesprächId);
        }
    },

    deleteRaum(id) {
        this.räume = this.räume.filter(r => r.id !== id);
    },

    getAlleRäume() {
        return this.räume;
    }
};

// --- Datei: Launchweb/data/persistence-services.client.js ---

// persistence-service.client.js — Version: Σ.client.localStorage

export const PersistenceClient = {
    loadAll(key) {
        const raw = localStorage.getItem(key);
        return raw ? JSON.parse(raw) : [];
    },

    save(key, data) {
        localStorage.setItem(key, JSON.stringify(data));
    },

    store(key, entry) {
        const data = this.loadAll(key);
        data.push(entry);
        this.save(key, data);
    },

    delete(key, id) {
        const data = this.loadAll(key).filter(e => e.id !== id);
        this.save(key, data);
    },

    clear(key) {
        localStorage.removeItem(key);
    }
};

// --- Datei: Launchweb/data/data-knoten.js ---

// data/data-knoten.js — Version: Σ.v∞.1.knotenstruktur.core

import { generateUID } from '../utils.js';

const knotenStore = [];

export function createKnoten({ titel, beschreibung, koordinaten, erstellerId, zeitpunkt = null, typ = 'allgemein' }) {
    const neuerKnoten = {
        id: generateUID(),
        titel,
        beschreibung,
        koordinaten,
        erstellerId,
        zeitpunkt,
        typ,
        erstelltAm: new Date().toISOString(),
        verbunden: [],
        aktiv: true
    };
    knotenStore.push(neuerKnoten);
    return neuerKnoten;
}

export function getAlleKnoten() {
    return knotenStore.filter(k => k.aktiv);
}

export function findeKnotenNachId(knotenId) {
    return knotenStore.find(k => k.id === knotenId && k.aktiv);
}

export function verknuepfeMitKnoten(knotenId, webungId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten && !knoten.verbunden.includes(webungId)) {
        knoten.verbunden.push(webungId);
    }
}

export function entferneVerknuepfung(knotenId, webungId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten) {
        knoten.verbunden = knoten.verbunden.filter(id => id !== webungId);
        if (knoten.verbunden.length === 0) {
            knoten.aktiv = false;
        }
    }
}

export function loescheKnoten(knotenId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten) {
        knoten.aktiv = false;
    }
}

// --- Datei: Launchweb/data/persistence-services.js ---

// persistence-service.js — Version: Σ.v2.contextaware

let speicher;

if (typeof window !== 'undefined' && window.localStorage) {
    // Client-basiert
    import('./persistence-service.client.js').then(mod => {
        speicher = mod.Speicher;
    });
} else {
    // Server-basiert (Node.js)
    import('./persistence-service.server.js').then(mod => {
        speicher = mod.Speicher;
    });
}

// Async-Wartefunktion, bis das Modul geladen ist
async function bereitstellen() {
    if (!speicher) {
        await new Promise(resolve => setTimeout(resolve, 10)); // minimal warten
        return bereitstellen(); // rekursiv warten
    }
    return speicher;
}

// Exporte als Proxy-Funktionen
export const Speicher = {
    async ladeAlle(name) {
        const s = await bereitstellen();
        return s.ladeAlle(name);
    },

    async schreibe(name, daten) {
        const s = await bereitstellen();
        return s.schreibe(name, daten);
    },

    async speichere(name, eintrag) {
        const s = await bereitstellen();
        return s.speichere(name, eintrag);
    },

    async loesche(name, id) {
        const s = await bereitstellen();
        return s.loesche(name, id);
    }
};

// --- Datei: Launchweb/services/api-knoten.js ---

// api-knoten.js — Version: Σ.v1.knotenservice

import { Knotenerkennung } from '../core/knotenerkennung.js';
import { Speicher } from './persistence-service.js';

export const apiKnoten = {
    async erstelleKnoten(daten) {
        const knoten = Knotenerkennung.erstelleKnoten(daten);
        await Speicher.speichere('knoten', knoten);
        return knoten;
    },

    async pruefeUndLoescheVerwaiste() {
        const knotenListe = await Speicher.ladeAlle('knoten');
        const webungen = await Speicher.ladeAlle('webung');

        const geloeschte = [];

        for (const k of knotenListe) {
            if (Knotenerkennung.loescheWennVerwaist(k, webungen)) {
                await Speicher.loesche('knoten', k.id);
                geloeschte.push(k.id);
            }
        }

        return geloeschte;
    }
};

// --- Datei: Launchweb/services/api-verblassen.js ---

// api-verblassen.js — Version: Σ.v1.verblass-service

import { Verblasslogik } from '../core/verblasslogik.js';
import { Speicher } from './persistence-service.js';

export const apiVerblassen = {
    async verblasseAlle() {
        const webungen = await Speicher.ladeAlle('webung');
        const knotenListe = await Speicher.ladeAlle('knoten');

        for (const w of webungen) {
            const knoten = knotenListe.find(k => k.id === w.zuKnotenId);
            Verblasslogik.setzeVerblasstStatus(w, knoten?.ereigniszeitpunkt);
        }

        await Speicher.schreibe('webung', webungen);
    }
};

// --- Datei: Launchweb/services/api-webung.js ---

// api-webung.js — Version: Σ.v1.api

import express from 'express';
import { WebungsEngine } from './webungsengine.js';
import { persistenceService } from './persistence-service.js';

export const webungApi = express.Router();

webungApi.post('/webung', async (req, res) => {
    try {
        const newWebung = await WebungsEngine.neueWebung(req.body);
        res.status(201).json(newWebung);
    } catch (err) {
        res.status(400).json({ error: err.message });
    }
});

webungApi.get('/webungen', async (req, res) => {
    const webungen = await persistenceService.getAll('webungen');
    res.json(webungen);
});

// --- Datei: Launchweb/services/auth-service.js ---

// services/auth-service.js — v1

let eingeloggterWeber = null;

export const AuthService = {
    login(userId, name, wohnort) {
        eingeloggterWeber = { id: userId, name, wohnort };
    },
    logout() {
        eingeloggterWeber = null;
    },
    getUser() {
        return eingeloggterWeber;
    },
    isLoggedIn() {
        return !!eingeloggterWeber;
    }
};

// --- Datei: Launchweb/services/websocket-service.js ---

// services/websocket-service.js — v1

class WebSocketService {
    constructor(url) {
        this.url = url;
        this.socket = null;
        this.listeners = new Set();
    }

    connect() {
        if (this.socket) return;

        this.socket = new WebSocket(this.url);

        this.socket.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            this.listeners.forEach(fn => fn(msg));
        };

        this.socket.onopen = () => {
            console.log('WebSocket verbunden');
        };

        this.socket.onclose = () => {
            this.socket = null;
            setTimeout(() => this.connect(), 1000);
        };

        this.socket.onerror = () => {
            this.socket?.close();
        };
    }

    send(msg) {
        if (this.socket?.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify(msg));
        }
    }

    subscribe(fn) {
        this.listeners.add(fn);
    }
}

export const WebSocketServiceInstance = new WebSocketService('ws://localhost:8080');

// --- Datei: Launchweb/services/api-antrag.js ---

// api-antrag.js — Version: Σ.v1.antrag-service

import { Antragslogik } from '../core/antragslogik.js';
import { Speicher } from './persistence-service.js';

export const apiAntrag = {
    async pruefeAlleAntraege() {
        const antraege = await Speicher.ladeAlle('antrag');

        for (const a of antraege) {
            Antragslogik.pruefeEntscheidung(a, a.einspruchsDatum);
        }

        await Speicher.schreibe('antrag', antraege);
    },

    async stelleAntrag(antrag) {
        Antragslogik.initialisiereAntrag(antrag);
        if (antrag.kategorie === 'gold') {
            Antragslogik.kennzeichneGoldantrag(antrag);
        }

        await Speicher.speichere('antrag', antrag);
        return antrag;
    },

    async markiereEinspruch(antragId) {
        const antraege = await Speicher.ladeAlle('antrag');
        const antrag = antraege.find(a => a.id === antragId);
        if (antrag) {
            Antragslogik.markiereEinspruch(antrag);
            antrag.einspruchsDatum = new Date().toISOString();
        }
        await Speicher.schreibe('antrag', antraege);
    }
};

// --- Datei: Launchweb/services/websocket-integration.js ---

// websocket-integration.js — Version: Σ.v1.0.webung.sync.full

import { websocketService } from './websocket-service.js';
import { loadInitialData } from './startup-loader.js';
import { renderVisuals } from './leaflet-setup.js';

export class WebsocketIntegration {
    constructor(map) {
        this.map = map;
        websocketService.registerMessageHandler(this.handleMessage.bind(this));
        websocketService.connect();
    }

    async handleMessage(msg) {
        const { type } = msg;

        if (['webung_created', 'knoten_created', 'antrag_started', 'einspruch', 'abstimmung'].includes(type)) {
            const freshData = await loadInitialData();
            renderVisuals(this.map, freshData);
        } else if (type === 'ping') {
            // optional: heartbeat received
        } else {
            console.warn('WebsocketIntegration: Unbekannter Nachrichtentyp', type);
        }
    }
}

// --- Datei: Launchweb/services/file-storage.js ---

// services/file-storage.js — v1

import fs from 'fs/promises';
import path from 'path';

export const FileStorage = {
    baseDir: './weltweberei-data',

    async ensureDir() {
        await fs.mkdir(this.baseDir, { recursive: true });
    },

    async read(file) {
        const full = path.join(this.baseDir, file);
        try {
            const content = await fs.readFile(full, 'utf-8');
            return JSON.parse(content);
        } catch (err) {
            if (err.code === 'ENOENT') return [];
            throw err;
        }
    },

    async write(file, data) {
        await this.ensureDir();
        const full = path.join(this.baseDir, file);
        await fs.writeFile(full, JSON.stringify(data, null, 2));
    }
};

// --- Datei: __MACOSX/Launchweb/._index.html ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._system-meta.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._weltweb.txt ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._startup-loader.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._leaflet-setup.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._strukturbaum.txt ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._init-events.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._style.css ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._engine-events.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._main.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-login.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-ereignis.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-interactions.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-finanz.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-themenfilter.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-core.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._ui-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._knoten-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._knoten-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._antrag-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._ui-antrag.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._render-antraege.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._antrag-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._diskurs-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._ui-diskurs.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._diskurs-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/layer/._layer-manager.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/layer/._ui-layer-advanced.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/layer/._ui-layer-toggle.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-naehstuebchen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-zeitreise.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-webrat.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._zeitleiste.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._webung-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._antragszyklus.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._verblasslogik.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._zeitlogik.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._manifest.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._knotenerkennung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._form-components.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utility-core.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._validation.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utility-tooltip.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utils.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._user-model.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._knotentypen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._webung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-base.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-antraege.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-faeden.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._colors.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-fadenlegende.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-garne.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-webkasse.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-finanz.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-model.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.client.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.server.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-diskurs.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._websocket-service.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-verblassen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._websocket-integration.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-antrag.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._file-storage.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._auth-service.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-webung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: Launchweb/layer-manager.js ---

// layer-manager.js — Version: Σ.v3.singleton-final

class LayerManager {
  constructor(map = null) {
    if (LayerManager._instance) return LayerManager._instance;
    this.map = map;
    this.data = {};
    this.layerStates = new Map();
    this.renderCallbacks = new Map();
    LayerManager._instance = this;
  }

  static getInstance() {
    if (!LayerManager._instance) {
      LayerManager._instance = new LayerManager();
    }
    return LayerManager._instance;
  }

  updateData(daten) {
    this.data = daten;
  }

  getData() {
    return this.data;
  }

  registerLayer(name, renderFn) {
    this.layerStates.set(name, true);
    this.renderCallbacks.set(name, renderFn);
  }

  renderActiveLayers(selection, projection) {
    for (const [name, isActive] of this.layerStates.entries()) {
      if (isActive) {
        const renderFn = this.renderCallbacks.get(name);
        if (renderFn) {
          const layerData = this.data[name] || [];
          renderFn(selection, projection, layerData);
        }
      }
    }
  }
}

export const layerManager = LayerManager.getInstance();

// --- Datei: Launchweb/leaflet-setup.js ---

import { layerManager } from './layer-manager.js';

export function setupLeafletMap(lat, lng, zoom) {
  const map = L.map('map').setView([lat, lng], zoom);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);

  const daten = layerManager.getData();
  console.log('🧪 LayerManager Daten in leaflet:', daten);

  if (daten?.knoten?.length) {
    daten.knoten.forEach(k => {
      if (k.lat && k.lng) {
        L.marker([k.lat, k.lng]).addTo(map).bindPopup(k.name || 'Knoten');
      }
    });
  }

  return map;
}

// --- Datei: Launchweb/style.css ---

/* style.css — Version: Σ.v1.0.webstruktur */

html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: system-ui, sans-serif;
    background-color: #fdfaf6;
}

#map {
    height: 100%;
    width: 100%;
}

.overlay {
    position: absolute;
    top: 10%;
    left: 10%;
    width: 80%;
    max-height: 80%;
    background: white;
    border: 2px solid #ccc;
    border-radius: 8px;
    padding: 1em;
    box-shadow: 0 0 10px rgba(0,0,0,0.2);
    overflow-y: auto;
    z-index: 1000;
}

.overlay.hidden {
    display: none;
}

.info-panel {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background: rgba(255,255,255,0.95);
    padding: 1em;
    border-top: 2px solid #ccc;
    display: none;
    z-index: 900;
}

.info-panel.visible {
    display: block;
}

#ui-controls {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 1100;
}

#ui-controls button {
    padding: 0.5em 1em;
    font-size: 1em;
    border-radius: 4px;
    border: none;
    background-color: #333;
    color: white;
    cursor: pointer;
    transition: background 0.2s;
}

#ui-controls button:hover {
    background-color: #555;
}

/* Tooltip-Styling (für utility-tooltip.js) */
.tooltip {
    position: absolute;
    background: #fff;
    padding: 0.5em 0.8em;
    border-radius: 4px;
    border: 1px solid #ccc;
    font-size: 0.9em;
    pointer-events: none;
    box-shadow: 0 0 5px rgba(0,0,0,0.1);
    z-index: 2000;
}

/* Farben aus visual/colors.js könnten per Klasse nachgeladen werden */

.layer-controls {
    position: absolute;
    top: 1em;
    right: 1em;
    background: rgba(255, 255, 255, 0.8);
    padding: 0.5em;
    border-radius: 5px;
    font-size: 0.9em;
}

.layer-toggle-label {
    display: block;
    margin: 0.2em 0;
}

// --- Datei: Launchweb/weltweb.txt ---



⸻

Manifest der Weltweberei


⸻

🧶 Webung

Webung bezeichnet jede Handlung, mit der ein Weber über seine Rolle in die Welt eingreift.
	•	Die Rolle ist visuell verankert an einem festen Ort auf der Leaflet-Karte, identifiziert über eine ID bei Registrierung.
	•	Eine Webung erzeugt eine Verbindung von der Rolle zu einem beliebigen Punkt auf der Karte – entweder:
	•	als Faden: temporär (verblasst innerhalb von 7 Tagen)
	•	als Garn: dauerhaft (bis zur aktiven Auflösung)

Eine Webung entsteht z. B. durch:
	•	Erstellen eines Knotens (Informationspunkt mit Kontext)
	•	Teilnahme an einem Gespräch
	•	Stellung eines Antrags
	•	Abgabe einer Zusage

	der Weber entscheidet selbst, ob er Faden oder Garn benutzt. Garn gilt als verbindliche Zusage.
	auch im Nachhinein kann ein Weber seine Rolle mit einem Knoten verbinden, wenn er beispielsweise physisch an einem Ereignis zugegen war und seine Mitwirkung nun dokumentieren möchte
⸻

🪢 Knoten

Ein Knoten entsteht, wenn ein Weber eine neue Webung mit Informationsinhalt an einem Ort auf der Karte vornimmt.
	•	Der Knoten ist Träger:
	•	von Informationen (z. B. Ankündigungen, Hinweise)
	•	von Gesprächsmöglichkeiten (Diskurs)
	•	von Anträgen (siehe unten)
	•	Weitere Webungen anderer Weber verknüpfen sich automatisch mit dem Knoten.
	•	Ein Knoten löst sich auf, wenn kein Faden und kein Garn mehr mit ihm verbunden ist.

Darstellung:
	•	Standardmäßig als visueller Knoten dargestellt
	•	Material: abgeleitet aus den verbundenen Fäden und Garne
	•	Visualisierung kann vom ursprünglichen Weber selbst angepasst werden

⸻

🧭 Webkasse

Die Webkasse ist das Gemeinschaftskonto der Ortsweberei.
Sie ist der exklusive Ort für Geldauszahlungsanträge.

⸻

🧾 Anträge
	•	Können gestellt werden auf:
	•	Geldauszahlung (→ nur über Knotenknüpfung auf Webkasse, heißen Goldantrag und sind mit goldenem Rand versehen)
	•	Veränderung
	•	Anschaffung
	•	alles mögliche

Visualisierung:
	•	Blauer Faden bei Stellung
	•	Lila Faden bei Einspruch (binnen 7 Tagen möglich)
	•	Grüner Faden bei Annahme
– automatisch 7 Tage nach Antragstellung (ohne Einspruch)
– bei Einspruch: Abstimmung 7 Tage nach Einspruch
	•	Roter Faden bei Ablehnung
	•	Goldener Rand bei Goldanträgen
	•	Jeder Antragsfaden verblasst 7 Tage nach Entscheidung

⸻

🧵 Extraräume
	•	Nähstübchen → Raum zum freien Plaudern
	•	Webrat → Diskussionen zu orts- und ereignisunabhängigen Themen

⸻

🗓️ Zeitleiste / Auditfunktion
	•	Navigierbare Zeitleiste, um vergangene Webungen auditierbar zu halten
	•	Zeitreise: Tag-für-Tag, einstellbare Geschwindigkeit
	•	Statische Zeitfenster: frei wählbare Intervalle (z. B. 1 Woche, 1 Monat etc.)

⸻

📱 Mobile first!

Alle Funktionalitäten und Interfaces sind von Grund auf für mobile Nutzung optimiert.


Wenn ein Weber an einem Gespräch teilnimmt, dann webt sich automatisch ein Faden von seiner Rolle in den Gesprächsraum. Solch ein Faden verschwindet ja sukzessive wieder innerhalb einer Woche. Wenn ein Weber dann aber in diesem Zeitraum weitere Beiträge in demselben Knoten tätigt, dann wird der Faden dicker (immer proportional zu der zeitlich überlappenden Anzahl der Beiträge. Dabei ist jeder Faden (zumindest anteilig) visuell vertreten (mit seiner jeweiligen Farbe und Transparenz))
Garn wiederum steht ja für verbindliche Zusagen und bleibt als stabile Verbindung zwischen Rolle und knoten, bis entweder der knoten Aufgelöst wird oder die Zusage abgebrochen wird. Garn erkennt man an der gezwirnten Optik (oder welche Optik Garn auch immer hat). Ist ein Ereignis vergangen (und hat sich also die Zusage in Tat umgewandelt) wird der knoten und die zu ihm führenden Fäden und Garne grau und verschwindet im laufe einer Woche sukzessive.

weltweberei/
├── index.html                    → Einstiegspunkt (Leaflet + UI-Struktur)
├── style.css                    → Grundlayout, farblich Weberei-konform
├── main.js                      → App-Starter: Kartenaufbau + Datenbindung
├── startup-loader.js            → Initialdaten, UI-Init, Layer-Setup
├── leaflet-setup.js             → Karte + Zeitachse + Keyevents

├── core/
    --- webung-engine.js
│   ├── zeitlogik.js             → Blasszeiten, Garnhaltbarkeit, Zeitreise
│   ├── knotenerkennung.js       → Logik zur Auflösung und Persistenzprüfung
│   ├── verblasslogik.js         → Fadenverblassung etc.
│   └── manifest.js              → Manifest-Logik (aus `weltweb.txt`)

├── data/
│   ├── data-model.js            → Datenstrukturen: Knoten, Fäden, Garne
│   ├── data-knoten.js           → Knoten-spezifische Datenhaltung
│   ├── data-diskurs.js          → Diskursdaten: Gespräche, Beiträge, etc.
│   ├── data-finanz.js           → Webkassen-Datenhaltung
│   └── persistence-service.js (+.client, +.server)  → Datei-/Serverpersistenz (Filesystem/Backend)

├── services/
│   ├── api-service.js           → Generische API-Schicht
│   ├── api-diskurs.js           → Gesprächs-API
│   ├── api-knoten.js            → Knotendaten-API
│   ├── websocket-service.js     → Live-Daten
│   ├── websocket-integration.js → Events live synchronisieren
│   ├── auth-service.js          → Anmeldung & Rollenverknüpfung
│   └── file-storage.js          → Lokale Dateioperationen├── api-antrag.js           → API für Anträge
│   ├── api-verblassen.js       → API für Verblasslogik
│   ├── api-webung.js           → API für allgemeine Webungen

├── visual/
│   ├── render-knoten.js             → Visualisierung der Knoten
│   ├── render-faeden.js             → Darstellung aller Fäden
│   ├── render-garne.js              → Darstellung aller Garne
│   ├── render-antraege.js             → Darstellung Antragszyklen
│   ├── render-webkasse.js           → Darstellung Webkasse
│   └── colors.js                → Farbsemantik & Symbolfarben

├── ui/
│   ├── ui-core.js               → Grundinteraktionen & UI-Logik
│   ├── ui-interactions.js       → Buttons, Events, UI-Flows
│   ├── ui-themenfilter.js       → Filter für Knotentypen
│   ├── ui-login.js              → Loginmaske + Identifikation
│   ├── ui-ereignis.js           → Knoteninteraktionen
│   ├── ui-finanz.js             → Webkasseninterface

│   ├── knoten/
│   │   ├── ui-knoten.js         → Knotendarstellung (Info + Visu)
│   │   ├── knoten-engine.js     → Knotenanlage, Logik
│   │   └── knoten-form.js       → Formular zur Knotenerstellung

│   ├── diskurs/
│   │   ├── ui-diskurs.js        → Gesprächsfenster
│   │   ├── diskurs-engine.js    → Diskursverlauf + Webungslogik
│   │   └── diskurs-form.js      → Beiträge hinzufügen, Antrag starten

│   ├── antrag/
│   │   ├── ui-antrag.js         → Antrag-UI
│   │   ├── antrag-engine.js     → Zyklus-Logik
│   │   └── antrag-form.js       → Antragsformular

│   └── extras/
│       ├── ui-zeitreise.js      → Zeitleistensteuerung
│       ├── ui-webrat.js         → Ortunabhängige Debatte
│       ├── ui-naehstuebchen.js  → Plauderbereich
│       └── zeitleiste.js        → Visualisierung vergangener Webungen

├── utils/
│   ├── utility-core.js          → Allg. Hilfsfunktionen
│   ├── utility-tooltip.js       → Tooltip-System
│   ├── form-components.js       → Felder, Dropdowns etc.
│   ├── validation.js            → Formprüfungen
│   └── utils.js                 → Alles sonstige

└── models/
    ├── user-model.js            → Rollenstruktur, Fadenverhalten
    └── knotentypen.js           → Definition & Farben aller Knotentypen

// --- Datei: Launchweb/ui/ui-ereignis.js ---

// ui-ereignis.js — Interaktion mit einzelnen Knotenpunkten

import { showKnotenInfo } from './knoten/ui-knoten.js';

export function setupEreignisInteraktion() {
    document.addEventListener('click', (e) => {
        const target = e.target.closest('.knotenpunkt');
        if (target) {
            const knotenId = target.dataset.knotenId;
            if (knotenId) {
                showKnotenInfo(knotenId);
            }
        }
    });
}

// --- Datei: Launchweb/ui/ui-interactions.js ---

// ui-interactions.js — Steuerung von Buttons und UI-Aktionen

export function setupUIInteractions() {
    const knotenButton = document.getElementById('neuer-knoten');
    const zeitreiseButton = document.getElementById('zeitreise-button');
	
	document.getElementById('toggle-faeden').addEventListener('click', () => {
    layerManager.toggleLayer('faeden');
    svgLayer.requestRender();
});

    if (knotenButton) {
        knotenButton.addEventListener('click', () => {
            alert('Knotenerstellung folgt.');
        });
    }

    if (zeitreiseButton) {
        zeitreiseButton.addEventListener('click', () => {
            alert('Zeitleiste wird aktiviert.');
        });
    }
}

// --- Datei: Launchweb/ui/ui-finanz.js ---

// ui-finanz.js — Webkassenanzeige & Interaktion

export function renderWebkasse(data) {
    const container = document.getElementById('webkasse-container');
    if (!container) return;

    const eintraege = data.map(eintrag => `
        <div class="buchung">
            <span class="betrag">${eintrag.betrag.toFixed(2)}€</span>
            <span class="zweck">${eintrag.zweck}</span>
            <span class="datum">${eintrag.datum}</span>
        </div>
    `).join('');

    container.innerHTML = `
        <h3>Webkasse</h3>
        <div class="eintraege">${eintraege}</div>
    `;
}

// --- Datei: Launchweb/ui/ui-themenfilter.js ---

// ui-themenfilter.js — Filterung nach Knotentypen (Farben, Kategorien)

export function initializeThemenfilter() {
    const filterElement = document.getElementById('themenfilter');

    if (!filterElement) return;

    filterElement.addEventListener('change', () => {
        const selected = filterElement.value;
        const event = new CustomEvent('filterChange', { detail: { selected } });
        window.dispatchEvent(event);
    });
}

// --- Datei: Launchweb/ui/ui-core.js ---

// ui-core.js — Version: uiΣ.v1.0.basismodul

export function initializeUICore() {
    const overlay = document.getElementById('webungs-overlay');
    const infoPanel = document.getElementById('knoten-info');

    function showOverlay(contentHtml) {
        overlay.innerHTML = contentHtml;
        overlay.classList.remove('hidden');
    }

    function hideOverlay() {
        overlay.classList.add('hidden');
        overlay.innerHTML = '';
    }

    function showInfo(contentHtml) {
        infoPanel.innerHTML = contentHtml;
        infoPanel.classList.remove('hidden');
    }

    function hideInfo() {
        infoPanel.classList.add('hidden');
        infoPanel.innerHTML = '';
    }

    function toggleOverlay(contentHtml) {
        if (overlay.classList.contains('hidden')) {
            showOverlay(contentHtml);
        } else {
            hideOverlay();
        }
    }

    function toggleInfo(contentHtml) {
        if (infoPanel.classList.contains('hidden')) {
            showInfo(contentHtml);
        } else {
            hideInfo();
        }
    }

    return {
        showOverlay,
        hideOverlay,
        showInfo,
        hideInfo,
        toggleOverlay,
        toggleInfo
    };
}

// --- Datei: Launchweb/ui/ui-login.js ---

// ui-login.js — Version: Σ.v1.auth.ui

import { rolleService } from '../models/user-model.js';

export function setupLoginUI() {
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('login-name');

    loginForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const name = nameInput.value.trim();
        if (name) {
            rolleService.login(name);
            document.getElementById('login-panel').style.display = 'none';
        }
    });

    if (rolleService.isLoggedIn()) {
        document.getElementById('login-panel').style.display = 'none';
    }
}

// --- Datei: Launchweb/ui/knoten/knoten-engine.js ---

// knoten-engine.js — Logik zum Erstellen und Speichern neuer Knoten

import { speichereKnoten } from '../../data/data-knoten.js';

export async function erstelleKnoten(knotenDaten) {
    const neuerKnoten = {
        id: Date.now().toString(),
        ...knotenDaten
    };

    await speichereKnoten(neuerKnoten);
    alert('Knoten erfolgreich erstellt.');
}

// --- Datei: Launchweb/ui/knoten/ui-knoten.js ---

// ui-knoten.js — Anzeige eines Knotens + Optionen

import { getKnotenById } from '../../data/data-knoten.js';

export function showKnotenInfo(knotenId) {
    const knoten = getKnotenById(knotenId);
    if (!knoten) return;

    const info = `
        <h2>${knoten.titel}</h2>
        <p>${knoten.beschreibung}</p>
        <button id="beitreten-btn">Beitreten</button>
    `;

    window.showInfoPanel(info);

    const btn = document.getElementById('beitreten-btn');
    if (btn) {
        btn.addEventListener('click', () => {
            alert('Webung mit diesem Knoten folgt.');
        });
    }
}

// --- Datei: Launchweb/ui/knoten/knoten-form.js ---

// knoten-form.js — Formular zur Knotenerstellung

import { erstelleKnoten } from './knoten-engine.js';

export function initKnotenForm() {
    const form = document.getElementById('knoten-form');
    if (!form) return;

    form.addEventListener('submit', async (e) => {
        e.preventDefault();

        const titel = form.querySelector('#titel').value;
        const beschreibung = form.querySelector('#beschreibung').value;

        await erstelleKnoten({ titel, beschreibung });
        form.reset();
    });
}

// --- Datei: Launchweb/ui/antrag/antrag-form.js ---

// antrag-form.js — v1

import { AntragEngine } from './antrag-engine.js';
import { generateId, todayISO } from '../../utils/utility-core.js';

export function erstelleAntragsformular(knotenId) {
    const form = document.createElement('form');
    form.innerHTML = `
        <h3>Neuer Antrag</h3>
        <label>Typ:
            <select name="typ">
                <option value="anschaffung">Anschaffung</option>
                <option value="veraenderung">Veränderung</option>
                <option value="goldantrag">Goldantrag</option>
            </select>
        </label>
        <label>Beschreibung:
            <textarea name="beschreibung" required></textarea>
        </label>
        <button type="submit">Antrag stellen</button>
    `;

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = new FormData(form);
        const neuerAntrag = {
            id: generateId(),
            typ: formData.get('typ'),
            beschreibung: formData.get('beschreibung'),
            knotenId,
            status: 'gestellt',
            gestelltAm: todayISO()
        };
        await AntragEngine.speichere(neuerAntrag);
        alert('Antrag gestellt.');
    });

    return form;
}

// --- Datei: Launchweb/ui/antrag/render-antraege.js ---

// render-antraege.js — v1

import { getFarbeFürAntrag } from './colors.js';

export function renderAntragsfaden(antrag) {
    const farbe = getFarbeFürAntrag(antrag);
    const faden = L.polyline([antrag.start, antrag.ziel], {
        color: farbe,
        weight: 3,
        className: antrag.typ === 'goldantrag' ? 'goldrand' : ''
    });
    faden.addTo(window.map); // globale Referenz
}

// --- Datei: Launchweb/ui/antrag/antrag-engine.js ---

// antrag-engine.js — v1

import { Speicher } from '../../data/persistence-service.js';
import { differenceInDays, parseISO } from 'date-fns';

export const AntragEngine = {
    async finde(id) {
        const alle = await Speicher.ladeAlle('antraege');
        return alle.find(a => a.id === id);
    },

    async speichere(antrag) {
        await Speicher.speichere('antraege', antrag);
    },

    async aktualisiereStatus() {
        const antraege = await Speicher.ladeAlle('antraege');
        const heute = new Date();

        for (let a of antraege) {
            const gestellt = parseISO(a.gestelltAm);
            if (a.status === 'gestellt') {
                if (differenceInDays(heute, gestellt) >= 7) {
                    a.status = 'angenommen';
                }
            } else if (a.status === 'einspruch') {
                const einspruch = parseISO(a.einspruchAm);
                if (differenceInDays(heute, einspruch) >= 7) {
                    a.status = 'abgelehnt';
                }
            }
        }

        await Speicher.schreibe('antraege', antraege);
    },

    async einspruchEinlegen(id) {
        const antraege = await Speicher.ladeAlle('antraege');
        const a = antraege.find(e => e.id === id);
        if (a && a.status === 'gestellt') {
            a.status = 'einspruch';
            a.einspruchAm = new Date().toISOString();
        }
        await Speicher.schreibe('antraege', antraege);
    }
};

// --- Datei: Launchweb/ui/antrag/ui-antrag.js ---

// ui-antrag.js — v1

import { AntragEngine } from './antrag-engine.js';
import { renderAntragsfaden } from '../../visual/render-antraege.js';

export function setupAntragUI() {
    document.addEventListener('click', async (e) => {
        if (e.target.matches('[data-antrag-id]')) {
            const id = e.target.dataset.antragId;
            const antrag = await AntragEngine.finde(id);
            if (antrag) {
                renderAntragsfaden(antrag);
            }
        }
    });
}

// --- Datei: Launchweb/ui/diskurs/diskurs-engine.js ---

// diskurs-engine.js — Logik zur Beitragserstellung und Fadenverknüpfung

import { speichereBeitrag } from '../../data/data-diskurs.js';
import { verknuepfeFaden } from '../../core/verblasslogik.js';

export async function hinzufuegenBeitrag(knotenId, autor, text) {
    const beitrag = {
        id: Date.now().toString(),
        knotenId,
        autor,
        text,
        zeitpunkt: new Date().toISOString()
    };

    await speichereBeitrag(beitrag);
    await verknuepfeFaden(autor, knotenId, 'beitrag');
}

// --- Datei: Launchweb/ui/diskurs/diskurs-form.js ---

// diskurs-form.js — Formular zur Erstellung eines Diskursbeitrags

import { hinzufuegenBeitrag } from './diskurs-engine.js';

export function startBeitragFormular(knotenId) {
    const html = `
        <form id="diskurs-eingabe">
            <input type="text" id="autor" placeholder="Dein Name" required />
            <textarea id="text" placeholder="Dein Beitrag" required></textarea>
            <button type="submit">Absenden</button>
        </form>
    `;

    const ziel = document.getElementById('diskurs-formular');
    if (ziel) ziel.innerHTML = html;

    const form = document.getElementById('diskurs-eingabe');
    if (form) {
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const autor = form.querySelector('#autor').value;
            const text = form.querySelector('#text').value;
            await hinzufuegenBeitrag(knotenId, autor, text);
            form.reset();
        });
    }
}

// --- Datei: Launchweb/ui/diskurs/ui-diskurs.js ---

// ui-diskurs.js — Anzeige des Gesprächsverlaufs innerhalb eines Knotens

import { getBeitraegeFuerKnoten } from '../../data/data-diskurs.js';
import { startBeitragFormular } from './diskurs-form.js';

export function zeigeDiskurs(knotenId) {
    const beitraege = getBeitraegeFuerKnoten(knotenId);

    const html = `
        <div class="diskurs-header">
            <h3>Gespräch zum Knoten</h3>
            <button id="beitrag-hinzufuegen">Beitrag verfassen</button>
        </div>
        <ul class="diskurs-liste">
            ${beitraege.map(b => `<li><strong>${b.autor}:</strong> ${b.text}</li>`).join('')}
        </ul>
        <div id="diskurs-formular"></div>
    `;

    const container = document.getElementById('diskurs-container');
    if (container) container.innerHTML = html;

    document.getElementById('beitrag-hinzufuegen')?.addEventListener('click', () => {
        startBeitragFormular(knotenId);
    });
}

// --- Datei: Launchweb/ui/layer/ui-layer-toggle.js ---

// ui-layer-toggle.js — Version: Σ.v1.layer.ui.toggle

export function setupLayerToggle(layerManager) {
    const container = document.getElementById('layer-controls');
    if (!container) return;

    const layerLabels = {
        knoten: 'Knoten',
        faeden: 'Fäden',
        garne: 'Garne',
        antraege: 'Anträge',
        webkasse: 'Webkasse'
    };

    Object.keys(layerLabels).forEach(layerKey => {
        const label = document.createElement('label');
        label.classList.add('layer-toggle-label');

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = layerManager.isLayerVisible(layerKey);
        checkbox.addEventListener('change', () => {
            layerManager.setLayerVisibility(layerKey, checkbox.checked);
        });

        label.appendChild(checkbox);
        label.append(` ${layerLabels[layerKey]}`);
        container.appendChild(label);
    });
}

// --- Datei: Launchweb/ui/layer/ui-layer-advanced.js ---

// ui-layer-advanced.js — Version: Σ.v1.adapted-to-toggle

export function setupLayerControls(layerManager) {
    const controlContainer = document.getElementById('layer-controls');
    if (!controlContainer) return;

    const layerNames = layerManager.getLayerNames();

    layerNames.forEach(layerName => {
        const label = document.createElement('label');
        label.textContent = ` ${layerName}`;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = layerManager.isLayerActive(layerName);

        checkbox.addEventListener('change', () => {
            layerManager.toggleLayer(layerName);
            // optional: trigger Map-Neurender
        });

        label.prepend(checkbox);
        controlContainer.appendChild(label);
    });
}

// --- Datei: Launchweb/ui/extras/ui-naehstuebchen.js ---

// ui-naehstuebchen.js — v1

import { diskursEngine } from '../diskurs/diskurs-engine.js';
import { uiDiskursFenster } from '../diskurs/ui-diskurs.js';

export function öffneNaehstuebchen() {
    const fenster = uiDiskursFenster.erzeuge('naehstuebchen');
    diskursEngine.öffneRaum('naehstuebchen', fenster);
}

// --- Datei: Launchweb/ui/extras/zeitleiste.js ---

// zeitleiste.js — v1

import { renderKnoten } from '../../visual/render-knoten.js';
import { renderFaeden } from '../../visual/render-faeden.js';

export const zeitleiste = {
    alleDaten: [],
    aktuelleZeit: null,

    init(data) {
        this.alleDaten = data;
    },

    zeigeTag(tagIndex) {
        const tag = this.alleDaten[tagIndex];
        if (!tag) return;
        this.aktuelleZeit = tag.datum;
        renderKnoten(tag.knoten);
        renderFaeden(tag.faeden);
    }
};

// --- Datei: Launchweb/ui/extras/ui-webrat.js ---

// ui-webrat.js — v1

import { diskursEngine } from '../diskurs/diskurs-engine.js';
import { uiDiskursFenster } from '../diskurs/ui-diskurs.js';

export function öffneWebrat() {
    const fenster = uiDiskursFenster.erzeuge('webrat');
    diskursEngine.öffneRaum('webrat', fenster);
}

// --- Datei: Launchweb/ui/extras/ui-zeitreise.js ---

// ui-zeitreise.js — v1

import { zeitleiste } from './zeitleiste.js';

export function setupZeitreiseUI() {
    const controls = document.getElementById('zeitreise-controls');
    const startBtn = controls.querySelector('#start-zeitreise');
    const stopBtn = controls.querySelector('#stop-zeitreise');
    const slider = controls.querySelector('#zeitreise-slider');

    let interval = null;

    startBtn.addEventListener('click', () => {
        let tag = parseInt(slider.value, 10);
        interval = setInterval(() => {
            zeitleiste.zeigeTag(tag++);
            slider.value = tag;
        }, 1000);
    });

    stopBtn.addEventListener('click', () => {
        clearInterval(interval);
        interval = null;
    });

    slider.addEventListener('input', () => {
        zeitleiste.zeigeTag(parseInt(slider.value, 10));
    });
}

// --- Datei: Launchweb/core/manifest.js ---

// manifest.js — Version: Σ.v1.systembegriffe

export const Typen = {
    webung: {
        faden: 'faden',
        garn: 'garn',
        antrag: 'antrag'
    },

    antrag: {
        gold: 'gold',
        veraenderung: 'veraenderung',
        anschaffung: 'anschaffung'
    },

    status: {
        aktiv: 'aktiv',
        verblasst: 'verblasst',
        angenommen: 'angenommen',
        abgelehnt: 'abgelehnt',
        einspruch: 'einspruch'
    }
};

// --- Datei: Launchweb/core/zeitlogik.js ---

// zeitlogik.js — Version: Σ.v1.verblassung

export const Zeitlogik = {
    verblassungsTage: 7,

    istVerblassend(webung, jetzt = new Date()) {
        if (!webung.verblasstAm) return false;
        return new Date(webung.verblasstAm) < jetzt;
    },

    berechneVerblassung(typ, ereigniszeitpunkt = null) {
        const basis = ereigniszeitpunkt
            ? new Date(ereigniszeitpunkt)
            : new Date();

        if (typ === 'garn') return null; // bleibt permanent
        const verblass = new Date(basis);
        verblass.setDate(verblass.getDate() + Zeitlogik.verblassungsTage);
        return verblass.toISOString();
    }
};

// --- Datei: Launchweb/core/knotenerkennung.js ---

// knotenerkennung.js — Version: Σ.v1.knotenlogik

import { Knoten } from '../models/knotenmodell.js';
import { generateUUID } from '../utils.js';

export class Knotenerkennung {
    static erstelleKnoten({ koordinaten, erstellerId, beschreibung, typ = "standard", darstellung = "default" }) {
        const neuerKnoten = new Knoten({
            id: generateUUID(),
            koordinaten,
            erstellerId,
            beschreibung,
            typ,
            darstellung
        });

        return neuerKnoten;
    }

    static loescheWennVerwaist(knoten, webungListe) {
        const aktiveVerbindungen = webungListe.filter(w => w.zuKnotenId === knoten.id && w.zustand === 'aktiv');
        return aktiveVerbindungen.length === 0;
    }
}

// --- Datei: Launchweb/core/verblasslogik.js ---

// core/verblasslogik.js — Version: Σ.v2.fadenverfall.vollständig

import { parseISO, differenceInDays } from 'date-fns';

export class Verblasslogik {
    static pruefeVerblassen(webung, knotenHatEreigniszeitpunkt = false) {
        const erstellt = parseISO(webung.entstandenAm);
        const now = new Date();
        const tageVergangen = differenceInDays(now, erstellt);

        if (webung.typ === 'garn') return false;

        // Wenn ein Ereigniszeitpunkt existiert, zählt ab diesem + 7 Tage
        return tageVergangen > 7;
    }

    static setzeVerblasstStatus(webung, knotenHatEreigniszeitpunkt = false) {
        if (this.pruefeVerblassen(webung, knotenHatEreigniszeitpunkt)) {
            webung.zustand = 'verblasst';
        }
    }

    static tageBisVerblassen(webung, knotenHatEreigniszeitpunkt = false) {
        const erstellt = parseISO(webung.entstandenAm);
        const now = new Date();
        const verbleibend = 7 - differenceInDays(now, erstellt);
        return Math.max(0, verbleibend);
    }

    static istVerblasst(webung) {
        return webung.zustand === 'verblasst';
    }
}

// --- Datei: Launchweb/core/antragszyklus.js ---

// antragslogik.js — Version: Σ.v1.antragszyklus

import { parseISO, differenceInDays } from 'date-fns';

export class Antragslogik {
    static pruefeEntscheidung(antrag, einspruchsDatum = null) {
        const erstellt = parseISO(antrag.entstandenAm);
        const now = new Date();

        if (antrag.zustand !== 'aktiv') return;

        if (!einspruchsDatum) {
            const tage = differenceInDays(now, erstellt);
            if (tage >= 7) {
                antrag.zustand = 'angenommen';
                antrag.farbsignal = 'grün';
            }
        } else {
            const einspruch = parseISO(einspruchsDatum);
            const tageNachEinspruch = differenceInDays(now, einspruch);
            if (tageNachEinspruch >= 7) {
                antrag.zustand = 'abgelehnt';
                antrag.farbsignal = 'rot';
            }
        }
    }

    static initialisiereAntrag(antrag) {
        antrag.farbsignal = 'blau';
    }

    static markiereEinspruch(antrag) {
        antrag.farbsignal = 'lila';
    }

    static kennzeichneGoldantrag(antrag) {
        antrag.goldrand = true;
    }
}

// --- Datei: Launchweb/core/webung-engine.js ---

// webungsengine.js — Version: Σ.v1.core

import { Rolle } from './rolle.js';
import { Faden } from './fadenmodell.js';
import { Knoten } from './knoten-modell.js';
import { Verblasslogik } from './verblasslogik.js';
import { Knotenerkennung } from './knotenerkennung.js';
import { persistenceService } from './persistence-service.js';
import { WebSocketServiceSingleton as ws } from './websocket-service.js';

export const WebungsEngine = {
    async neueWebung({ rollenId, koordinaten, inhalt, typ = 'faden', optional = {} }) {
        const rolle = await persistenceService.find('rollen', rollenId);
        if (!rolle) throw new Error('Rolle nicht gefunden');

        // 1. Knoten prüfen oder erzeugen
        let knoten = await Knotenerkennung.findeOderErzeugeKnoten(koordinaten, inhalt);

        // 2. Webung erzeugen
        const webung = new Faden({
            rolleId: rollenId,
            knotenId: knoten.id,
            typ,
            inhalt,
            ...optional
        });

        // 3. Verknüpfen
        rolle.webungen.push(webung.id);
        knoten.webungen.push(webung.id);

        // 4. Verblasslogik anwenden
        Verblasslogik.setzeVerblasstStatus(webung);

        // 5. Speichern
        await persistenceService.save('rollen', rolle);
        await persistenceService.save('knoten', knoten);
        await persistenceService.save('webungen', webung);

        // 6. WebSocket-Broadcast
        ws.send({ type: 'webung_neu', payload: { webungId: webung.id } });

        return webung;
    },

    async prüfeVerblassungFürAlle() {
        const webungen = await persistenceService.getAll('webungen');
        const knotenMap = await persistenceService.getMap('knoten');

        for (const webung of webungen) {
            const knoten = knotenMap[webung.knotenId];
            Verblasslogik.setzeVerblasstStatus(webung, !!knoten?.ereigniszeitpunkt);
            await persistenceService.save('webungen', webung);
        }
    }
};

// --- Datei: Launchweb/utils/utility-tooltip.js ---

// utility-tooltip.js — Version: Σ.v1.tooltip.system

export function createTooltip(content, position) {
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    tooltip.innerText = content;
    tooltip.style.top = `${position.y}px`;
    tooltip.style.left = `${position.x}px`;
    document.body.appendChild(tooltip);
    return tooltip;
}

export function removeTooltip() {
    const tooltips = document.querySelectorAll('.tooltip');
    tooltips.forEach(t => t.remove());
}

// --- Datei: Launchweb/utils/validation.js ---

// validation.js — Version: Σ.v1.form.validation

export const Validators = {
    required(value) {
        return value?.trim() ? null : 'Pflichtfeld';
    },

    minLength(min) {
        return (value) => {
            return value.length >= min ? null : `Mindestens ${min} Zeichen`;
        };
    },

    isNumber(value) {
        return isNaN(value) ? 'Muss eine Zahl sein' : null;
    }
};

// --- Datei: Launchweb/utils/utility-core.js ---

// utility-core.js — Version: Σ.v1.core.util

export const UtilityCore = {
    generateUUID() {
        return crypto.randomUUID();
    },

    formatDate(date) {
        return new Intl.DateTimeFormat('de-DE', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        }).format(new Date(date));
    },

    clone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
};

// --- Datei: Launchweb/utils/form-components.js ---

// form-components.js — Version: Σ.v1.formteile

export function createInputField({ id, label, type = 'text', placeholder = '', value = '' }) {
    const wrapper = document.createElement('div');
    const labelEl = document.createElement('label');
    labelEl.setAttribute('for', id);
    labelEl.textContent = label;

    const input = document.createElement('input');
    input.type = type;
    input.id = id;
    input.placeholder = placeholder;
    input.value = value;

    wrapper.appendChild(labelEl);
    wrapper.appendChild(input);
    return wrapper;
}

export function createSelect({ id, label, options }) {
    const wrapper = document.createElement('div');
    const labelEl = document.createElement('label');
    labelEl.setAttribute('for', id);
    labelEl.textContent = label;

    const select = document.createElement('select');
    select.id = id;

    options.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.label;
        select.appendChild(option);
    });

    wrapper.appendChild(labelEl);
    wrapper.appendChild(select);
    return wrapper;
}

// --- Datei: Launchweb/utils/utils.js ---

// utils.js — Version: Σ.v1.misc.tools

export function debounce(fn, delay) {
    let timer = null;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), delay);
    };
}

export function throttle(fn, limit) {
    let inThrottle;
    return function (...args) {
        if (!inThrottle) {
            fn(...args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
        }
    };
}

// --- Datei: Launchweb/models/webung.js ---

// fadenmodell.js — Version: Σ.v1.fadenstruktur

export class Webung {
    constructor({ id, typ = "faden", vonRolleId, zuKnotenId }) {
        this.id = id;
        this.typ = typ; // "faden", "garn", "antrag", "goldantrag"
        this.vonRolleId = vonRolleId;
        this.zuKnotenId = zuKnotenId;
        this.entstandenAm = new Date().toISOString();
        this.zustand = "aktiv"; // oder "verblasst", "abgelehnt", "angenommen"
        this.farbsignal = null; // z. B. "blau", "lila", "grün", "rot", "goldrand"
    }
}

// --- Datei: Launchweb/models/user-model.js ---

// models/user-model.js — Version: Σ.v1.rolle.core

export const rolleService = {
    rolleId: null,

    set(id) {
        this.rolleId = id;
        localStorage.setItem('rolleId', id);
    },

    get() {
        return this.rolleId || localStorage.getItem('rolleId');
    },

    restore() {
        this.rolleId = localStorage.getItem('rolleId');
    }
};

// --- Datei: Launchweb/models/knotentypen.js ---

// models/knotentypen.js — Definition symbolischer Knotentypen

export const Knotentypen = {
    standard: {
        farbe: '#7F8C8D',
        symbol: '●',
        beschreibung: 'Standardknoten ohne Spezifizierung'
    },
    goldantrag: {
        farbe: '#F1C40F',
        symbol: '◎',
        beschreibung: 'Geldantrag in der Webkasse'
    },
    zusage: {
        farbe: '#2ECC71',
        symbol: '✓',
        beschreibung: 'Verbindliche Zusage (Garn)'
    },
    faden: {
        farbe: '#3498DB',
        symbol: '➝',
        beschreibung: 'Temporäre Beteiligung (Faden)'
    },
    einspruch: {
        farbe: '#9B59B6',
        symbol: '⚠️',
        beschreibung: 'Einspruch gegen Antrag'
    },
    abgelehnt: {
        farbe: '#E74C3C',
        symbol: '✗',
        beschreibung: 'Abgelehnter Antrag'
    },
    angenommen: {
        farbe: '#27AE60',
        symbol: '✓',
        beschreibung: 'Angenommener Antrag'
    }
};

// --- Datei: Launchweb/visuals/render-garne.js ---

// visual/render-garne.js — Version: Σ.v∞.garn.verbindung.symbolisch

import * as d3 from 'd3';
import { Farben } from './colors.js';

/**
 * Zeichnet dauerhafte Garnverbindungen zwischen Knoten (z. B. durch Zusagen)
 */
export function renderGarne(svg, projection, daten) {
  const garne = daten.filter(w => w.typ === 'garn' && w.zustand !== 'verblasst');

  const verbindungen = svg.selectAll('.garn').data(garne, d => d.id);
  verbindungen.exit().remove();

  const neu = verbindungen.enter()
    .append('path')
    .attr('class', 'garn');

  neu.merge(verbindungen)
    .attr('d', d => {
      const [x1, y1] = projection([d.quelle.lng, d.quelle.lat]);
      const [x2, y2] = projection([d.ziel.lng, d.ziel.lat]);
      return `M${x1},${y1} L${x2},${y2}`;
    })
    .attr('stroke', d => {
      const farbe = Farben.garn[d.zustand] || Farben.garn.zusage;
      return farbe;
    })
    .attr('stroke-width', d => 3 + (d.intensität || 0))
    .attr('stroke-dasharray', '1,3') // Zwirn-Stil
    .attr('opacity', 0.9)
    .attr('fill', 'none');
}

// --- Datei: Launchweb/visuals/render-webkasse.js ---

// visual/render-webkasse.js — Version: Σ.v∞.symbol.gold.circle

import { Farben } from './colors.js';

/**
 * Zeichnet die kollektive Webkasse als Kreis mit Goldfarbe
 */
export function renderWebkasse(selection, projection, data, showTooltip, hideTooltip) {
  const pos = projection({ lat: 53.56, lng: 10.03 }); // feste Position
  const stand = data.webkasse?.kontostand || 0;
  const radius = Math.sqrt(stand) * 0.05 + 10;

  const topf = selection.selectAll('.webkasse').data([stand]);

  topf.enter()
    .append('circle')
    .attr('class', 'webkasse')
    .merge(topf)
    .attr('cx', pos.x)
    .attr('cy', pos.y)
    .attr('r', radius)
    .attr('fill', Farben.webkasse)
    .attr('fill-opacity', 0.8)
    .attr('stroke', '#222')
    .attr('stroke-width', 1.5)
    .on('mouseover', e => showTooltip(`Webkasse: ${stand.toFixed(2)} €`, e.pageX, e.pageY))
    .on('mouseout', hideTooltip);

  topf.exit().remove();
}

// --- Datei: Launchweb/visuals/render-base.js ---

// render-base.js — Version: Σ.v∞.style.core

export const RenderBase = {
    fadenStyle(farbe, dicke = 2, transparenz = 0.5) {
        return {
            stroke: farbe,
            'stroke-width': dicke,
            'stroke-opacity': transparenz,
            fill: 'none'
        };
    },
    garnStyle(farbe) {
        return {
            stroke: farbe,
            'stroke-dasharray': '5,2',
            'stroke-width': 3,
            'stroke-opacity': 0.9,
            fill: 'none'
        };
    },
    antragRandStyle(farbe) {
        return {
            stroke: farbe,
            'stroke-width': 3,
            fill: 'none'
        };
    }
};

// --- Datei: Launchweb/visuals/render-antraege.js ---

// visual/render-antraege.js — Version: Σ.v∞.antrag.statusfarben.klar

import * as d3 from 'd3';
import { Farben } from './colors.js';

/**
 * Zeichnet alle Anträge mit Farbcodierung je nach Status
 */
export function renderAntraege(svg, projection, daten) {
  const antraege = daten.filter(w => w.typ === 'antrag' && w.zustand !== 'verblasst');

  const verbindungen = svg.selectAll('.antrag')
    .data(antraege, d => d.id);

  verbindungen.exit().remove();

  const neu = verbindungen.enter()
    .append('path')
    .attr('class', 'antrag');

  neu.merge(verbindungen)
    .attr('d', d => {
      const [x1, y1] = projection([d.quelle.lng, d.quelle.lat]);
      const [x2, y2] = projection([d.ziel.lng, d.ziel.lat]);
      return `M${x1},${y1} L${x2},${y2}`;
    })
    .attr('stroke', d => Farben.antrag[d.status] || Farben.antrag.gestellt)
    .attr('stroke-width', 3)
    .attr('stroke-dasharray', '2,4')
    .attr('opacity', 0.9)
    .attr('fill', 'none')
    .attr('filter', d => d.kategorie === 'goldantrag' ? 'url(#goldrand)' : null);
}

// --- Datei: Launchweb/visuals/colors.js ---

// visual/colors.js – Version: Σ.v2.klare-farben

export const Farben = {
  // Fäden
  faden: {
    wortbeitrag: '#888',
    antrag: '#0077cc',
    einspruch: '#8e44ad',
    angenommen: '#27ae60',
    abgelehnt: '#c0392b',
    verblasst: '#ccc'
  },

  // Garne
  garn: {
    zusage: '#d35400',
    vergangen: '#95a5a6'
  },

  // Knoten
  knoten: {
    standard: '#000',
    individuell: '#444'
  },

  // Anträge mit Goldrand
  rand: {
    gold: '#ffd700'
  },

  // UI / Hilfselemente
  ui: {
    highlight: '#f39c12',
    hintergrund: '#fefefe'
  }
};

// --- Datei: Launchweb/visuals/render-faeden.js ---

// visual/render-faeden.js — Version: Σ.v∞.faeden.typisiert

import { select } from 'd3-selection';
import { Farben } from './colors.js';
import { SystemMeta } from '../system-meta.js';

/**
 * Zeichnet temporäre Verbindungen („Fäden“) z. B. Wortbeiträge, Anträge etc.
 */
export function renderFaeden(svg, projection, daten) {
  if (!SystemMeta.istLayerAktiv('faeden')) return;

  const faeden = daten.webungen.filter(w => w.typ === 'faden' && w.zustand !== 'verblasst');

  const layer = svg.selectAll('.faden').data(faeden, d => d.id);

  layer.enter()
    .append('line')
    .attr('class', 'faden')
    .attr('x1', d => projection(d.von)[0])
    .attr('y1', d => projection(d.von)[1])
    .attr('x2', d => projection(d.zu)[0])
    .attr('y2', d => projection(d.zu)[1])
    .style('stroke', d => Farben.faden[d.subtyp] || Farben.faden.wortbeitrag)
    .style('stroke-width', d => Math.max(1, d.stärke || 1))
    .style('opacity', d => d.transparenz || 0.4);

  layer.exit().remove();
}

// --- Datei: Launchweb/visuals/render-knoten.js ---

// render-knoten.js — Version: Σ.v∞.svg.symbol.farbenbasiert

import { Farben } from './colors.js';

export function renderKnoten(selection, projection, bounds, data, showTooltip, hideTooltip) {
  const getLatLng = e =>
    Array.isArray(e.koordinaten)
      ? [e.koordinaten[0], e.koordinaten[1]]
      : [e.koordinaten.lat, e.koordinaten.lng];

  const visible = data.knoten.filter(e => bounds.contains(getLatLng(e)));

  const groups = selection.selectAll('.knoten').data(visible, d => d.id);

  const enter = groups.enter().append('g').attr('class', 'knoten');

  enter.merge(groups)
    .attr('transform', d => {
      const [lat, lng] = getLatLng(d);
      const p = projection({ lat, lng });
      return `translate(${p.x},${p.y})`;
    })
    .each(function (d) {
      const g = d3.select(this);
      const r = d.typ === 'person' ? 10 : 12;
      const fill = Farben.knoten[d.typ] || Farben.knoten.standard;

      g.selectAll('circle')
        .data([d])
        .join('circle')
        .attr('r', r)
        .attr('fill', fill)
        .attr('stroke', '#000')
        .attr('stroke-width', 1.5);

      g.on('mouseover', e => showTooltip(d.titel || 'Knoten', e.pageX, e.pageY))
       .on('mouseout', hideTooltip);
    });

  groups.exit().remove();
}

// --- Datei: Launchweb/visuals/render-fadenlegende.js ---

// render-fadenlegende.js — Version: Σ.v1.fadenlegende

import * as d3 from 'd3';
import { FADENFARBEN, FADENSTILE } from './colors.js';

export function renderFadenlegende(containerId) {
    const fadenTypen = [
        { label: 'Gesprächsbeitrag', farbe: FADENFARBEN.gespräch, stil: FADENSTILE.normal },
        { label: 'Gesprächseröffnung', farbe: FADENFARBEN.gesprächStart, stil: FADENSTILE.normal },
        { label: 'Zusage (Garn)', farbe: FADENFARBEN.garn, stil: FADENSTILE.garn },
        { label: 'Antrag', farbe: FADENFARBEN.antrag, stil: FADENSTILE.normal },
        { label: 'Einspruch', farbe: FADENFARBEN.einspruch, stil: FADENSTILE.normal },
        { label: 'Abgelehnt', farbe: FADENFARBEN.abgelehnt, stil: FADENSTILE.normal },
        { label: 'Angenommen', farbe: FADENFARBEN.angenommen, stil: FADENSTILE.normal },
        { label: 'Goldantrag', farbe: FADENFARBEN.antrag, stil: FADENSTILE.gold },
        { label: 'Vergangen', farbe: FADENFARBEN.vergangen, stil: FADENSTILE.verblassend }
    ];

    const container = d3.select(`#${containerId}`);
    container.html(''); // Reset

    const svg = container.append('svg')
        .attr('width', 300)
        .attr('height', fadenTypen.length * 30);

    const einträge = svg.selectAll('g')
        .data(fadenTypen)
        .enter()
        .append('g')
        .attr('transform', (_, i) => `translate(10, ${i * 30 + 10})`);

    einträge.append('line')
        .attr('x1', 0)
        .attr('y1', 5)
        .attr('x2', 60)
        .attr('y2', 5)
        .attr('stroke', d => d.farbe)
        .attr('stroke-width', d => d.stil === 'garn' ? 4 : 2)
        .attr('stroke-dasharray', d => d.stil === 'verblassend' ? '2,2' : (d.stil === 'gold' ? '4,1' : ''))
        .attr('opacity', d => d.stil === 'verblassend' ? 0.3 : 1);

    einträge.append('text')
        .attr('x', 70)
        .attr('y', 9)
        .text(d => d.label)
        .attr('font-size', '12px')
        .attr('fill', '#333');
}

// --- Datei: Launchweb/data/persistence-services.server.js ---

// persistence-service.server.js — Version: Σ.server.fs

import fs from 'fs/promises';
import path from 'path';

export const PersistenceServer = {
    basePath: './weltweberei-data',

    async ensureDir() {
        await fs.mkdir(this.basePath, { recursive: true });
    },

    filePath(name) {
        return path.join(this.basePath, `${name}.json`);
    },

    async loadAll(name) {
        try {
            const content = await fs.readFile(this.filePath(name), 'utf-8');
            return JSON.parse(content);
        } catch (err) {
            if (err.code === 'ENOENT') return [];
            throw err;
        }
    },

    async write(name, data) {
        await this.ensureDir();
        await fs.writeFile(this.filePath(name), JSON.stringify(data, null, 2));
    },

    async store(name, entry) {
        const data = await this.loadAll(name);
        data.push(entry);
        await this.write(name, data);
    },

    async delete(name, id) {
        const data = await this.loadAll(name);
        const filtered = data.filter(e => e.id !== id);
        await this.write(name, filtered);
    }
};

// --- Datei: Launchweb/data/data-model.js ---

// data-model.js — Version: Σ.v1.modelstruktur

export const Model = {
    webung: {
        id: null,
        vonRollenId: null,
        typ: 'faden' | 'garn' | 'antrag',
        zuKnotenId: null,
        text: '',
        erstelltAm: null,
        verblasstAm: null,
        farbe: '', // optisch gesteuert über Typ & Status
        status: '', // aktiv | verblasst | angenommen | abgelehnt
    },

    knoten: {
        id: null,
        erstelltVon: null,
        erstelltAm: null,
        koordinaten: { lat: 0, lng: 0 },
        text: '',
        visual: 'knotenstandard',
        ereigniszeitpunkt: null // optional
    },

    antrag: {
        id: null,
        vonRollenId: null,
        knotenId: null,
        gestelltAm: null,
        typ: '', // 'gold' | 'veränderung' | 'anschaffung'
        text: '',
        status: 'offen' | 'einspruch' | 'abgelehnt' | 'angenommen',
        einspruchsDatum: null,
        entscheidungsDatum: null
    },

    rolle: {
        id: null,
        name: '',
        wohnort: { lat: 0, lng: 0 }
    }
};

// --- Datei: Launchweb/data/data-finanz.js ---

// data/data-finanz.js — Version: Σ.v∞.1.webkasse.core

import { generateUID } from '../utils.js';

let webkasse = {
    kontostand: 0,
    buchungen: [] // { id, betrag, von, zweck, zeitpunkt, quelle }
};

// Buchungstypen: spende, zusage, auszahlung, umbuchung, goldfaden

export function aktuelleWebkasse() {
    return {
        kontostand: webkasse.kontostand,
        buchungen: [...webkasse.buchungen]
    };
}

export function fuegeBuchungHinzu({ betrag, von, zweck, quelle = 'unbekannt' }) {
    const buchung = {
        id: generateUID(),
        betrag,
        von,
        zweck,
        quelle,
        zeitpunkt: new Date().toISOString()
    };
    webkasse.buchungen.push(buchung);
    webkasse.kontostand += betrag;
    return buchung;
}

export function macheAuszahlung({ betrag, an, zweck = 'auszahlung' }) {
    if (webkasse.kontostand >= betrag) {
        return fuegeBuchungHinzu({ betrag: -betrag, von: 'webkasse', zweck, quelle: 'auszahlung:' + an });
    } else {
        throw new Error("Nicht genügend Mittel in der Webkasse");
    }
}

export function filtereBuchungen(filterFn) {
    return webkasse.buchungen.filter(filterFn);
}

export function resetWebkasse() {
    webkasse = {
        kontostand: 0,
        buchungen: []
    };
}

// --- Datei: Launchweb/data/data-diskurs.js ---

// data/data-diskurs.js — Version: Σ.v2.diskursstruktur.raumgestützt

export const diskursData = {
    räume: [], // Jeder Raum: { id, typ, referenzId, gespräche: [ { id, beitrag, typ, autor, zeit } ] }

    addRaum(raum) {
        this.räume.push(raum);
    },

    findRaum(id) {
        return this.räume.find(r => r.id === id);
    },

    addGespräch(raumId, gespräch) {
        const raum = this.findRaum(raumId);
        if (raum) {
            raum.gespräche.push(gespräch);
        }
    },

    getGespräche(raumId) {
        const raum = this.findRaum(raumId);
        return raum ? raum.gespräche : [];
    },

    getGesprächeMitTyp(raumId, typ) {
        const raum = this.findRaum(raumId);
        return raum ? raum.gespräche.filter(g => g.typ === typ) : [];
    },

    deleteGespräch(raumId, gesprächId) {
        const raum = this.findRaum(raumId);
        if (raum) {
            raum.gespräche = raum.gespräche.filter(g => g.id !== gesprächId);
        }
    },

    deleteRaum(id) {
        this.räume = this.räume.filter(r => r.id !== id);
    },

    getAlleRäume() {
        return this.räume;
    }
};

// --- Datei: Launchweb/data/persistence-services.client.js ---

// persistence-service.client.js — Version: Σ.client.localStorage

export const PersistenceClient = {
    loadAll(key) {
        const raw = localStorage.getItem(key);
        return raw ? JSON.parse(raw) : [];
    },

    save(key, data) {
        localStorage.setItem(key, JSON.stringify(data));
    },

    store(key, entry) {
        const data = this.loadAll(key);
        data.push(entry);
        this.save(key, data);
    },

    delete(key, id) {
        const data = this.loadAll(key).filter(e => e.id !== id);
        this.save(key, data);
    },

    clear(key) {
        localStorage.removeItem(key);
    }
};

// --- Datei: Launchweb/data/data-knoten.js ---

// data/data-knoten.js — Version: Σ.v∞.1.knotenstruktur.core

import { generateUID } from '../utils.js';

const knotenStore = [];

export function createKnoten({ titel, beschreibung, koordinaten, erstellerId, zeitpunkt = null, typ = 'allgemein' }) {
    const neuerKnoten = {
        id: generateUID(),
        titel,
        beschreibung,
        koordinaten,
        erstellerId,
        zeitpunkt,
        typ,
        erstelltAm: new Date().toISOString(),
        verbunden: [],
        aktiv: true
    };
    knotenStore.push(neuerKnoten);
    return neuerKnoten;
}

export function getAlleKnoten() {
    return knotenStore.filter(k => k.aktiv);
}

export function findeKnotenNachId(knotenId) {
    return knotenStore.find(k => k.id === knotenId && k.aktiv);
}

export function verknuepfeMitKnoten(knotenId, webungId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten && !knoten.verbunden.includes(webungId)) {
        knoten.verbunden.push(webungId);
    }
}

export function entferneVerknuepfung(knotenId, webungId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten) {
        knoten.verbunden = knoten.verbunden.filter(id => id !== webungId);
        if (knoten.verbunden.length === 0) {
            knoten.aktiv = false;
        }
    }
}

export function loescheKnoten(knotenId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten) {
        knoten.aktiv = false;
    }
}

// --- Datei: Launchweb/data/persistence-services.js ---

// persistence-service.js — Version: Σ.v2.contextaware

let speicher;

if (typeof window !== 'undefined' && window.localStorage) {
    // Client-basiert
    import('./persistence-service.client.js').then(mod => {
        speicher = mod.Speicher;
    });
} else {
    // Server-basiert (Node.js)
    import('./persistence-service.server.js').then(mod => {
        speicher = mod.Speicher;
    });
}

// Async-Wartefunktion, bis das Modul geladen ist
async function bereitstellen() {
    if (!speicher) {
        await new Promise(resolve => setTimeout(resolve, 10)); // minimal warten
        return bereitstellen(); // rekursiv warten
    }
    return speicher;
}

// Exporte als Proxy-Funktionen
export const Speicher = {
    async ladeAlle(name) {
        const s = await bereitstellen();
        return s.ladeAlle(name);
    },

    async schreibe(name, daten) {
        const s = await bereitstellen();
        return s.schreibe(name, daten);
    },

    async speichere(name, eintrag) {
        const s = await bereitstellen();
        return s.speichere(name, eintrag);
    },

    async loesche(name, id) {
        const s = await bereitstellen();
        return s.loesche(name, id);
    }
};

// --- Datei: Launchweb/services/api-knoten.js ---

// api-knoten.js — Version: Σ.v1.knotenservice

import { Knotenerkennung } from '../core/knotenerkennung.js';
import { Speicher } from './persistence-service.js';

export const apiKnoten = {
    async erstelleKnoten(daten) {
        const knoten = Knotenerkennung.erstelleKnoten(daten);
        await Speicher.speichere('knoten', knoten);
        return knoten;
    },

    async pruefeUndLoescheVerwaiste() {
        const knotenListe = await Speicher.ladeAlle('knoten');
        const webungen = await Speicher.ladeAlle('webung');

        const geloeschte = [];

        for (const k of knotenListe) {
            if (Knotenerkennung.loescheWennVerwaist(k, webungen)) {
                await Speicher.loesche('knoten', k.id);
                geloeschte.push(k.id);
            }
        }

        return geloeschte;
    }
};

// --- Datei: Launchweb/services/api-verblassen.js ---

// api-verblassen.js — Version: Σ.v1.verblass-service

import { Verblasslogik } from '../core/verblasslogik.js';
import { Speicher } from './persistence-service.js';

export const apiVerblassen = {
    async verblasseAlle() {
        const webungen = await Speicher.ladeAlle('webung');
        const knotenListe = await Speicher.ladeAlle('knoten');

        for (const w of webungen) {
            const knoten = knotenListe.find(k => k.id === w.zuKnotenId);
            Verblasslogik.setzeVerblasstStatus(w, knoten?.ereigniszeitpunkt);
        }

        await Speicher.schreibe('webung', webungen);
    }
};

// --- Datei: Launchweb/services/api-webung.js ---

// api-webung.js — Version: Σ.v1.api

import express from 'express';
import { WebungsEngine } from './webungsengine.js';
import { persistenceService } from './persistence-service.js';

export const webungApi = express.Router();

webungApi.post('/webung', async (req, res) => {
    try {
        const newWebung = await WebungsEngine.neueWebung(req.body);
        res.status(201).json(newWebung);
    } catch (err) {
        res.status(400).json({ error: err.message });
    }
});

webungApi.get('/webungen', async (req, res) => {
    const webungen = await persistenceService.getAll('webungen');
    res.json(webungen);
});

// --- Datei: Launchweb/services/auth-service.js ---

// services/auth-service.js — v1

let eingeloggterWeber = null;

export const AuthService = {
    login(userId, name, wohnort) {
        eingeloggterWeber = { id: userId, name, wohnort };
    },
    logout() {
        eingeloggterWeber = null;
    },
    getUser() {
        return eingeloggterWeber;
    },
    isLoggedIn() {
        return !!eingeloggterWeber;
    }
};

// --- Datei: Launchweb/services/websocket-service.js ---

// services/websocket-service.js — v1

class WebSocketService {
    constructor(url) {
        this.url = url;
        this.socket = null;
        this.listeners = new Set();
    }

    connect() {
        if (this.socket) return;

        this.socket = new WebSocket(this.url);

        this.socket.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            this.listeners.forEach(fn => fn(msg));
        };

        this.socket.onopen = () => {
            console.log('WebSocket verbunden');
        };

        this.socket.onclose = () => {
            this.socket = null;
            setTimeout(() => this.connect(), 1000);
        };

        this.socket.onerror = () => {
            this.socket?.close();
        };
    }

    send(msg) {
        if (this.socket?.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify(msg));
        }
    }

    subscribe(fn) {
        this.listeners.add(fn);
    }
}

export const WebSocketServiceInstance = new WebSocketService('ws://localhost:8080');

// --- Datei: Launchweb/services/api-antrag.js ---

// api-antrag.js — Version: Σ.v1.antrag-service

import { Antragslogik } from '../core/antragslogik.js';
import { Speicher } from './persistence-service.js';

export const apiAntrag = {
    async pruefeAlleAntraege() {
        const antraege = await Speicher.ladeAlle('antrag');

        for (const a of antraege) {
            Antragslogik.pruefeEntscheidung(a, a.einspruchsDatum);
        }

        await Speicher.schreibe('antrag', antraege);
    },

    async stelleAntrag(antrag) {
        Antragslogik.initialisiereAntrag(antrag);
        if (antrag.kategorie === 'gold') {
            Antragslogik.kennzeichneGoldantrag(antrag);
        }

        await Speicher.speichere('antrag', antrag);
        return antrag;
    },

    async markiereEinspruch(antragId) {
        const antraege = await Speicher.ladeAlle('antrag');
        const antrag = antraege.find(a => a.id === antragId);
        if (antrag) {
            Antragslogik.markiereEinspruch(antrag);
            antrag.einspruchsDatum = new Date().toISOString();
        }
        await Speicher.schreibe('antrag', antraege);
    }
};

// --- Datei: Launchweb/services/websocket-integration.js ---

// websocket-integration.js — Version: Σ.v1.0.webung.sync.full

import { websocketService } from './websocket-service.js';
import { loadInitialData } from './startup-loader.js';
import { renderVisuals } from './leaflet-setup.js';

export class WebsocketIntegration {
    constructor(map) {
        this.map = map;
        websocketService.registerMessageHandler(this.handleMessage.bind(this));
        websocketService.connect();
    }

    async handleMessage(msg) {
        const { type } = msg;

        if (['webung_created', 'knoten_created', 'antrag_started', 'einspruch', 'abstimmung'].includes(type)) {
            const freshData = await loadInitialData();
            renderVisuals(this.map, freshData);
        } else if (type === 'ping') {
            // optional: heartbeat received
        } else {
            console.warn('WebsocketIntegration: Unbekannter Nachrichtentyp', type);
        }
    }
}

// --- Datei: Launchweb/services/file-storage.js ---

// services/file-storage.js — v1

import fs from 'fs/promises';
import path from 'path';

export const FileStorage = {
    baseDir: './weltweberei-data',

    async ensureDir() {
        await fs.mkdir(this.baseDir, { recursive: true });
    },

    async read(file) {
        const full = path.join(this.baseDir, file);
        try {
            const content = await fs.readFile(full, 'utf-8');
            return JSON.parse(content);
        } catch (err) {
            if (err.code === 'ENOENT') return [];
            throw err;
        }
    },

    async write(file, data) {
        await this.ensureDir();
        const full = path.join(this.baseDir, file);
        await fs.writeFile(full, JSON.stringify(data, null, 2));
    }
};

// --- Datei: __MACOSX/Launchweb/._index.html ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._system-meta.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._merged-weltweb.txt ---

// Fehler: 'utf-8' codec can't decode byte 0xb0 in position 45: invalid start byte


// --- Datei: __MACOSX/Launchweb/._weltweb.txt ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._startup-loader.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._layer-manager.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._leaflet-setup.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._strukturbaum.txt ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._init-events.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._style.css ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._engine-events.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._main.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-login.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-ereignis.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-interactions.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-finanz.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-themenfilter.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-core.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._ui-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._knoten-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._knoten-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._antrag-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._ui-antrag.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._render-antraege.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._antrag-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._diskurs-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._ui-diskurs.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._diskurs-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/layer/._ui-layer-advanced.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/layer/._ui-layer-toggle.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-naehstuebchen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-zeitreise.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-webrat.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._zeitleiste.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._webung-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._antragszyklus.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._verblasslogik.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._zeitlogik.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._manifest.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._knotenerkennung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._form-components.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utility-core.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._validation.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utility-tooltip.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utils.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._user-model.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._knotentypen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._webung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-base.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-antraege.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-faeden.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._colors.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-fadenlegende.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-garne.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-webkasse.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-finanz.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-model.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.client.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.server.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-diskurs.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._websocket-service.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-verblassen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._websocket-integration.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-antrag.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._file-storage.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._auth-service.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-webung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: Launchweb/layer-manager.js ---

// layer-manager.js — Version: Σ.v3.singleton-final

class LayerManager {
  constructor(map = null) {
    if (LayerManager._instance) return LayerManager._instance;
    this.map = map;
    this.data = {};
    this.layerStates = new Map();
    this.renderCallbacks = new Map();
    LayerManager._instance = this;
  }

  static getInstance() {
    if (!LayerManager._instance) {
      LayerManager._instance = new LayerManager();
    }
    return LayerManager._instance;
  }

  updateData(daten) {
    this.data = daten;
  }

  getData() {
    return this.data;
  }

  registerLayer(name, renderFn) {
    this.layerStates.set(name, true);
    this.renderCallbacks.set(name, renderFn);
  }

  renderActiveLayers(selection, projection) {
    for (const [name, isActive] of this.layerStates.entries()) {
      if (isActive) {
        const renderFn = this.renderCallbacks.get(name);
        if (renderFn) {
          const layerData = this.data[name] || [];
          renderFn(selection, projection, layerData);
        }
      }
    }
  }
}

export const layerManager = LayerManager.getInstance();

// --- Datei: Launchweb/leaflet-setup.js ---

import { layerManager } from './layer-manager.js';

export function setupLeafletMap(lat, lng, zoom) {
  const map = L.map('map').setView([lat, lng], zoom);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);

  const daten = layerManager.getData();
  console.log('🧪 LayerManager Daten in leaflet:', daten);

  if (daten?.knoten?.length) {
    daten.knoten.forEach(k => {
      if (k.lat && k.lng) {
        L.marker([k.lat, k.lng]).addTo(map).bindPopup(k.name || 'Knoten');
      }
    });
  }

  return map;
}

// --- Datei: Launchweb/style.css ---

/* style.css — Version: Σ.v1.0.webstruktur */

html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: system-ui, sans-serif;
    background-color: #fdfaf6;
}

#map {
    height: 100%;
    width: 100%;
}

.overlay {
    position: absolute;
    top: 10%;
    left: 10%;
    width: 80%;
    max-height: 80%;
    background: white;
    border: 2px solid #ccc;
    border-radius: 8px;
    padding: 1em;
    box-shadow: 0 0 10px rgba(0,0,0,0.2);
    overflow-y: auto;
    z-index: 1000;
}

.overlay.hidden {
    display: none;
}

.info-panel {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background: rgba(255,255,255,0.95);
    padding: 1em;
    border-top: 2px solid #ccc;
    display: none;
    z-index: 900;
}

.info-panel.visible {
    display: block;
}

#ui-controls {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 1100;
}

#ui-controls button {
    padding: 0.5em 1em;
    font-size: 1em;
    border-radius: 4px;
    border: none;
    background-color: #333;
    color: white;
    cursor: pointer;
    transition: background 0.2s;
}

#ui-controls button:hover {
    background-color: #555;
}

/* Tooltip-Styling (für utility-tooltip.js) */
.tooltip {
    position: absolute;
    background: #fff;
    padding: 0.5em 0.8em;
    border-radius: 4px;
    border: 1px solid #ccc;
    font-size: 0.9em;
    pointer-events: none;
    box-shadow: 0 0 5px rgba(0,0,0,0.1);
    z-index: 2000;
}

/* Farben aus visual/colors.js könnten per Klasse nachgeladen werden */

.layer-controls {
    position: absolute;
    top: 1em;
    right: 1em;
    background: rgba(255, 255, 255, 0.8);
    padding: 0.5em;
    border-radius: 5px;
    font-size: 0.9em;
}

.layer-toggle-label {
    display: block;
    margin: 0.2em 0;
}

// --- Datei: Launchweb/weltweb.txt ---



⸻

Manifest der Weltweberei


⸻

🧶 Webung

Webung bezeichnet jede Handlung, mit der ein Weber über seine Rolle in die Welt eingreift.
	•	Die Rolle ist visuell verankert an einem festen Ort auf der Leaflet-Karte, identifiziert über eine ID bei Registrierung.
	•	Eine Webung erzeugt eine Verbindung von der Rolle zu einem beliebigen Punkt auf der Karte – entweder:
	•	als Faden: temporär (verblasst innerhalb von 7 Tagen)
	•	als Garn: dauerhaft (bis zur aktiven Auflösung)

Eine Webung entsteht z. B. durch:
	•	Erstellen eines Knotens (Informationspunkt mit Kontext)
	•	Teilnahme an einem Gespräch
	•	Stellung eines Antrags
	•	Abgabe einer Zusage

	der Weber entscheidet selbst, ob er Faden oder Garn benutzt. Garn gilt als verbindliche Zusage.
	auch im Nachhinein kann ein Weber seine Rolle mit einem Knoten verbinden, wenn er beispielsweise physisch an einem Ereignis zugegen war und seine Mitwirkung nun dokumentieren möchte
⸻

🪢 Knoten

Ein Knoten entsteht, wenn ein Weber eine neue Webung mit Informationsinhalt an einem Ort auf der Karte vornimmt.
	•	Der Knoten ist Träger:
	•	von Informationen (z. B. Ankündigungen, Hinweise)
	•	von Gesprächsmöglichkeiten (Diskurs)
	•	von Anträgen (siehe unten)
	•	Weitere Webungen anderer Weber verknüpfen sich automatisch mit dem Knoten.
	•	Ein Knoten löst sich auf, wenn kein Faden und kein Garn mehr mit ihm verbunden ist.

Darstellung:
	•	Standardmäßig als visueller Knoten dargestellt
	•	Material: abgeleitet aus den verbundenen Fäden und Garne
	•	Visualisierung kann vom ursprünglichen Weber selbst angepasst werden

⸻

🧭 Webkasse

Die Webkasse ist das Gemeinschaftskonto der Ortsweberei.
Sie ist der exklusive Ort für Geldauszahlungsanträge.

⸻

🧾 Anträge
	•	Können gestellt werden auf:
	•	Geldauszahlung (→ nur über Knotenknüpfung auf Webkasse, heißen Goldantrag und sind mit goldenem Rand versehen)
	•	Veränderung
	•	Anschaffung
	•	alles mögliche

Visualisierung:
	•	Blauer Faden bei Stellung
	•	Lila Faden bei Einspruch (binnen 7 Tagen möglich)
	•	Grüner Faden bei Annahme
– automatisch 7 Tage nach Antragstellung (ohne Einspruch)
– bei Einspruch: Abstimmung 7 Tage nach Einspruch
	•	Roter Faden bei Ablehnung
	•	Goldener Rand bei Goldanträgen
	•	Jeder Antragsfaden verblasst 7 Tage nach Entscheidung

⸻

🧵 Extraräume
	•	Nähstübchen → Raum zum freien Plaudern
	•	Webrat → Diskussionen zu orts- und ereignisunabhängigen Themen

⸻

🗓️ Zeitleiste / Auditfunktion
	•	Navigierbare Zeitleiste, um vergangene Webungen auditierbar zu halten
	•	Zeitreise: Tag-für-Tag, einstellbare Geschwindigkeit
	•	Statische Zeitfenster: frei wählbare Intervalle (z. B. 1 Woche, 1 Monat etc.)

⸻

📱 Mobile first!

Alle Funktionalitäten und Interfaces sind von Grund auf für mobile Nutzung optimiert.


Wenn ein Weber an einem Gespräch teilnimmt, dann webt sich automatisch ein Faden von seiner Rolle in den Gesprächsraum. Solch ein Faden verschwindet ja sukzessive wieder innerhalb einer Woche. Wenn ein Weber dann aber in diesem Zeitraum weitere Beiträge in demselben Knoten tätigt, dann wird der Faden dicker (immer proportional zu der zeitlich überlappenden Anzahl der Beiträge. Dabei ist jeder Faden (zumindest anteilig) visuell vertreten (mit seiner jeweiligen Farbe und Transparenz))
Garn wiederum steht ja für verbindliche Zusagen und bleibt als stabile Verbindung zwischen Rolle und knoten, bis entweder der knoten Aufgelöst wird oder die Zusage abgebrochen wird. Garn erkennt man an der gezwirnten Optik (oder welche Optik Garn auch immer hat). Ist ein Ereignis vergangen (und hat sich also die Zusage in Tat umgewandelt) wird der knoten und die zu ihm führenden Fäden und Garne grau und verschwindet im laufe einer Woche sukzessive.

weltweberei/
├── index.html                    → Einstiegspunkt (Leaflet + UI-Struktur)
├── style.css                    → Grundlayout, farblich Weberei-konform
├── main.js                      → App-Starter: Kartenaufbau + Datenbindung
├── startup-loader.js            → Initialdaten, UI-Init, Layer-Setup
├── leaflet-setup.js             → Karte + Zeitachse + Keyevents

├── core/
    --- webung-engine.js
│   ├── zeitlogik.js             → Blasszeiten, Garnhaltbarkeit, Zeitreise
│   ├── knotenerkennung.js       → Logik zur Auflösung und Persistenzprüfung
│   ├── verblasslogik.js         → Fadenverblassung etc.
│   └── manifest.js              → Manifest-Logik (aus `weltweb.txt`)

├── data/
│   ├── data-model.js            → Datenstrukturen: Knoten, Fäden, Garne
│   ├── data-knoten.js           → Knoten-spezifische Datenhaltung
│   ├── data-diskurs.js          → Diskursdaten: Gespräche, Beiträge, etc.
│   ├── data-finanz.js           → Webkassen-Datenhaltung
│   └── persistence-service.js (+.client, +.server)  → Datei-/Serverpersistenz (Filesystem/Backend)

├── services/
│   ├── api-service.js           → Generische API-Schicht
│   ├── api-diskurs.js           → Gesprächs-API
│   ├── api-knoten.js            → Knotendaten-API
│   ├── websocket-service.js     → Live-Daten
│   ├── websocket-integration.js → Events live synchronisieren
│   ├── auth-service.js          → Anmeldung & Rollenverknüpfung
│   └── file-storage.js          → Lokale Dateioperationen├── api-antrag.js           → API für Anträge
│   ├── api-verblassen.js       → API für Verblasslogik
│   ├── api-webung.js           → API für allgemeine Webungen

├── visual/
│   ├── render-knoten.js             → Visualisierung der Knoten
│   ├── render-faeden.js             → Darstellung aller Fäden
│   ├── render-garne.js              → Darstellung aller Garne
│   ├── render-antraege.js             → Darstellung Antragszyklen
│   ├── render-webkasse.js           → Darstellung Webkasse
│   └── colors.js                → Farbsemantik & Symbolfarben

├── ui/
│   ├── ui-core.js               → Grundinteraktionen & UI-Logik
│   ├── ui-interactions.js       → Buttons, Events, UI-Flows
│   ├── ui-themenfilter.js       → Filter für Knotentypen
│   ├── ui-login.js              → Loginmaske + Identifikation
│   ├── ui-ereignis.js           → Knoteninteraktionen
│   ├── ui-finanz.js             → Webkasseninterface

│   ├── knoten/
│   │   ├── ui-knoten.js         → Knotendarstellung (Info + Visu)
│   │   ├── knoten-engine.js     → Knotenanlage, Logik
│   │   └── knoten-form.js       → Formular zur Knotenerstellung

│   ├── diskurs/
│   │   ├── ui-diskurs.js        → Gesprächsfenster
│   │   ├── diskurs-engine.js    → Diskursverlauf + Webungslogik
│   │   └── diskurs-form.js      → Beiträge hinzufügen, Antrag starten

│   ├── antrag/
│   │   ├── ui-antrag.js         → Antrag-UI
│   │   ├── antrag-engine.js     → Zyklus-Logik
│   │   └── antrag-form.js       → Antragsformular

│   └── extras/
│       ├── ui-zeitreise.js      → Zeitleistensteuerung
│       ├── ui-webrat.js         → Ortunabhängige Debatte
│       ├── ui-naehstuebchen.js  → Plauderbereich
│       └── zeitleiste.js        → Visualisierung vergangener Webungen

├── utils/
│   ├── utility-core.js          → Allg. Hilfsfunktionen
│   ├── utility-tooltip.js       → Tooltip-System
│   ├── form-components.js       → Felder, Dropdowns etc.
│   ├── validation.js            → Formprüfungen
│   └── utils.js                 → Alles sonstige

└── models/
    ├── user-model.js            → Rollenstruktur, Fadenverhalten
    └── knotentypen.js           → Definition & Farben aller Knotentypen

// --- Datei: Launchweb/ui/ui-ereignis.js ---

// ui-ereignis.js — Interaktion mit einzelnen Knotenpunkten

import { showKnotenInfo } from './knoten/ui-knoten.js';

export function setupEreignisInteraktion() {
    document.addEventListener('click', (e) => {
        const target = e.target.closest('.knotenpunkt');
        if (target) {
            const knotenId = target.dataset.knotenId;
            if (knotenId) {
                showKnotenInfo(knotenId);
            }
        }
    });
}

// --- Datei: Launchweb/ui/ui-interactions.js ---

// ui-interactions.js — Steuerung von Buttons und UI-Aktionen

export function setupUIInteractions() {
    const knotenButton = document.getElementById('neuer-knoten');
    const zeitreiseButton = document.getElementById('zeitreise-button');
	
	document.getElementById('toggle-faeden').addEventListener('click', () => {
    layerManager.toggleLayer('faeden');
    svgLayer.requestRender();
});

    if (knotenButton) {
        knotenButton.addEventListener('click', () => {
            alert('Knotenerstellung folgt.');
        });
    }

    if (zeitreiseButton) {
        zeitreiseButton.addEventListener('click', () => {
            alert('Zeitleiste wird aktiviert.');
        });
    }
}

// --- Datei: Launchweb/ui/ui-finanz.js ---

// ui-finanz.js — Webkassenanzeige & Interaktion

export function renderWebkasse(data) {
    const container = document.getElementById('webkasse-container');
    if (!container) return;

    const eintraege = data.map(eintrag => `
        <div class="buchung">
            <span class="betrag">${eintrag.betrag.toFixed(2)}€</span>
            <span class="zweck">${eintrag.zweck}</span>
            <span class="datum">${eintrag.datum}</span>
        </div>
    `).join('');

    container.innerHTML = `
        <h3>Webkasse</h3>
        <div class="eintraege">${eintraege}</div>
    `;
}

// --- Datei: Launchweb/ui/ui-themenfilter.js ---

// ui-themenfilter.js — Filterung nach Knotentypen (Farben, Kategorien)

export function initializeThemenfilter() {
    const filterElement = document.getElementById('themenfilter');

    if (!filterElement) return;

    filterElement.addEventListener('change', () => {
        const selected = filterElement.value;
        const event = new CustomEvent('filterChange', { detail: { selected } });
        window.dispatchEvent(event);
    });
}

// --- Datei: Launchweb/ui/ui-core.js ---

// ui-core.js — Version: uiΣ.v1.0.basismodul

export function initializeUICore() {
    const overlay = document.getElementById('webungs-overlay');
    const infoPanel = document.getElementById('knoten-info');

    function showOverlay(contentHtml) {
        overlay.innerHTML = contentHtml;
        overlay.classList.remove('hidden');
    }

    function hideOverlay() {
        overlay.classList.add('hidden');
        overlay.innerHTML = '';
    }

    function showInfo(contentHtml) {
        infoPanel.innerHTML = contentHtml;
        infoPanel.classList.remove('hidden');
    }

    function hideInfo() {
        infoPanel.classList.add('hidden');
        infoPanel.innerHTML = '';
    }

    function toggleOverlay(contentHtml) {
        if (overlay.classList.contains('hidden')) {
            showOverlay(contentHtml);
        } else {
            hideOverlay();
        }
    }

    function toggleInfo(contentHtml) {
        if (infoPanel.classList.contains('hidden')) {
            showInfo(contentHtml);
        } else {
            hideInfo();
        }
    }

    return {
        showOverlay,
        hideOverlay,
        showInfo,
        hideInfo,
        toggleOverlay,
        toggleInfo
    };
}

// --- Datei: Launchweb/ui/ui-login.js ---

// ui-login.js — Version: Σ.v1.auth.ui

import { rolleService } from '../models/user-model.js';

export function setupLoginUI() {
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('login-name');

    loginForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const name = nameInput.value.trim();
        if (name) {
            rolleService.login(name);
            document.getElementById('login-panel').style.display = 'none';
        }
    });

    if (rolleService.isLoggedIn()) {
        document.getElementById('login-panel').style.display = 'none';
    }
}

// --- Datei: Launchweb/ui/knoten/knoten-engine.js ---

// knoten-engine.js — Logik zum Erstellen und Speichern neuer Knoten

import { speichereKnoten } from '../../data/data-knoten.js';

export async function erstelleKnoten(knotenDaten) {
    const neuerKnoten = {
        id: Date.now().toString(),
        ...knotenDaten
    };

    await speichereKnoten(neuerKnoten);
    alert('Knoten erfolgreich erstellt.');
}

// --- Datei: Launchweb/ui/knoten/ui-knoten.js ---

// ui-knoten.js — Anzeige eines Knotens + Optionen

import { getKnotenById } from '../../data/data-knoten.js';

export function showKnotenInfo(knotenId) {
    const knoten = getKnotenById(knotenId);
    if (!knoten) return;

    const info = `
        <h2>${knoten.titel}</h2>
        <p>${knoten.beschreibung}</p>
        <button id="beitreten-btn">Beitreten</button>
    `;

    window.showInfoPanel(info);

    const btn = document.getElementById('beitreten-btn');
    if (btn) {
        btn.addEventListener('click', () => {
            alert('Webung mit diesem Knoten folgt.');
        });
    }
}

// --- Datei: Launchweb/ui/knoten/knoten-form.js ---

// knoten-form.js — Formular zur Knotenerstellung

import { erstelleKnoten } from './knoten-engine.js';

export function initKnotenForm() {
    const form = document.getElementById('knoten-form');
    if (!form) return;

    form.addEventListener('submit', async (e) => {
        e.preventDefault();

        const titel = form.querySelector('#titel').value;
        const beschreibung = form.querySelector('#beschreibung').value;

        await erstelleKnoten({ titel, beschreibung });
        form.reset();
    });
}

// --- Datei: Launchweb/ui/antrag/antrag-form.js ---

// antrag-form.js — v1

import { AntragEngine } from './antrag-engine.js';
import { generateId, todayISO } from '../../utils/utility-core.js';

export function erstelleAntragsformular(knotenId) {
    const form = document.createElement('form');
    form.innerHTML = `
        <h3>Neuer Antrag</h3>
        <label>Typ:
            <select name="typ">
                <option value="anschaffung">Anschaffung</option>
                <option value="veraenderung">Veränderung</option>
                <option value="goldantrag">Goldantrag</option>
            </select>
        </label>
        <label>Beschreibung:
            <textarea name="beschreibung" required></textarea>
        </label>
        <button type="submit">Antrag stellen</button>
    `;

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = new FormData(form);
        const neuerAntrag = {
            id: generateId(),
            typ: formData.get('typ'),
            beschreibung: formData.get('beschreibung'),
            knotenId,
            status: 'gestellt',
            gestelltAm: todayISO()
        };
        await AntragEngine.speichere(neuerAntrag);
        alert('Antrag gestellt.');
    });

    return form;
}

// --- Datei: Launchweb/ui/antrag/render-antraege.js ---

// render-antraege.js — v1

import { getFarbeFürAntrag } from './colors.js';

export function renderAntragsfaden(antrag) {
    const farbe = getFarbeFürAntrag(antrag);
    const faden = L.polyline([antrag.start, antrag.ziel], {
        color: farbe,
        weight: 3,
        className: antrag.typ === 'goldantrag' ? 'goldrand' : ''
    });
    faden.addTo(window.map); // globale Referenz
}

// --- Datei: Launchweb/ui/antrag/antrag-engine.js ---

// antrag-engine.js — v1

import { Speicher } from '../../data/persistence-service.js';
import { differenceInDays, parseISO } from 'date-fns';

export const AntragEngine = {
    async finde(id) {
        const alle = await Speicher.ladeAlle('antraege');
        return alle.find(a => a.id === id);
    },

    async speichere(antrag) {
        await Speicher.speichere('antraege', antrag);
    },

    async aktualisiereStatus() {
        const antraege = await Speicher.ladeAlle('antraege');
        const heute = new Date();

        for (let a of antraege) {
            const gestellt = parseISO(a.gestelltAm);
            if (a.status === 'gestellt') {
                if (differenceInDays(heute, gestellt) >= 7) {
                    a.status = 'angenommen';
                }
            } else if (a.status === 'einspruch') {
                const einspruch = parseISO(a.einspruchAm);
                if (differenceInDays(heute, einspruch) >= 7) {
                    a.status = 'abgelehnt';
                }
            }
        }

        await Speicher.schreibe('antraege', antraege);
    },

    async einspruchEinlegen(id) {
        const antraege = await Speicher.ladeAlle('antraege');
        const a = antraege.find(e => e.id === id);
        if (a && a.status === 'gestellt') {
            a.status = 'einspruch';
            a.einspruchAm = new Date().toISOString();
        }
        await Speicher.schreibe('antraege', antraege);
    }
};

// --- Datei: Launchweb/ui/antrag/ui-antrag.js ---

// ui-antrag.js — v1

import { AntragEngine } from './antrag-engine.js';
import { renderAntragsfaden } from '../../visual/render-antraege.js';

export function setupAntragUI() {
    document.addEventListener('click', async (e) => {
        if (e.target.matches('[data-antrag-id]')) {
            const id = e.target.dataset.antragId;
            const antrag = await AntragEngine.finde(id);
            if (antrag) {
                renderAntragsfaden(antrag);
            }
        }
    });
}

// --- Datei: Launchweb/ui/diskurs/diskurs-engine.js ---

// diskurs-engine.js — Logik zur Beitragserstellung und Fadenverknüpfung

import { speichereBeitrag } from '../../data/data-diskurs.js';
import { verknuepfeFaden } from '../../core/verblasslogik.js';

export async function hinzufuegenBeitrag(knotenId, autor, text) {
    const beitrag = {
        id: Date.now().toString(),
        knotenId,
        autor,
        text,
        zeitpunkt: new Date().toISOString()
    };

    await speichereBeitrag(beitrag);
    await verknuepfeFaden(autor, knotenId, 'beitrag');
}

// --- Datei: Launchweb/ui/diskurs/diskurs-form.js ---

// diskurs-form.js — Formular zur Erstellung eines Diskursbeitrags

import { hinzufuegenBeitrag } from './diskurs-engine.js';

export function startBeitragFormular(knotenId) {
    const html = `
        <form id="diskurs-eingabe">
            <input type="text" id="autor" placeholder="Dein Name" required />
            <textarea id="text" placeholder="Dein Beitrag" required></textarea>
            <button type="submit">Absenden</button>
        </form>
    `;

    const ziel = document.getElementById('diskurs-formular');
    if (ziel) ziel.innerHTML = html;

    const form = document.getElementById('diskurs-eingabe');
    if (form) {
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const autor = form.querySelector('#autor').value;
            const text = form.querySelector('#text').value;
            await hinzufuegenBeitrag(knotenId, autor, text);
            form.reset();
        });
    }
}

// --- Datei: Launchweb/ui/diskurs/ui-diskurs.js ---

// ui-diskurs.js — Anzeige des Gesprächsverlaufs innerhalb eines Knotens

import { getBeitraegeFuerKnoten } from '../../data/data-diskurs.js';
import { startBeitragFormular } from './diskurs-form.js';

export function zeigeDiskurs(knotenId) {
    const beitraege = getBeitraegeFuerKnoten(knotenId);

    const html = `
        <div class="diskurs-header">
            <h3>Gespräch zum Knoten</h3>
            <button id="beitrag-hinzufuegen">Beitrag verfassen</button>
        </div>
        <ul class="diskurs-liste">
            ${beitraege.map(b => `<li><strong>${b.autor}:</strong> ${b.text}</li>`).join('')}
        </ul>
        <div id="diskurs-formular"></div>
    `;

    const container = document.getElementById('diskurs-container');
    if (container) container.innerHTML = html;

    document.getElementById('beitrag-hinzufuegen')?.addEventListener('click', () => {
        startBeitragFormular(knotenId);
    });
}

// --- Datei: Launchweb/ui/layer/ui-layer-toggle.js ---

// ui-layer-toggle.js — Version: Σ.v1.layer.ui.toggle

export function setupLayerToggle(layerManager) {
    const container = document.getElementById('layer-controls');
    if (!container) return;

    const layerLabels = {
        knoten: 'Knoten',
        faeden: 'Fäden',
        garne: 'Garne',
        antraege: 'Anträge',
        webkasse: 'Webkasse'
    };

    Object.keys(layerLabels).forEach(layerKey => {
        const label = document.createElement('label');
        label.classList.add('layer-toggle-label');

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = layerManager.isLayerVisible(layerKey);
        checkbox.addEventListener('change', () => {
            layerManager.setLayerVisibility(layerKey, checkbox.checked);
        });

        label.appendChild(checkbox);
        label.append(` ${layerLabels[layerKey]}`);
        container.appendChild(label);
    });
}

// --- Datei: Launchweb/ui/layer/ui-layer-advanced.js ---

// ui-layer-advanced.js — Version: Σ.v1.adapted-to-toggle

export function setupLayerControls(layerManager) {
    const controlContainer = document.getElementById('layer-controls');
    if (!controlContainer) return;

    const layerNames = layerManager.getLayerNames();

    layerNames.forEach(layerName => {
        const label = document.createElement('label');
        label.textContent = ` ${layerName}`;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = layerManager.isLayerActive(layerName);

        checkbox.addEventListener('change', () => {
            layerManager.toggleLayer(layerName);
            // optional: trigger Map-Neurender
        });

        label.prepend(checkbox);
        controlContainer.appendChild(label);
    });
}

// --- Datei: Launchweb/ui/extras/ui-naehstuebchen.js ---

// ui-naehstuebchen.js — v1

import { diskursEngine } from '../diskurs/diskurs-engine.js';
import { uiDiskursFenster } from '../diskurs/ui-diskurs.js';

export function öffneNaehstuebchen() {
    const fenster = uiDiskursFenster.erzeuge('naehstuebchen');
    diskursEngine.öffneRaum('naehstuebchen', fenster);
}

// --- Datei: Launchweb/ui/extras/zeitleiste.js ---

// zeitleiste.js — v1

import { renderKnoten } from '../../visual/render-knoten.js';
import { renderFaeden } from '../../visual/render-faeden.js';

export const zeitleiste = {
    alleDaten: [],
    aktuelleZeit: null,

    init(data) {
        this.alleDaten = data;
    },

    zeigeTag(tagIndex) {
        const tag = this.alleDaten[tagIndex];
        if (!tag) return;
        this.aktuelleZeit = tag.datum;
        renderKnoten(tag.knoten);
        renderFaeden(tag.faeden);
    }
};

// --- Datei: Launchweb/ui/extras/ui-webrat.js ---

// ui-webrat.js — v1

import { diskursEngine } from '../diskurs/diskurs-engine.js';
import { uiDiskursFenster } from '../diskurs/ui-diskurs.js';

export function öffneWebrat() {
    const fenster = uiDiskursFenster.erzeuge('webrat');
    diskursEngine.öffneRaum('webrat', fenster);
}

// --- Datei: Launchweb/ui/extras/ui-zeitreise.js ---

// ui-zeitreise.js — v1

import { zeitleiste } from './zeitleiste.js';

export function setupZeitreiseUI() {
    const controls = document.getElementById('zeitreise-controls');
    const startBtn = controls.querySelector('#start-zeitreise');
    const stopBtn = controls.querySelector('#stop-zeitreise');
    const slider = controls.querySelector('#zeitreise-slider');

    let interval = null;

    startBtn.addEventListener('click', () => {
        let tag = parseInt(slider.value, 10);
        interval = setInterval(() => {
            zeitleiste.zeigeTag(tag++);
            slider.value = tag;
        }, 1000);
    });

    stopBtn.addEventListener('click', () => {
        clearInterval(interval);
        interval = null;
    });

    slider.addEventListener('input', () => {
        zeitleiste.zeigeTag(parseInt(slider.value, 10));
    });
}

// --- Datei: Launchweb/core/manifest.js ---

// manifest.js — Version: Σ.v1.systembegriffe

export const Typen = {
    webung: {
        faden: 'faden',
        garn: 'garn',
        antrag: 'antrag'
    },

    antrag: {
        gold: 'gold',
        veraenderung: 'veraenderung',
        anschaffung: 'anschaffung'
    },

    status: {
        aktiv: 'aktiv',
        verblasst: 'verblasst',
        angenommen: 'angenommen',
        abgelehnt: 'abgelehnt',
        einspruch: 'einspruch'
    }
};

// --- Datei: Launchweb/core/zeitlogik.js ---

// zeitlogik.js — Version: Σ.v1.verblassung

export const Zeitlogik = {
    verblassungsTage: 7,

    istVerblassend(webung, jetzt = new Date()) {
        if (!webung.verblasstAm) return false;
        return new Date(webung.verblasstAm) < jetzt;
    },

    berechneVerblassung(typ, ereigniszeitpunkt = null) {
        const basis = ereigniszeitpunkt
            ? new Date(ereigniszeitpunkt)
            : new Date();

        if (typ === 'garn') return null; // bleibt permanent
        const verblass = new Date(basis);
        verblass.setDate(verblass.getDate() + Zeitlogik.verblassungsTage);
        return verblass.toISOString();
    }
};

// --- Datei: Launchweb/core/knotenerkennung.js ---

// knotenerkennung.js — Version: Σ.v1.knotenlogik

import { Knoten } from '../models/knotenmodell.js';
import { generateUUID } from '../utils.js';

export class Knotenerkennung {
    static erstelleKnoten({ koordinaten, erstellerId, beschreibung, typ = "standard", darstellung = "default" }) {
        const neuerKnoten = new Knoten({
            id: generateUUID(),
            koordinaten,
            erstellerId,
            beschreibung,
            typ,
            darstellung
        });

        return neuerKnoten;
    }

    static loescheWennVerwaist(knoten, webungListe) {
        const aktiveVerbindungen = webungListe.filter(w => w.zuKnotenId === knoten.id && w.zustand === 'aktiv');
        return aktiveVerbindungen.length === 0;
    }
}

// --- Datei: Launchweb/core/verblasslogik.js ---

// core/verblasslogik.js — Version: Σ.v2.fadenverfall.vollständig

import { parseISO, differenceInDays } from 'date-fns';

export class Verblasslogik {
    static pruefeVerblassen(webung, knotenHatEreigniszeitpunkt = false) {
        const erstellt = parseISO(webung.entstandenAm);
        const now = new Date();
        const tageVergangen = differenceInDays(now, erstellt);

        if (webung.typ === 'garn') return false;

        // Wenn ein Ereigniszeitpunkt existiert, zählt ab diesem + 7 Tage
        return tageVergangen > 7;
    }

    static setzeVerblasstStatus(webung, knotenHatEreigniszeitpunkt = false) {
        if (this.pruefeVerblassen(webung, knotenHatEreigniszeitpunkt)) {
            webung.zustand = 'verblasst';
        }
    }

    static tageBisVerblassen(webung, knotenHatEreigniszeitpunkt = false) {
        const erstellt = parseISO(webung.entstandenAm);
        const now = new Date();
        const verbleibend = 7 - differenceInDays(now, erstellt);
        return Math.max(0, verbleibend);
    }

    static istVerblasst(webung) {
        return webung.zustand === 'verblasst';
    }
}

// --- Datei: Launchweb/core/antragszyklus.js ---

// antragslogik.js — Version: Σ.v1.antragszyklus

import { parseISO, differenceInDays } from 'date-fns';

export class Antragslogik {
    static pruefeEntscheidung(antrag, einspruchsDatum = null) {
        const erstellt = parseISO(antrag.entstandenAm);
        const now = new Date();

        if (antrag.zustand !== 'aktiv') return;

        if (!einspruchsDatum) {
            const tage = differenceInDays(now, erstellt);
            if (tage >= 7) {
                antrag.zustand = 'angenommen';
                antrag.farbsignal = 'grün';
            }
        } else {
            const einspruch = parseISO(einspruchsDatum);
            const tageNachEinspruch = differenceInDays(now, einspruch);
            if (tageNachEinspruch >= 7) {
                antrag.zustand = 'abgelehnt';
                antrag.farbsignal = 'rot';
            }
        }
    }

    static initialisiereAntrag(antrag) {
        antrag.farbsignal = 'blau';
    }

    static markiereEinspruch(antrag) {
        antrag.farbsignal = 'lila';
    }

    static kennzeichneGoldantrag(antrag) {
        antrag.goldrand = true;
    }
}

// --- Datei: Launchweb/core/webung-engine.js ---

// webungsengine.js — Version: Σ.v1.core

import { Rolle } from './rolle.js';
import { Faden } from './fadenmodell.js';
import { Knoten } from './knoten-modell.js';
import { Verblasslogik } from './verblasslogik.js';
import { Knotenerkennung } from './knotenerkennung.js';
import { persistenceService } from './persistence-service.js';
import { WebSocketServiceSingleton as ws } from './websocket-service.js';

export const WebungsEngine = {
    async neueWebung({ rollenId, koordinaten, inhalt, typ = 'faden', optional = {} }) {
        const rolle = await persistenceService.find('rollen', rollenId);
        if (!rolle) throw new Error('Rolle nicht gefunden');

        // 1. Knoten prüfen oder erzeugen
        let knoten = await Knotenerkennung.findeOderErzeugeKnoten(koordinaten, inhalt);

        // 2. Webung erzeugen
        const webung = new Faden({
            rolleId: rollenId,
            knotenId: knoten.id,
            typ,
            inhalt,
            ...optional
        });

        // 3. Verknüpfen
        rolle.webungen.push(webung.id);
        knoten.webungen.push(webung.id);

        // 4. Verblasslogik anwenden
        Verblasslogik.setzeVerblasstStatus(webung);

        // 5. Speichern
        await persistenceService.save('rollen', rolle);
        await persistenceService.save('knoten', knoten);
        await persistenceService.save('webungen', webung);

        // 6. WebSocket-Broadcast
        ws.send({ type: 'webung_neu', payload: { webungId: webung.id } });

        return webung;
    },

    async prüfeVerblassungFürAlle() {
        const webungen = await persistenceService.getAll('webungen');
        const knotenMap = await persistenceService.getMap('knoten');

        for (const webung of webungen) {
            const knoten = knotenMap[webung.knotenId];
            Verblasslogik.setzeVerblasstStatus(webung, !!knoten?.ereigniszeitpunkt);
            await persistenceService.save('webungen', webung);
        }
    }
};

// --- Datei: Launchweb/utils/utility-tooltip.js ---

// utility-tooltip.js — Version: Σ.v1.tooltip.system

export function createTooltip(content, position) {
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    tooltip.innerText = content;
    tooltip.style.top = `${position.y}px`;
    tooltip.style.left = `${position.x}px`;
    document.body.appendChild(tooltip);
    return tooltip;
}

export function removeTooltip() {
    const tooltips = document.querySelectorAll('.tooltip');
    tooltips.forEach(t => t.remove());
}

// --- Datei: Launchweb/utils/validation.js ---

// validation.js — Version: Σ.v1.form.validation

export const Validators = {
    required(value) {
        return value?.trim() ? null : 'Pflichtfeld';
    },

    minLength(min) {
        return (value) => {
            return value.length >= min ? null : `Mindestens ${min} Zeichen`;
        };
    },

    isNumber(value) {
        return isNaN(value) ? 'Muss eine Zahl sein' : null;
    }
};

// --- Datei: Launchweb/utils/utility-core.js ---

// utility-core.js — Version: Σ.v1.core.util

export const UtilityCore = {
    generateUUID() {
        return crypto.randomUUID();
    },

    formatDate(date) {
        return new Intl.DateTimeFormat('de-DE', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        }).format(new Date(date));
    },

    clone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
};

// --- Datei: Launchweb/utils/form-components.js ---

// form-components.js — Version: Σ.v1.formteile

export function createInputField({ id, label, type = 'text', placeholder = '', value = '' }) {
    const wrapper = document.createElement('div');
    const labelEl = document.createElement('label');
    labelEl.setAttribute('for', id);
    labelEl.textContent = label;

    const input = document.createElement('input');
    input.type = type;
    input.id = id;
    input.placeholder = placeholder;
    input.value = value;

    wrapper.appendChild(labelEl);
    wrapper.appendChild(input);
    return wrapper;
}

export function createSelect({ id, label, options }) {
    const wrapper = document.createElement('div');
    const labelEl = document.createElement('label');
    labelEl.setAttribute('for', id);
    labelEl.textContent = label;

    const select = document.createElement('select');
    select.id = id;

    options.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.label;
        select.appendChild(option);
    });

    wrapper.appendChild(labelEl);
    wrapper.appendChild(select);
    return wrapper;
}

// --- Datei: Launchweb/utils/utils.js ---

// utils.js — Version: Σ.v1.misc.tools

export function debounce(fn, delay) {
    let timer = null;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), delay);
    };
}

export function throttle(fn, limit) {
    let inThrottle;
    return function (...args) {
        if (!inThrottle) {
            fn(...args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
        }
    };
}

// --- Datei: Launchweb/models/webung.js ---

// fadenmodell.js — Version: Σ.v1.fadenstruktur

export class Webung {
    constructor({ id, typ = "faden", vonRolleId, zuKnotenId }) {
        this.id = id;
        this.typ = typ; // "faden", "garn", "antrag", "goldantrag"
        this.vonRolleId = vonRolleId;
        this.zuKnotenId = zuKnotenId;
        this.entstandenAm = new Date().toISOString();
        this.zustand = "aktiv"; // oder "verblasst", "abgelehnt", "angenommen"
        this.farbsignal = null; // z. B. "blau", "lila", "grün", "rot", "goldrand"
    }
}

// --- Datei: Launchweb/models/user-model.js ---

// models/user-model.js — Version: Σ.v1.rolle.core

export const rolleService = {
    rolleId: null,

    set(id) {
        this.rolleId = id;
        localStorage.setItem('rolleId', id);
    },

    get() {
        return this.rolleId || localStorage.getItem('rolleId');
    },

    restore() {
        this.rolleId = localStorage.getItem('rolleId');
    }
};

// --- Datei: Launchweb/models/knotentypen.js ---

// models/knotentypen.js — Definition symbolischer Knotentypen

export const Knotentypen = {
    standard: {
        farbe: '#7F8C8D',
        symbol: '●',
        beschreibung: 'Standardknoten ohne Spezifizierung'
    },
    goldantrag: {
        farbe: '#F1C40F',
        symbol: '◎',
        beschreibung: 'Geldantrag in der Webkasse'
    },
    zusage: {
        farbe: '#2ECC71',
        symbol: '✓',
        beschreibung: 'Verbindliche Zusage (Garn)'
    },
    faden: {
        farbe: '#3498DB',
        symbol: '➝',
        beschreibung: 'Temporäre Beteiligung (Faden)'
    },
    einspruch: {
        farbe: '#9B59B6',
        symbol: '⚠️',
        beschreibung: 'Einspruch gegen Antrag'
    },
    abgelehnt: {
        farbe: '#E74C3C',
        symbol: '✗',
        beschreibung: 'Abgelehnter Antrag'
    },
    angenommen: {
        farbe: '#27AE60',
        symbol: '✓',
        beschreibung: 'Angenommener Antrag'
    }
};

// --- Datei: Launchweb/visuals/render-garne.js ---

// visual/render-garne.js — Version: Σ.v∞.garn.verbindung.symbolisch

import * as d3 from 'd3';
import { Farben } from './colors.js';

/**
 * Zeichnet dauerhafte Garnverbindungen zwischen Knoten (z. B. durch Zusagen)
 */
export function renderGarne(svg, projection, daten) {
  const garne = daten.filter(w => w.typ === 'garn' && w.zustand !== 'verblasst');

  const verbindungen = svg.selectAll('.garn').data(garne, d => d.id);
  verbindungen.exit().remove();

  const neu = verbindungen.enter()
    .append('path')
    .attr('class', 'garn');

  neu.merge(verbindungen)
    .attr('d', d => {
      const [x1, y1] = projection([d.quelle.lng, d.quelle.lat]);
      const [x2, y2] = projection([d.ziel.lng, d.ziel.lat]);
      return `M${x1},${y1} L${x2},${y2}`;
    })
    .attr('stroke', d => {
      const farbe = Farben.garn[d.zustand] || Farben.garn.zusage;
      return farbe;
    })
    .attr('stroke-width', d => 3 + (d.intensität || 0))
    .attr('stroke-dasharray', '1,3') // Zwirn-Stil
    .attr('opacity', 0.9)
    .attr('fill', 'none');
}

// --- Datei: Launchweb/visuals/render-webkasse.js ---

// visual/render-webkasse.js — Version: Σ.v∞.symbol.gold.circle

import { Farben } from './colors.js';

/**
 * Zeichnet die kollektive Webkasse als Kreis mit Goldfarbe
 */
export function renderWebkasse(selection, projection, data, showTooltip, hideTooltip) {
  const pos = projection({ lat: 53.56, lng: 10.03 }); // feste Position
  const stand = data.webkasse?.kontostand || 0;
  const radius = Math.sqrt(stand) * 0.05 + 10;

  const topf = selection.selectAll('.webkasse').data([stand]);

  topf.enter()
    .append('circle')
    .attr('class', 'webkasse')
    .merge(topf)
    .attr('cx', pos.x)
    .attr('cy', pos.y)
    .attr('r', radius)
    .attr('fill', Farben.webkasse)
    .attr('fill-opacity', 0.8)
    .attr('stroke', '#222')
    .attr('stroke-width', 1.5)
    .on('mouseover', e => showTooltip(`Webkasse: ${stand.toFixed(2)} €`, e.pageX, e.pageY))
    .on('mouseout', hideTooltip);

  topf.exit().remove();
}

// --- Datei: Launchweb/visuals/render-base.js ---

// render-base.js — Version: Σ.v∞.style.core

export const RenderBase = {
    fadenStyle(farbe, dicke = 2, transparenz = 0.5) {
        return {
            stroke: farbe,
            'stroke-width': dicke,
            'stroke-opacity': transparenz,
            fill: 'none'
        };
    },
    garnStyle(farbe) {
        return {
            stroke: farbe,
            'stroke-dasharray': '5,2',
            'stroke-width': 3,
            'stroke-opacity': 0.9,
            fill: 'none'
        };
    },
    antragRandStyle(farbe) {
        return {
            stroke: farbe,
            'stroke-width': 3,
            fill: 'none'
        };
    }
};

// --- Datei: Launchweb/visuals/render-antraege.js ---

// visual/render-antraege.js — Version: Σ.v∞.antrag.statusfarben.klar

import * as d3 from 'd3';
import { Farben } from './colors.js';

/**
 * Zeichnet alle Anträge mit Farbcodierung je nach Status
 */
export function renderAntraege(svg, projection, daten) {
  const antraege = daten.filter(w => w.typ === 'antrag' && w.zustand !== 'verblasst');

  const verbindungen = svg.selectAll('.antrag')
    .data(antraege, d => d.id);

  verbindungen.exit().remove();

  const neu = verbindungen.enter()
    .append('path')
    .attr('class', 'antrag');

  neu.merge(verbindungen)
    .attr('d', d => {
      const [x1, y1] = projection([d.quelle.lng, d.quelle.lat]);
      const [x2, y2] = projection([d.ziel.lng, d.ziel.lat]);
      return `M${x1},${y1} L${x2},${y2}`;
    })
    .attr('stroke', d => Farben.antrag[d.status] || Farben.antrag.gestellt)
    .attr('stroke-width', 3)
    .attr('stroke-dasharray', '2,4')
    .attr('opacity', 0.9)
    .attr('fill', 'none')
    .attr('filter', d => d.kategorie === 'goldantrag' ? 'url(#goldrand)' : null);
}

// --- Datei: Launchweb/visuals/colors.js ---

// visual/colors.js – Version: Σ.v2.klare-farben

export const Farben = {
  // Fäden
  faden: {
    wortbeitrag: '#888',
    antrag: '#0077cc',
    einspruch: '#8e44ad',
    angenommen: '#27ae60',
    abgelehnt: '#c0392b',
    verblasst: '#ccc'
  },

  // Garne
  garn: {
    zusage: '#d35400',
    vergangen: '#95a5a6'
  },

  // Knoten
  knoten: {
    standard: '#000',
    individuell: '#444'
  },

  // Anträge mit Goldrand
  rand: {
    gold: '#ffd700'
  },

  // UI / Hilfselemente
  ui: {
    highlight: '#f39c12',
    hintergrund: '#fefefe'
  }
};

// --- Datei: Launchweb/visuals/render-faeden.js ---

// visual/render-faeden.js — Version: Σ.v∞.faeden.typisiert

import { select } from 'd3-selection';
import { Farben } from './colors.js';
import { SystemMeta } from '../system-meta.js';

/**
 * Zeichnet temporäre Verbindungen („Fäden“) z. B. Wortbeiträge, Anträge etc.
 */
export function renderFaeden(svg, projection, daten) {
  if (!SystemMeta.istLayerAktiv('faeden')) return;

  const faeden = daten.webungen.filter(w => w.typ === 'faden' && w.zustand !== 'verblasst');

  const layer = svg.selectAll('.faden').data(faeden, d => d.id);

  layer.enter()
    .append('line')
    .attr('class', 'faden')
    .attr('x1', d => projection(d.von)[0])
    .attr('y1', d => projection(d.von)[1])
    .attr('x2', d => projection(d.zu)[0])
    .attr('y2', d => projection(d.zu)[1])
    .style('stroke', d => Farben.faden[d.subtyp] || Farben.faden.wortbeitrag)
    .style('stroke-width', d => Math.max(1, d.stärke || 1))
    .style('opacity', d => d.transparenz || 0.4);

  layer.exit().remove();
}

// --- Datei: Launchweb/visuals/render-knoten.js ---

// render-knoten.js — Version: Σ.v∞.svg.symbol.farbenbasiert

import { Farben } from './colors.js';

export function renderKnoten(selection, projection, bounds, data, showTooltip, hideTooltip) {
  const getLatLng = e =>
    Array.isArray(e.koordinaten)
      ? [e.koordinaten[0], e.koordinaten[1]]
      : [e.koordinaten.lat, e.koordinaten.lng];

  const visible = data.knoten.filter(e => bounds.contains(getLatLng(e)));

  const groups = selection.selectAll('.knoten').data(visible, d => d.id);

  const enter = groups.enter().append('g').attr('class', 'knoten');

  enter.merge(groups)
    .attr('transform', d => {
      const [lat, lng] = getLatLng(d);
      const p = projection({ lat, lng });
      return `translate(${p.x},${p.y})`;
    })
    .each(function (d) {
      const g = d3.select(this);
      const r = d.typ === 'person' ? 10 : 12;
      const fill = Farben.knoten[d.typ] || Farben.knoten.standard;

      g.selectAll('circle')
        .data([d])
        .join('circle')
        .attr('r', r)
        .attr('fill', fill)
        .attr('stroke', '#000')
        .attr('stroke-width', 1.5);

      g.on('mouseover', e => showTooltip(d.titel || 'Knoten', e.pageX, e.pageY))
       .on('mouseout', hideTooltip);
    });

  groups.exit().remove();
}

// --- Datei: Launchweb/visuals/render-fadenlegende.js ---

// render-fadenlegende.js — Version: Σ.v1.fadenlegende

import * as d3 from 'd3';
import { FADENFARBEN, FADENSTILE } from './colors.js';

export function renderFadenlegende(containerId) {
    const fadenTypen = [
        { label: 'Gesprächsbeitrag', farbe: FADENFARBEN.gespräch, stil: FADENSTILE.normal },
        { label: 'Gesprächseröffnung', farbe: FADENFARBEN.gesprächStart, stil: FADENSTILE.normal },
        { label: 'Zusage (Garn)', farbe: FADENFARBEN.garn, stil: FADENSTILE.garn },
        { label: 'Antrag', farbe: FADENFARBEN.antrag, stil: FADENSTILE.normal },
        { label: 'Einspruch', farbe: FADENFARBEN.einspruch, stil: FADENSTILE.normal },
        { label: 'Abgelehnt', farbe: FADENFARBEN.abgelehnt, stil: FADENSTILE.normal },
        { label: 'Angenommen', farbe: FADENFARBEN.angenommen, stil: FADENSTILE.normal },
        { label: 'Goldantrag', farbe: FADENFARBEN.antrag, stil: FADENSTILE.gold },
        { label: 'Vergangen', farbe: FADENFARBEN.vergangen, stil: FADENSTILE.verblassend }
    ];

    const container = d3.select(`#${containerId}`);
    container.html(''); // Reset

    const svg = container.append('svg')
        .attr('width', 300)
        .attr('height', fadenTypen.length * 30);

    const einträge = svg.selectAll('g')
        .data(fadenTypen)
        .enter()
        .append('g')
        .attr('transform', (_, i) => `translate(10, ${i * 30 + 10})`);

    einträge.append('line')
        .attr('x1', 0)
        .attr('y1', 5)
        .attr('x2', 60)
        .attr('y2', 5)
        .attr('stroke', d => d.farbe)
        .attr('stroke-width', d => d.stil === 'garn' ? 4 : 2)
        .attr('stroke-dasharray', d => d.stil === 'verblassend' ? '2,2' : (d.stil === 'gold' ? '4,1' : ''))
        .attr('opacity', d => d.stil === 'verblassend' ? 0.3 : 1);

    einträge.append('text')
        .attr('x', 70)
        .attr('y', 9)
        .text(d => d.label)
        .attr('font-size', '12px')
        .attr('fill', '#333');
}

// --- Datei: Launchweb/data/persistence-services.server.js ---

// persistence-service.server.js — Version: Σ.server.fs

import fs from 'fs/promises';
import path from 'path';

export const PersistenceServer = {
    basePath: './weltweberei-data',

    async ensureDir() {
        await fs.mkdir(this.basePath, { recursive: true });
    },

    filePath(name) {
        return path.join(this.basePath, `${name}.json`);
    },

    async loadAll(name) {
        try {
            const content = await fs.readFile(this.filePath(name), 'utf-8');
            return JSON.parse(content);
        } catch (err) {
            if (err.code === 'ENOENT') return [];
            throw err;
        }
    },

    async write(name, data) {
        await this.ensureDir();
        await fs.writeFile(this.filePath(name), JSON.stringify(data, null, 2));
    },

    async store(name, entry) {
        const data = await this.loadAll(name);
        data.push(entry);
        await this.write(name, data);
    },

    async delete(name, id) {
        const data = await this.loadAll(name);
        const filtered = data.filter(e => e.id !== id);
        await this.write(name, filtered);
    }
};

// --- Datei: Launchweb/data/data-model.js ---

// data-model.js — Version: Σ.v1.modelstruktur

export const Model = {
    webung: {
        id: null,
        vonRollenId: null,
        typ: 'faden' | 'garn' | 'antrag',
        zuKnotenId: null,
        text: '',
        erstelltAm: null,
        verblasstAm: null,
        farbe: '', // optisch gesteuert über Typ & Status
        status: '', // aktiv | verblasst | angenommen | abgelehnt
    },

    knoten: {
        id: null,
        erstelltVon: null,
        erstelltAm: null,
        koordinaten: { lat: 0, lng: 0 },
        text: '',
        visual: 'knotenstandard',
        ereigniszeitpunkt: null // optional
    },

    antrag: {
        id: null,
        vonRollenId: null,
        knotenId: null,
        gestelltAm: null,
        typ: '', // 'gold' | 'veränderung' | 'anschaffung'
        text: '',
        status: 'offen' | 'einspruch' | 'abgelehnt' | 'angenommen',
        einspruchsDatum: null,
        entscheidungsDatum: null
    },

    rolle: {
        id: null,
        name: '',
        wohnort: { lat: 0, lng: 0 }
    }
};

// --- Datei: Launchweb/data/data-finanz.js ---

// data/data-finanz.js — Version: Σ.v∞.1.webkasse.core

import { generateUID } from '../utils.js';

let webkasse = {
    kontostand: 0,
    buchungen: [] // { id, betrag, von, zweck, zeitpunkt, quelle }
};

// Buchungstypen: spende, zusage, auszahlung, umbuchung, goldfaden

export function aktuelleWebkasse() {
    return {
        kontostand: webkasse.kontostand,
        buchungen: [...webkasse.buchungen]
    };
}

export function fuegeBuchungHinzu({ betrag, von, zweck, quelle = 'unbekannt' }) {
    const buchung = {
        id: generateUID(),
        betrag,
        von,
        zweck,
        quelle,
        zeitpunkt: new Date().toISOString()
    };
    webkasse.buchungen.push(buchung);
    webkasse.kontostand += betrag;
    return buchung;
}

export function macheAuszahlung({ betrag, an, zweck = 'auszahlung' }) {
    if (webkasse.kontostand >= betrag) {
        return fuegeBuchungHinzu({ betrag: -betrag, von: 'webkasse', zweck, quelle: 'auszahlung:' + an });
    } else {
        throw new Error("Nicht genügend Mittel in der Webkasse");
    }
}

export function filtereBuchungen(filterFn) {
    return webkasse.buchungen.filter(filterFn);
}

export function resetWebkasse() {
    webkasse = {
        kontostand: 0,
        buchungen: []
    };
}

// --- Datei: Launchweb/data/data-diskurs.js ---

// data/data-diskurs.js — Version: Σ.v2.diskursstruktur.raumgestützt

export const diskursData = {
    räume: [], // Jeder Raum: { id, typ, referenzId, gespräche: [ { id, beitrag, typ, autor, zeit } ] }

    addRaum(raum) {
        this.räume.push(raum);
    },

    findRaum(id) {
        return this.räume.find(r => r.id === id);
    },

    addGespräch(raumId, gespräch) {
        const raum = this.findRaum(raumId);
        if (raum) {
            raum.gespräche.push(gespräch);
        }
    },

    getGespräche(raumId) {
        const raum = this.findRaum(raumId);
        return raum ? raum.gespräche : [];
    },

    getGesprächeMitTyp(raumId, typ) {
        const raum = this.findRaum(raumId);
        return raum ? raum.gespräche.filter(g => g.typ === typ) : [];
    },

    deleteGespräch(raumId, gesprächId) {
        const raum = this.findRaum(raumId);
        if (raum) {
            raum.gespräche = raum.gespräche.filter(g => g.id !== gesprächId);
        }
    },

    deleteRaum(id) {
        this.räume = this.räume.filter(r => r.id !== id);
    },

    getAlleRäume() {
        return this.räume;
    }
};

// --- Datei: Launchweb/data/persistence-services.client.js ---

// persistence-service.client.js — Version: Σ.client.localStorage

export const PersistenceClient = {
    loadAll(key) {
        const raw = localStorage.getItem(key);
        return raw ? JSON.parse(raw) : [];
    },

    save(key, data) {
        localStorage.setItem(key, JSON.stringify(data));
    },

    store(key, entry) {
        const data = this.loadAll(key);
        data.push(entry);
        this.save(key, data);
    },

    delete(key, id) {
        const data = this.loadAll(key).filter(e => e.id !== id);
        this.save(key, data);
    },

    clear(key) {
        localStorage.removeItem(key);
    }
};

// --- Datei: Launchweb/data/data-knoten.js ---

// data/data-knoten.js — Version: Σ.v∞.1.knotenstruktur.core

import { generateUID } from '../utils.js';

const knotenStore = [];

export function createKnoten({ titel, beschreibung, koordinaten, erstellerId, zeitpunkt = null, typ = 'allgemein' }) {
    const neuerKnoten = {
        id: generateUID(),
        titel,
        beschreibung,
        koordinaten,
        erstellerId,
        zeitpunkt,
        typ,
        erstelltAm: new Date().toISOString(),
        verbunden: [],
        aktiv: true
    };
    knotenStore.push(neuerKnoten);
    return neuerKnoten;
}

export function getAlleKnoten() {
    return knotenStore.filter(k => k.aktiv);
}

export function findeKnotenNachId(knotenId) {
    return knotenStore.find(k => k.id === knotenId && k.aktiv);
}

export function verknuepfeMitKnoten(knotenId, webungId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten && !knoten.verbunden.includes(webungId)) {
        knoten.verbunden.push(webungId);
    }
}

export function entferneVerknuepfung(knotenId, webungId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten) {
        knoten.verbunden = knoten.verbunden.filter(id => id !== webungId);
        if (knoten.verbunden.length === 0) {
            knoten.aktiv = false;
        }
    }
}

export function loescheKnoten(knotenId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten) {
        knoten.aktiv = false;
    }
}

// --- Datei: Launchweb/data/persistence-services.js ---

// persistence-service.js — Version: Σ.v2.contextaware

let speicher;

if (typeof window !== 'undefined' && window.localStorage) {
    // Client-basiert
    import('./persistence-service.client.js').then(mod => {
        speicher = mod.Speicher;
    });
} else {
    // Server-basiert (Node.js)
    import('./persistence-service.server.js').then(mod => {
        speicher = mod.Speicher;
    });
}

// Async-Wartefunktion, bis das Modul geladen ist
async function bereitstellen() {
    if (!speicher) {
        await new Promise(resolve => setTimeout(resolve, 10)); // minimal warten
        return bereitstellen(); // rekursiv warten
    }
    return speicher;
}

// Exporte als Proxy-Funktionen
export const Speicher = {
    async ladeAlle(name) {
        const s = await bereitstellen();
        return s.ladeAlle(name);
    },

    async schreibe(name, daten) {
        const s = await bereitstellen();
        return s.schreibe(name, daten);
    },

    async speichere(name, eintrag) {
        const s = await bereitstellen();
        return s.speichere(name, eintrag);
    },

    async loesche(name, id) {
        const s = await bereitstellen();
        return s.loesche(name, id);
    }
};

// --- Datei: Launchweb/services/api-knoten.js ---

// api-knoten.js — Version: Σ.v1.knotenservice

import { Knotenerkennung } from '../core/knotenerkennung.js';
import { Speicher } from './persistence-service.js';

export const apiKnoten = {
    async erstelleKnoten(daten) {
        const knoten = Knotenerkennung.erstelleKnoten(daten);
        await Speicher.speichere('knoten', knoten);
        return knoten;
    },

    async pruefeUndLoescheVerwaiste() {
        const knotenListe = await Speicher.ladeAlle('knoten');
        const webungen = await Speicher.ladeAlle('webung');

        const geloeschte = [];

        for (const k of knotenListe) {
            if (Knotenerkennung.loescheWennVerwaist(k, webungen)) {
                await Speicher.loesche('knoten', k.id);
                geloeschte.push(k.id);
            }
        }

        return geloeschte;
    }
};

// --- Datei: Launchweb/services/api-verblassen.js ---

// api-verblassen.js — Version: Σ.v1.verblass-service

import { Verblasslogik } from '../core/verblasslogik.js';
import { Speicher } from './persistence-service.js';

export const apiVerblassen = {
    async verblasseAlle() {
        const webungen = await Speicher.ladeAlle('webung');
        const knotenListe = await Speicher.ladeAlle('knoten');

        for (const w of webungen) {
            const knoten = knotenListe.find(k => k.id === w.zuKnotenId);
            Verblasslogik.setzeVerblasstStatus(w, knoten?.ereigniszeitpunkt);
        }

        await Speicher.schreibe('webung', webungen);
    }
};

// --- Datei: Launchweb/services/api-webung.js ---

// api-webung.js — Version: Σ.v1.api

import express from 'express';
import { WebungsEngine } from './webungsengine.js';
import { persistenceService } from './persistence-service.js';

export const webungApi = express.Router();

webungApi.post('/webung', async (req, res) => {
    try {
        const newWebung = await WebungsEngine.neueWebung(req.body);
        res.status(201).json(newWebung);
    } catch (err) {
        res.status(400).json({ error: err.message });
    }
});

webungApi.get('/webungen', async (req, res) => {
    const webungen = await persistenceService.getAll('webungen');
    res.json(webungen);
});

// --- Datei: Launchweb/services/auth-service.js ---

// services/auth-service.js — v1

let eingeloggterWeber = null;

export const AuthService = {
    login(userId, name, wohnort) {
        eingeloggterWeber = { id: userId, name, wohnort };
    },
    logout() {
        eingeloggterWeber = null;
    },
    getUser() {
        return eingeloggterWeber;
    },
    isLoggedIn() {
        return !!eingeloggterWeber;
    }
};

// --- Datei: Launchweb/services/websocket-service.js ---

// services/websocket-service.js — v1

class WebSocketService {
    constructor(url) {
        this.url = url;
        this.socket = null;
        this.listeners = new Set();
    }

    connect() {
        if (this.socket) return;

        this.socket = new WebSocket(this.url);

        this.socket.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            this.listeners.forEach(fn => fn(msg));
        };

        this.socket.onopen = () => {
            console.log('WebSocket verbunden');
        };

        this.socket.onclose = () => {
            this.socket = null;
            setTimeout(() => this.connect(), 1000);
        };

        this.socket.onerror = () => {
            this.socket?.close();
        };
    }

    send(msg) {
        if (this.socket?.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify(msg));
        }
    }

    subscribe(fn) {
        this.listeners.add(fn);
    }
}

export const WebSocketServiceInstance = new WebSocketService('ws://localhost:8080');

// --- Datei: Launchweb/services/api-antrag.js ---

// api-antrag.js — Version: Σ.v1.antrag-service

import { Antragslogik } from '../core/antragslogik.js';
import { Speicher } from './persistence-service.js';

export const apiAntrag = {
    async pruefeAlleAntraege() {
        const antraege = await Speicher.ladeAlle('antrag');

        for (const a of antraege) {
            Antragslogik.pruefeEntscheidung(a, a.einspruchsDatum);
        }

        await Speicher.schreibe('antrag', antraege);
    },

    async stelleAntrag(antrag) {
        Antragslogik.initialisiereAntrag(antrag);
        if (antrag.kategorie === 'gold') {
            Antragslogik.kennzeichneGoldantrag(antrag);
        }

        await Speicher.speichere('antrag', antrag);
        return antrag;
    },

    async markiereEinspruch(antragId) {
        const antraege = await Speicher.ladeAlle('antrag');
        const antrag = antraege.find(a => a.id === antragId);
        if (antrag) {
            Antragslogik.markiereEinspruch(antrag);
            antrag.einspruchsDatum = new Date().toISOString();
        }
        await Speicher.schreibe('antrag', antraege);
    }
};

// --- Datei: Launchweb/services/websocket-integration.js ---

// websocket-integration.js — Version: Σ.v1.0.webung.sync.full

import { websocketService } from './websocket-service.js';
import { loadInitialData } from './startup-loader.js';
import { renderVisuals } from './leaflet-setup.js';

export class WebsocketIntegration {
    constructor(map) {
        this.map = map;
        websocketService.registerMessageHandler(this.handleMessage.bind(this));
        websocketService.connect();
    }

    async handleMessage(msg) {
        const { type } = msg;

        if (['webung_created', 'knoten_created', 'antrag_started', 'einspruch', 'abstimmung'].includes(type)) {
            const freshData = await loadInitialData();
            renderVisuals(this.map, freshData);
        } else if (type === 'ping') {
            // optional: heartbeat received
        } else {
            console.warn('WebsocketIntegration: Unbekannter Nachrichtentyp', type);
        }
    }
}

// --- Datei: Launchweb/services/file-storage.js ---

// services/file-storage.js — v1

import fs from 'fs/promises';
import path from 'path';

export const FileStorage = {
    baseDir: './weltweberei-data',

    async ensureDir() {
        await fs.mkdir(this.baseDir, { recursive: true });
    },

    async read(file) {
        const full = path.join(this.baseDir, file);
        try {
            const content = await fs.readFile(full, 'utf-8');
            return JSON.parse(content);
        } catch (err) {
            if (err.code === 'ENOENT') return [];
            throw err;
        }
    },

    async write(file, data) {
        await this.ensureDir();
        const full = path.join(this.baseDir, file);
        await fs.writeFile(full, JSON.stringify(data, null, 2));
    }
};

// --- Datei: __MACOSX/Launchweb/._index.html ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._system-meta.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._merged-weltweb.txt ---

// Fehler: 'utf-8' codec can't decode byte 0xb0 in position 45: invalid start byte


// --- Datei: __MACOSX/Launchweb/._weltweb.txt ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._startup-loader.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._layer-manager.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._leaflet-setup.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._strukturbaum.txt ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._init-events.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._style.css ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._engine-events.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._main.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-login.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-ereignis.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-interactions.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-finanz.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-themenfilter.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-core.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._ui-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._knoten-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._knoten-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._antrag-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._ui-antrag.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._render-antraege.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._antrag-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._diskurs-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._ui-diskurs.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._diskurs-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/layer/._ui-layer-advanced.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/layer/._ui-layer-toggle.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-naehstuebchen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-zeitreise.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-webrat.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._zeitleiste.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._webung-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._antragszyklus.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._verblasslogik.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._zeitlogik.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._manifest.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._knotenerkennung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._form-components.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utility-core.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._validation.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utility-tooltip.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utils.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._user-model.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._knotentypen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._webung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-base.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-antraege.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-faeden.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._colors.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-fadenlegende.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-garne.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-webkasse.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-finanz.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-model.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.client.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.server.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-diskurs.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._websocket-service.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-verblassen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._websocket-integration.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-antrag.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._file-storage.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._auth-service.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-webung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: Launchweb/layer-manager.js ---

// layer-manager.js — Version: Σ.v3.singleton-final

class LayerManager {
  constructor(map = null) {
    if (LayerManager._instance) return LayerManager._instance;
    this.map = map;
    this.data = {};
    this.layerStates = new Map();
    this.renderCallbacks = new Map();
    LayerManager._instance = this;
  }

  static getInstance() {
    if (!LayerManager._instance) {
      LayerManager._instance = new LayerManager();
    }
    return LayerManager._instance;
  }

  updateData(daten) {
    this.data = daten;
  }

  getData() {
    return this.data;
  }

  registerLayer(name, renderFn) {
    this.layerStates.set(name, true);
    this.renderCallbacks.set(name, renderFn);
  }

  renderActiveLayers(selection, projection) {
    for (const [name, isActive] of this.layerStates.entries()) {
      if (isActive) {
        const renderFn = this.renderCallbacks.get(name);
        if (renderFn) {
          const layerData = this.data[name] || [];
          renderFn(selection, projection, layerData);
        }
      }
    }
  }
}

export const layerManager = LayerManager.getInstance();

// --- Datei: Launchweb/leaflet-setup.js ---

import { layerManager } from './layer-manager.js';

export function setupLeafletMap(lat, lng, zoom) {
  const map = L.map('map').setView([lat, lng], zoom);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);

  const daten = layerManager.getData();
  console.log('🧪 LayerManager Daten in leaflet:', daten);

  if (daten?.knoten?.length) {
    daten.knoten.forEach(k => {
      if (k.lat && k.lng) {
        L.marker([k.lat, k.lng]).addTo(map).bindPopup(k.name || 'Knoten');
      }
    });
  }

  return map;
}

// --- Datei: Launchweb/style.css ---

/* style.css — Version: Σ.v1.0.webstruktur */

html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: system-ui, sans-serif;
    background-color: #fdfaf6;
}

#map {
    height: 100%;
    width: 100%;
}

.overlay {
    position: absolute;
    top: 10%;
    left: 10%;
    width: 80%;
    max-height: 80%;
    background: white;
    border: 2px solid #ccc;
    border-radius: 8px;
    padding: 1em;
    box-shadow: 0 0 10px rgba(0,0,0,0.2);
    overflow-y: auto;
    z-index: 1000;
}

.overlay.hidden {
    display: none;
}

.info-panel {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background: rgba(255,255,255,0.95);
    padding: 1em;
    border-top: 2px solid #ccc;
    display: none;
    z-index: 900;
}

.info-panel.visible {
    display: block;
}

#ui-controls {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 1100;
}

#ui-controls button {
    padding: 0.5em 1em;
    font-size: 1em;
    border-radius: 4px;
    border: none;
    background-color: #333;
    color: white;
    cursor: pointer;
    transition: background 0.2s;
}

#ui-controls button:hover {
    background-color: #555;
}

/* Tooltip-Styling (für utility-tooltip.js) */
.tooltip {
    position: absolute;
    background: #fff;
    padding: 0.5em 0.8em;
    border-radius: 4px;
    border: 1px solid #ccc;
    font-size: 0.9em;
    pointer-events: none;
    box-shadow: 0 0 5px rgba(0,0,0,0.1);
    z-index: 2000;
}

/* Farben aus visual/colors.js könnten per Klasse nachgeladen werden */

.layer-controls {
    position: absolute;
    top: 1em;
    right: 1em;
    background: rgba(255, 255, 255, 0.8);
    padding: 0.5em;
    border-radius: 5px;
    font-size: 0.9em;
}

.layer-toggle-label {
    display: block;
    margin: 0.2em 0;
}

// --- Datei: Launchweb/weltweb.txt ---



⸻

Manifest der Weltweberei


⸻

🧶 Webung

Webung bezeichnet jede Handlung, mit der ein Weber über seine Rolle in die Welt eingreift.
	•	Die Rolle ist visuell verankert an einem festen Ort auf der Leaflet-Karte, identifiziert über eine ID bei Registrierung.
	•	Eine Webung erzeugt eine Verbindung von der Rolle zu einem beliebigen Punkt auf der Karte – entweder:
	•	als Faden: temporär (verblasst innerhalb von 7 Tagen)
	•	als Garn: dauerhaft (bis zur aktiven Auflösung)

Eine Webung entsteht z. B. durch:
	•	Erstellen eines Knotens (Informationspunkt mit Kontext)
	•	Teilnahme an einem Gespräch
	•	Stellung eines Antrags
	•	Abgabe einer Zusage

	der Weber entscheidet selbst, ob er Faden oder Garn benutzt. Garn gilt als verbindliche Zusage.
	auch im Nachhinein kann ein Weber seine Rolle mit einem Knoten verbinden, wenn er beispielsweise physisch an einem Ereignis zugegen war und seine Mitwirkung nun dokumentieren möchte
⸻

🪢 Knoten

Ein Knoten entsteht, wenn ein Weber eine neue Webung mit Informationsinhalt an einem Ort auf der Karte vornimmt.
	•	Der Knoten ist Träger:
	•	von Informationen (z. B. Ankündigungen, Hinweise)
	•	von Gesprächsmöglichkeiten (Diskurs)
	•	von Anträgen (siehe unten)
	•	Weitere Webungen anderer Weber verknüpfen sich automatisch mit dem Knoten.
	•	Ein Knoten löst sich auf, wenn kein Faden und kein Garn mehr mit ihm verbunden ist.

Darstellung:
	•	Standardmäßig als visueller Knoten dargestellt
	•	Material: abgeleitet aus den verbundenen Fäden und Garne
	•	Visualisierung kann vom ursprünglichen Weber selbst angepasst werden

⸻

🧭 Webkasse

Die Webkasse ist das Gemeinschaftskonto der Ortsweberei.
Sie ist der exklusive Ort für Geldauszahlungsanträge.

⸻

🧾 Anträge
	•	Können gestellt werden auf:
	•	Geldauszahlung (→ nur über Knotenknüpfung auf Webkasse, heißen Goldantrag und sind mit goldenem Rand versehen)
	•	Veränderung
	•	Anschaffung
	•	alles mögliche

Visualisierung:
	•	Blauer Faden bei Stellung
	•	Lila Faden bei Einspruch (binnen 7 Tagen möglich)
	•	Grüner Faden bei Annahme
– automatisch 7 Tage nach Antragstellung (ohne Einspruch)
– bei Einspruch: Abstimmung 7 Tage nach Einspruch
	•	Roter Faden bei Ablehnung
	•	Goldener Rand bei Goldanträgen
	•	Jeder Antragsfaden verblasst 7 Tage nach Entscheidung

⸻

🧵 Extraräume
	•	Nähstübchen → Raum zum freien Plaudern
	•	Webrat → Diskussionen zu orts- und ereignisunabhängigen Themen

⸻

🗓️ Zeitleiste / Auditfunktion
	•	Navigierbare Zeitleiste, um vergangene Webungen auditierbar zu halten
	•	Zeitreise: Tag-für-Tag, einstellbare Geschwindigkeit
	•	Statische Zeitfenster: frei wählbare Intervalle (z. B. 1 Woche, 1 Monat etc.)

⸻

📱 Mobile first!

Alle Funktionalitäten und Interfaces sind von Grund auf für mobile Nutzung optimiert.


Wenn ein Weber an einem Gespräch teilnimmt, dann webt sich automatisch ein Faden von seiner Rolle in den Gesprächsraum. Solch ein Faden verschwindet ja sukzessive wieder innerhalb einer Woche. Wenn ein Weber dann aber in diesem Zeitraum weitere Beiträge in demselben Knoten tätigt, dann wird der Faden dicker (immer proportional zu der zeitlich überlappenden Anzahl der Beiträge. Dabei ist jeder Faden (zumindest anteilig) visuell vertreten (mit seiner jeweiligen Farbe und Transparenz))
Garn wiederum steht ja für verbindliche Zusagen und bleibt als stabile Verbindung zwischen Rolle und knoten, bis entweder der knoten Aufgelöst wird oder die Zusage abgebrochen wird. Garn erkennt man an der gezwirnten Optik (oder welche Optik Garn auch immer hat). Ist ein Ereignis vergangen (und hat sich also die Zusage in Tat umgewandelt) wird der knoten und die zu ihm führenden Fäden und Garne grau und verschwindet im laufe einer Woche sukzessive.

weltweberei/
├── index.html                    → Einstiegspunkt (Leaflet + UI-Struktur)
├── style.css                    → Grundlayout, farblich Weberei-konform
├── main.js                      → App-Starter: Kartenaufbau + Datenbindung
├── startup-loader.js            → Initialdaten, UI-Init, Layer-Setup
├── leaflet-setup.js             → Karte + Zeitachse + Keyevents

├── core/
    --- webung-engine.js
│   ├── zeitlogik.js             → Blasszeiten, Garnhaltbarkeit, Zeitreise
│   ├── knotenerkennung.js       → Logik zur Auflösung und Persistenzprüfung
│   ├── verblasslogik.js         → Fadenverblassung etc.
│   └── manifest.js              → Manifest-Logik (aus `weltweb.txt`)

├── data/
│   ├── data-model.js            → Datenstrukturen: Knoten, Fäden, Garne
│   ├── data-knoten.js           → Knoten-spezifische Datenhaltung
│   ├── data-diskurs.js          → Diskursdaten: Gespräche, Beiträge, etc.
│   ├── data-finanz.js           → Webkassen-Datenhaltung
│   └── persistence-service.js (+.client, +.server)  → Datei-/Serverpersistenz (Filesystem/Backend)

├── services/
│   ├── api-service.js           → Generische API-Schicht
│   ├── api-diskurs.js           → Gesprächs-API
│   ├── api-knoten.js            → Knotendaten-API
│   ├── websocket-service.js     → Live-Daten
│   ├── websocket-integration.js → Events live synchronisieren
│   ├── auth-service.js          → Anmeldung & Rollenverknüpfung
│   └── file-storage.js          → Lokale Dateioperationen├── api-antrag.js           → API für Anträge
│   ├── api-verblassen.js       → API für Verblasslogik
│   ├── api-webung.js           → API für allgemeine Webungen

├── visual/
│   ├── render-knoten.js             → Visualisierung der Knoten
│   ├── render-faeden.js             → Darstellung aller Fäden
│   ├── render-garne.js              → Darstellung aller Garne
│   ├── render-antraege.js             → Darstellung Antragszyklen
│   ├── render-webkasse.js           → Darstellung Webkasse
│   └── colors.js                → Farbsemantik & Symbolfarben

├── ui/
│   ├── ui-core.js               → Grundinteraktionen & UI-Logik
│   ├── ui-interactions.js       → Buttons, Events, UI-Flows
│   ├── ui-themenfilter.js       → Filter für Knotentypen
│   ├── ui-login.js              → Loginmaske + Identifikation
│   ├── ui-ereignis.js           → Knoteninteraktionen
│   ├── ui-finanz.js             → Webkasseninterface

│   ├── knoten/
│   │   ├── ui-knoten.js         → Knotendarstellung (Info + Visu)
│   │   ├── knoten-engine.js     → Knotenanlage, Logik
│   │   └── knoten-form.js       → Formular zur Knotenerstellung

│   ├── diskurs/
│   │   ├── ui-diskurs.js        → Gesprächsfenster
│   │   ├── diskurs-engine.js    → Diskursverlauf + Webungslogik
│   │   └── diskurs-form.js      → Beiträge hinzufügen, Antrag starten

│   ├── antrag/
│   │   ├── ui-antrag.js         → Antrag-UI
│   │   ├── antrag-engine.js     → Zyklus-Logik
│   │   └── antrag-form.js       → Antragsformular

│   └── extras/
│       ├── ui-zeitreise.js      → Zeitleistensteuerung
│       ├── ui-webrat.js         → Ortunabhängige Debatte
│       ├── ui-naehstuebchen.js  → Plauderbereich
│       └── zeitleiste.js        → Visualisierung vergangener Webungen

├── utils/
│   ├── utility-core.js          → Allg. Hilfsfunktionen
│   ├── utility-tooltip.js       → Tooltip-System
│   ├── form-components.js       → Felder, Dropdowns etc.
│   ├── validation.js            → Formprüfungen
│   └── utils.js                 → Alles sonstige

└── models/
    ├── user-model.js            → Rollenstruktur, Fadenverhalten
    └── knotentypen.js           → Definition & Farben aller Knotentypen

// --- Datei: Launchweb/ui/ui-ereignis.js ---

// ui-ereignis.js — Interaktion mit einzelnen Knotenpunkten

import { showKnotenInfo } from './knoten/ui-knoten.js';

export function setupEreignisInteraktion() {
    document.addEventListener('click', (e) => {
        const target = e.target.closest('.knotenpunkt');
        if (target) {
            const knotenId = target.dataset.knotenId;
            if (knotenId) {
                showKnotenInfo(knotenId);
            }
        }
    });
}

// --- Datei: Launchweb/ui/ui-interactions.js ---

// ui-interactions.js — Steuerung von Buttons und UI-Aktionen

export function setupUIInteractions() {
    const knotenButton = document.getElementById('neuer-knoten');
    const zeitreiseButton = document.getElementById('zeitreise-button');
	
	document.getElementById('toggle-faeden').addEventListener('click', () => {
    layerManager.toggleLayer('faeden');
    svgLayer.requestRender();
});

    if (knotenButton) {
        knotenButton.addEventListener('click', () => {
            alert('Knotenerstellung folgt.');
        });
    }

    if (zeitreiseButton) {
        zeitreiseButton.addEventListener('click', () => {
            alert('Zeitleiste wird aktiviert.');
        });
    }
}

// --- Datei: Launchweb/ui/ui-finanz.js ---

// ui-finanz.js — Webkassenanzeige & Interaktion

export function renderWebkasse(data) {
    const container = document.getElementById('webkasse-container');
    if (!container) return;

    const eintraege = data.map(eintrag => `
        <div class="buchung">
            <span class="betrag">${eintrag.betrag.toFixed(2)}€</span>
            <span class="zweck">${eintrag.zweck}</span>
            <span class="datum">${eintrag.datum}</span>
        </div>
    `).join('');

    container.innerHTML = `
        <h3>Webkasse</h3>
        <div class="eintraege">${eintraege}</div>
    `;
}

// --- Datei: Launchweb/ui/ui-themenfilter.js ---

// ui-themenfilter.js — Filterung nach Knotentypen (Farben, Kategorien)

export function initializeThemenfilter() {
    const filterElement = document.getElementById('themenfilter');

    if (!filterElement) return;

    filterElement.addEventListener('change', () => {
        const selected = filterElement.value;
        const event = new CustomEvent('filterChange', { detail: { selected } });
        window.dispatchEvent(event);
    });
}

// --- Datei: Launchweb/ui/ui-core.js ---

// ui-core.js — Version: uiΣ.v1.0.basismodul

export function initializeUICore() {
    const overlay = document.getElementById('webungs-overlay');
    const infoPanel = document.getElementById('knoten-info');

    function showOverlay(contentHtml) {
        overlay.innerHTML = contentHtml;
        overlay.classList.remove('hidden');
    }

    function hideOverlay() {
        overlay.classList.add('hidden');
        overlay.innerHTML = '';
    }

    function showInfo(contentHtml) {
        infoPanel.innerHTML = contentHtml;
        infoPanel.classList.remove('hidden');
    }

    function hideInfo() {
        infoPanel.classList.add('hidden');
        infoPanel.innerHTML = '';
    }

    function toggleOverlay(contentHtml) {
        if (overlay.classList.contains('hidden')) {
            showOverlay(contentHtml);
        } else {
            hideOverlay();
        }
    }

    function toggleInfo(contentHtml) {
        if (infoPanel.classList.contains('hidden')) {
            showInfo(contentHtml);
        } else {
            hideInfo();
        }
    }

    return {
        showOverlay,
        hideOverlay,
        showInfo,
        hideInfo,
        toggleOverlay,
        toggleInfo
    };
}

// --- Datei: Launchweb/ui/ui-login.js ---

// ui-login.js — Version: Σ.v1.auth.ui

import { rolleService } from '../models/user-model.js';

export function setupLoginUI() {
    const loginForm = document.getElementById('login-form');
    const nameInput = document.getElementById('login-name');

    loginForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const name = nameInput.value.trim();
        if (name) {
            rolleService.login(name);
            document.getElementById('login-panel').style.display = 'none';
        }
    });

    if (rolleService.isLoggedIn()) {
        document.getElementById('login-panel').style.display = 'none';
    }
}

// --- Datei: Launchweb/ui/knoten/knoten-engine.js ---

// knoten-engine.js — Logik zum Erstellen und Speichern neuer Knoten

import { speichereKnoten } from '../../data/data-knoten.js';

export async function erstelleKnoten(knotenDaten) {
    const neuerKnoten = {
        id: Date.now().toString(),
        ...knotenDaten
    };

    await speichereKnoten(neuerKnoten);
    alert('Knoten erfolgreich erstellt.');
}

// --- Datei: Launchweb/ui/knoten/ui-knoten.js ---

// ui-knoten.js — Anzeige eines Knotens + Optionen

import { getKnotenById } from '../../data/data-knoten.js';

export function showKnotenInfo(knotenId) {
    const knoten = getKnotenById(knotenId);
    if (!knoten) return;

    const info = `
        <h2>${knoten.titel}</h2>
        <p>${knoten.beschreibung}</p>
        <button id="beitreten-btn">Beitreten</button>
    `;

    window.showInfoPanel(info);

    const btn = document.getElementById('beitreten-btn');
    if (btn) {
        btn.addEventListener('click', () => {
            alert('Webung mit diesem Knoten folgt.');
        });
    }
}

// --- Datei: Launchweb/ui/knoten/knoten-form.js ---

// knoten-form.js — Formular zur Knotenerstellung

import { erstelleKnoten } from './knoten-engine.js';

export function initKnotenForm() {
    const form = document.getElementById('knoten-form');
    if (!form) return;

    form.addEventListener('submit', async (e) => {
        e.preventDefault();

        const titel = form.querySelector('#titel').value;
        const beschreibung = form.querySelector('#beschreibung').value;

        await erstelleKnoten({ titel, beschreibung });
        form.reset();
    });
}

// --- Datei: Launchweb/ui/antrag/antrag-form.js ---

// antrag-form.js — v1

import { AntragEngine } from './antrag-engine.js';
import { generateId, todayISO } from '../../utils/utility-core.js';

export function erstelleAntragsformular(knotenId) {
    const form = document.createElement('form');
    form.innerHTML = `
        <h3>Neuer Antrag</h3>
        <label>Typ:
            <select name="typ">
                <option value="anschaffung">Anschaffung</option>
                <option value="veraenderung">Veränderung</option>
                <option value="goldantrag">Goldantrag</option>
            </select>
        </label>
        <label>Beschreibung:
            <textarea name="beschreibung" required></textarea>
        </label>
        <button type="submit">Antrag stellen</button>
    `;

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = new FormData(form);
        const neuerAntrag = {
            id: generateId(),
            typ: formData.get('typ'),
            beschreibung: formData.get('beschreibung'),
            knotenId,
            status: 'gestellt',
            gestelltAm: todayISO()
        };
        await AntragEngine.speichere(neuerAntrag);
        alert('Antrag gestellt.');
    });

    return form;
}

// --- Datei: Launchweb/ui/antrag/render-antraege.js ---

// render-antraege.js — v1

import { getFarbeFürAntrag } from './colors.js';

export function renderAntragsfaden(antrag) {
    const farbe = getFarbeFürAntrag(antrag);
    const faden = L.polyline([antrag.start, antrag.ziel], {
        color: farbe,
        weight: 3,
        className: antrag.typ === 'goldantrag' ? 'goldrand' : ''
    });
    faden.addTo(window.map); // globale Referenz
}

// --- Datei: Launchweb/ui/antrag/antrag-engine.js ---

// antrag-engine.js — v1

import { Speicher } from '../../data/persistence-service.js';
import { differenceInDays, parseISO } from 'date-fns';

export const AntragEngine = {
    async finde(id) {
        const alle = await Speicher.ladeAlle('antraege');
        return alle.find(a => a.id === id);
    },

    async speichere(antrag) {
        await Speicher.speichere('antraege', antrag);
    },

    async aktualisiereStatus() {
        const antraege = await Speicher.ladeAlle('antraege');
        const heute = new Date();

        for (let a of antraege) {
            const gestellt = parseISO(a.gestelltAm);
            if (a.status === 'gestellt') {
                if (differenceInDays(heute, gestellt) >= 7) {
                    a.status = 'angenommen';
                }
            } else if (a.status === 'einspruch') {
                const einspruch = parseISO(a.einspruchAm);
                if (differenceInDays(heute, einspruch) >= 7) {
                    a.status = 'abgelehnt';
                }
            }
        }

        await Speicher.schreibe('antraege', antraege);
    },

    async einspruchEinlegen(id) {
        const antraege = await Speicher.ladeAlle('antraege');
        const a = antraege.find(e => e.id === id);
        if (a && a.status === 'gestellt') {
            a.status = 'einspruch';
            a.einspruchAm = new Date().toISOString();
        }
        await Speicher.schreibe('antraege', antraege);
    }
};

// --- Datei: Launchweb/ui/antrag/ui-antrag.js ---

// ui-antrag.js — v1

import { AntragEngine } from './antrag-engine.js';
import { renderAntragsfaden } from '../../visual/render-antraege.js';

export function setupAntragUI() {
    document.addEventListener('click', async (e) => {
        if (e.target.matches('[data-antrag-id]')) {
            const id = e.target.dataset.antragId;
            const antrag = await AntragEngine.finde(id);
            if (antrag) {
                renderAntragsfaden(antrag);
            }
        }
    });
}

// --- Datei: Launchweb/ui/diskurs/diskurs-engine.js ---

// diskurs-engine.js — Logik zur Beitragserstellung und Fadenverknüpfung

import { speichereBeitrag } from '../../data/data-diskurs.js';
import { verknuepfeFaden } from '../../core/verblasslogik.js';

export async function hinzufuegenBeitrag(knotenId, autor, text) {
    const beitrag = {
        id: Date.now().toString(),
        knotenId,
        autor,
        text,
        zeitpunkt: new Date().toISOString()
    };

    await speichereBeitrag(beitrag);
    await verknuepfeFaden(autor, knotenId, 'beitrag');
}

// --- Datei: Launchweb/ui/diskurs/diskurs-form.js ---

// diskurs-form.js — Formular zur Erstellung eines Diskursbeitrags

import { hinzufuegenBeitrag } from './diskurs-engine.js';

export function startBeitragFormular(knotenId) {
    const html = `
        <form id="diskurs-eingabe">
            <input type="text" id="autor" placeholder="Dein Name" required />
            <textarea id="text" placeholder="Dein Beitrag" required></textarea>
            <button type="submit">Absenden</button>
        </form>
    `;

    const ziel = document.getElementById('diskurs-formular');
    if (ziel) ziel.innerHTML = html;

    const form = document.getElementById('diskurs-eingabe');
    if (form) {
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const autor = form.querySelector('#autor').value;
            const text = form.querySelector('#text').value;
            await hinzufuegenBeitrag(knotenId, autor, text);
            form.reset();
        });
    }
}

// --- Datei: Launchweb/ui/diskurs/ui-diskurs.js ---

// ui-diskurs.js — Anzeige des Gesprächsverlaufs innerhalb eines Knotens

import { getBeitraegeFuerKnoten } from '../../data/data-diskurs.js';
import { startBeitragFormular } from './diskurs-form.js';

export function zeigeDiskurs(knotenId) {
    const beitraege = getBeitraegeFuerKnoten(knotenId);

    const html = `
        <div class="diskurs-header">
            <h3>Gespräch zum Knoten</h3>
            <button id="beitrag-hinzufuegen">Beitrag verfassen</button>
        </div>
        <ul class="diskurs-liste">
            ${beitraege.map(b => `<li><strong>${b.autor}:</strong> ${b.text}</li>`).join('')}
        </ul>
        <div id="diskurs-formular"></div>
    `;

    const container = document.getElementById('diskurs-container');
    if (container) container.innerHTML = html;

    document.getElementById('beitrag-hinzufuegen')?.addEventListener('click', () => {
        startBeitragFormular(knotenId);
    });
}

// --- Datei: Launchweb/ui/layer/ui-layer-toggle.js ---

// ui-layer-toggle.js — Version: Σ.v1.layer.ui.toggle

export function setupLayerToggle(layerManager) {
    const container = document.getElementById('layer-controls');
    if (!container) return;

    const layerLabels = {
        knoten: 'Knoten',
        faeden: 'Fäden',
        garne: 'Garne',
        antraege: 'Anträge',
        webkasse: 'Webkasse'
    };

    Object.keys(layerLabels).forEach(layerKey => {
        const label = document.createElement('label');
        label.classList.add('layer-toggle-label');

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = layerManager.isLayerVisible(layerKey);
        checkbox.addEventListener('change', () => {
            layerManager.setLayerVisibility(layerKey, checkbox.checked);
        });

        label.appendChild(checkbox);
        label.append(` ${layerLabels[layerKey]}`);
        container.appendChild(label);
    });
}

// --- Datei: Launchweb/ui/layer/ui-layer-advanced.js ---

// ui-layer-advanced.js — Version: Σ.v1.adapted-to-toggle

export function setupLayerControls(layerManager) {
    const controlContainer = document.getElementById('layer-controls');
    if (!controlContainer) return;

    const layerNames = layerManager.getLayerNames();

    layerNames.forEach(layerName => {
        const label = document.createElement('label');
        label.textContent = ` ${layerName}`;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = layerManager.isLayerActive(layerName);

        checkbox.addEventListener('change', () => {
            layerManager.toggleLayer(layerName);
            // optional: trigger Map-Neurender
        });

        label.prepend(checkbox);
        controlContainer.appendChild(label);
    });
}

// --- Datei: Launchweb/ui/extras/ui-naehstuebchen.js ---

// ui-naehstuebchen.js — v1

import { diskursEngine } from '../diskurs/diskurs-engine.js';
import { uiDiskursFenster } from '../diskurs/ui-diskurs.js';

export function öffneNaehstuebchen() {
    const fenster = uiDiskursFenster.erzeuge('naehstuebchen');
    diskursEngine.öffneRaum('naehstuebchen', fenster);
}

// --- Datei: Launchweb/ui/extras/zeitleiste.js ---

// zeitleiste.js — v1

import { renderKnoten } from '../../visual/render-knoten.js';
import { renderFaeden } from '../../visual/render-faeden.js';

export const zeitleiste = {
    alleDaten: [],
    aktuelleZeit: null,

    init(data) {
        this.alleDaten = data;
    },

    zeigeTag(tagIndex) {
        const tag = this.alleDaten[tagIndex];
        if (!tag) return;
        this.aktuelleZeit = tag.datum;
        renderKnoten(tag.knoten);
        renderFaeden(tag.faeden);
    }
};

// --- Datei: Launchweb/ui/extras/ui-webrat.js ---

// ui-webrat.js — v1

import { diskursEngine } from '../diskurs/diskurs-engine.js';
import { uiDiskursFenster } from '../diskurs/ui-diskurs.js';

export function öffneWebrat() {
    const fenster = uiDiskursFenster.erzeuge('webrat');
    diskursEngine.öffneRaum('webrat', fenster);
}

// --- Datei: Launchweb/ui/extras/ui-zeitreise.js ---

// ui-zeitreise.js — v1

import { zeitleiste } from './zeitleiste.js';

export function setupZeitreiseUI() {
    const controls = document.getElementById('zeitreise-controls');
    const startBtn = controls.querySelector('#start-zeitreise');
    const stopBtn = controls.querySelector('#stop-zeitreise');
    const slider = controls.querySelector('#zeitreise-slider');

    let interval = null;

    startBtn.addEventListener('click', () => {
        let tag = parseInt(slider.value, 10);
        interval = setInterval(() => {
            zeitleiste.zeigeTag(tag++);
            slider.value = tag;
        }, 1000);
    });

    stopBtn.addEventListener('click', () => {
        clearInterval(interval);
        interval = null;
    });

    slider.addEventListener('input', () => {
        zeitleiste.zeigeTag(parseInt(slider.value, 10));
    });
}

// --- Datei: Launchweb/core/manifest.js ---

// manifest.js — Version: Σ.v1.systembegriffe

export const Typen = {
    webung: {
        faden: 'faden',
        garn: 'garn',
        antrag: 'antrag'
    },

    antrag: {
        gold: 'gold',
        veraenderung: 'veraenderung',
        anschaffung: 'anschaffung'
    },

    status: {
        aktiv: 'aktiv',
        verblasst: 'verblasst',
        angenommen: 'angenommen',
        abgelehnt: 'abgelehnt',
        einspruch: 'einspruch'
    }
};

// --- Datei: Launchweb/core/zeitlogik.js ---

// zeitlogik.js — Version: Σ.v1.verblassung

export const Zeitlogik = {
    verblassungsTage: 7,

    istVerblassend(webung, jetzt = new Date()) {
        if (!webung.verblasstAm) return false;
        return new Date(webung.verblasstAm) < jetzt;
    },

    berechneVerblassung(typ, ereigniszeitpunkt = null) {
        const basis = ereigniszeitpunkt
            ? new Date(ereigniszeitpunkt)
            : new Date();

        if (typ === 'garn') return null; // bleibt permanent
        const verblass = new Date(basis);
        verblass.setDate(verblass.getDate() + Zeitlogik.verblassungsTage);
        return verblass.toISOString();
    }
};

// --- Datei: Launchweb/core/knotenerkennung.js ---

// knotenerkennung.js — Version: Σ.v1.knotenlogik

import { Knoten } from '../models/knotenmodell.js';
import { generateUUID } from '../utils.js';

export class Knotenerkennung {
    static erstelleKnoten({ koordinaten, erstellerId, beschreibung, typ = "standard", darstellung = "default" }) {
        const neuerKnoten = new Knoten({
            id: generateUUID(),
            koordinaten,
            erstellerId,
            beschreibung,
            typ,
            darstellung
        });

        return neuerKnoten;
    }

    static loescheWennVerwaist(knoten, webungListe) {
        const aktiveVerbindungen = webungListe.filter(w => w.zuKnotenId === knoten.id && w.zustand === 'aktiv');
        return aktiveVerbindungen.length === 0;
    }
}

// --- Datei: Launchweb/core/verblasslogik.js ---

// core/verblasslogik.js — Version: Σ.v2.fadenverfall.vollständig

import { parseISO, differenceInDays } from 'date-fns';

export class Verblasslogik {
    static pruefeVerblassen(webung, knotenHatEreigniszeitpunkt = false) {
        const erstellt = parseISO(webung.entstandenAm);
        const now = new Date();
        const tageVergangen = differenceInDays(now, erstellt);

        if (webung.typ === 'garn') return false;

        // Wenn ein Ereigniszeitpunkt existiert, zählt ab diesem + 7 Tage
        return tageVergangen > 7;
    }

    static setzeVerblasstStatus(webung, knotenHatEreigniszeitpunkt = false) {
        if (this.pruefeVerblassen(webung, knotenHatEreigniszeitpunkt)) {
            webung.zustand = 'verblasst';
        }
    }

    static tageBisVerblassen(webung, knotenHatEreigniszeitpunkt = false) {
        const erstellt = parseISO(webung.entstandenAm);
        const now = new Date();
        const verbleibend = 7 - differenceInDays(now, erstellt);
        return Math.max(0, verbleibend);
    }

    static istVerblasst(webung) {
        return webung.zustand === 'verblasst';
    }
}

// --- Datei: Launchweb/core/antragszyklus.js ---

// antragslogik.js — Version: Σ.v1.antragszyklus

import { parseISO, differenceInDays } from 'date-fns';

export class Antragslogik {
    static pruefeEntscheidung(antrag, einspruchsDatum = null) {
        const erstellt = parseISO(antrag.entstandenAm);
        const now = new Date();

        if (antrag.zustand !== 'aktiv') return;

        if (!einspruchsDatum) {
            const tage = differenceInDays(now, erstellt);
            if (tage >= 7) {
                antrag.zustand = 'angenommen';
                antrag.farbsignal = 'grün';
            }
        } else {
            const einspruch = parseISO(einspruchsDatum);
            const tageNachEinspruch = differenceInDays(now, einspruch);
            if (tageNachEinspruch >= 7) {
                antrag.zustand = 'abgelehnt';
                antrag.farbsignal = 'rot';
            }
        }
    }

    static initialisiereAntrag(antrag) {
        antrag.farbsignal = 'blau';
    }

    static markiereEinspruch(antrag) {
        antrag.farbsignal = 'lila';
    }

    static kennzeichneGoldantrag(antrag) {
        antrag.goldrand = true;
    }
}

// --- Datei: Launchweb/core/webung-engine.js ---

// webungsengine.js — Version: Σ.v1.core

import { Rolle } from './rolle.js';
import { Faden } from './fadenmodell.js';
import { Knoten } from './knoten-modell.js';
import { Verblasslogik } from './verblasslogik.js';
import { Knotenerkennung } from './knotenerkennung.js';
import { persistenceService } from './persistence-service.js';
import { WebSocketServiceSingleton as ws } from './websocket-service.js';

export const WebungsEngine = {
    async neueWebung({ rollenId, koordinaten, inhalt, typ = 'faden', optional = {} }) {
        const rolle = await persistenceService.find('rollen', rollenId);
        if (!rolle) throw new Error('Rolle nicht gefunden');

        // 1. Knoten prüfen oder erzeugen
        let knoten = await Knotenerkennung.findeOderErzeugeKnoten(koordinaten, inhalt);

        // 2. Webung erzeugen
        const webung = new Faden({
            rolleId: rollenId,
            knotenId: knoten.id,
            typ,
            inhalt,
            ...optional
        });

        // 3. Verknüpfen
        rolle.webungen.push(webung.id);
        knoten.webungen.push(webung.id);

        // 4. Verblasslogik anwenden
        Verblasslogik.setzeVerblasstStatus(webung);

        // 5. Speichern
        await persistenceService.save('rollen', rolle);
        await persistenceService.save('knoten', knoten);
        await persistenceService.save('webungen', webung);

        // 6. WebSocket-Broadcast
        ws.send({ type: 'webung_neu', payload: { webungId: webung.id } });

        return webung;
    },

    async prüfeVerblassungFürAlle() {
        const webungen = await persistenceService.getAll('webungen');
        const knotenMap = await persistenceService.getMap('knoten');

        for (const webung of webungen) {
            const knoten = knotenMap[webung.knotenId];
            Verblasslogik.setzeVerblasstStatus(webung, !!knoten?.ereigniszeitpunkt);
            await persistenceService.save('webungen', webung);
        }
    }
};

// --- Datei: Launchweb/utils/utility-tooltip.js ---

// utility-tooltip.js — Version: Σ.v1.tooltip.system

export function createTooltip(content, position) {
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    tooltip.innerText = content;
    tooltip.style.top = `${position.y}px`;
    tooltip.style.left = `${position.x}px`;
    document.body.appendChild(tooltip);
    return tooltip;
}

export function removeTooltip() {
    const tooltips = document.querySelectorAll('.tooltip');
    tooltips.forEach(t => t.remove());
}

// --- Datei: Launchweb/utils/validation.js ---

// validation.js — Version: Σ.v1.form.validation

export const Validators = {
    required(value) {
        return value?.trim() ? null : 'Pflichtfeld';
    },

    minLength(min) {
        return (value) => {
            return value.length >= min ? null : `Mindestens ${min} Zeichen`;
        };
    },

    isNumber(value) {
        return isNaN(value) ? 'Muss eine Zahl sein' : null;
    }
};

// --- Datei: Launchweb/utils/utility-core.js ---

// utility-core.js — Version: Σ.v1.core.util

export const UtilityCore = {
    generateUUID() {
        return crypto.randomUUID();
    },

    formatDate(date) {
        return new Intl.DateTimeFormat('de-DE', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        }).format(new Date(date));
    },

    clone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
};

// --- Datei: Launchweb/utils/form-components.js ---

// form-components.js — Version: Σ.v1.formteile

export function createInputField({ id, label, type = 'text', placeholder = '', value = '' }) {
    const wrapper = document.createElement('div');
    const labelEl = document.createElement('label');
    labelEl.setAttribute('for', id);
    labelEl.textContent = label;

    const input = document.createElement('input');
    input.type = type;
    input.id = id;
    input.placeholder = placeholder;
    input.value = value;

    wrapper.appendChild(labelEl);
    wrapper.appendChild(input);
    return wrapper;
}

export function createSelect({ id, label, options }) {
    const wrapper = document.createElement('div');
    const labelEl = document.createElement('label');
    labelEl.setAttribute('for', id);
    labelEl.textContent = label;

    const select = document.createElement('select');
    select.id = id;

    options.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.label;
        select.appendChild(option);
    });

    wrapper.appendChild(labelEl);
    wrapper.appendChild(select);
    return wrapper;
}

// --- Datei: Launchweb/utils/utils.js ---

// utils.js — Version: Σ.v1.misc.tools

export function debounce(fn, delay) {
    let timer = null;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), delay);
    };
}

export function throttle(fn, limit) {
    let inThrottle;
    return function (...args) {
        if (!inThrottle) {
            fn(...args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
        }
    };
}

// --- Datei: Launchweb/models/webung.js ---

// fadenmodell.js — Version: Σ.v1.fadenstruktur

export class Webung {
    constructor({ id, typ = "faden", vonRolleId, zuKnotenId }) {
        this.id = id;
        this.typ = typ; // "faden", "garn", "antrag", "goldantrag"
        this.vonRolleId = vonRolleId;
        this.zuKnotenId = zuKnotenId;
        this.entstandenAm = new Date().toISOString();
        this.zustand = "aktiv"; // oder "verblasst", "abgelehnt", "angenommen"
        this.farbsignal = null; // z. B. "blau", "lila", "grün", "rot", "goldrand"
    }
}

// --- Datei: Launchweb/models/user-model.js ---

// models/user-model.js — Version: Σ.v1.rolle.core

export const rolleService = {
    rolleId: null,

    set(id) {
        this.rolleId = id;
        localStorage.setItem('rolleId', id);
    },

    get() {
        return this.rolleId || localStorage.getItem('rolleId');
    },

    restore() {
        this.rolleId = localStorage.getItem('rolleId');
    }
};

// --- Datei: Launchweb/models/knotentypen.js ---

// models/knotentypen.js — Definition symbolischer Knotentypen

export const Knotentypen = {
    standard: {
        farbe: '#7F8C8D',
        symbol: '●',
        beschreibung: 'Standardknoten ohne Spezifizierung'
    },
    goldantrag: {
        farbe: '#F1C40F',
        symbol: '◎',
        beschreibung: 'Geldantrag in der Webkasse'
    },
    zusage: {
        farbe: '#2ECC71',
        symbol: '✓',
        beschreibung: 'Verbindliche Zusage (Garn)'
    },
    faden: {
        farbe: '#3498DB',
        symbol: '➝',
        beschreibung: 'Temporäre Beteiligung (Faden)'
    },
    einspruch: {
        farbe: '#9B59B6',
        symbol: '⚠️',
        beschreibung: 'Einspruch gegen Antrag'
    },
    abgelehnt: {
        farbe: '#E74C3C',
        symbol: '✗',
        beschreibung: 'Abgelehnter Antrag'
    },
    angenommen: {
        farbe: '#27AE60',
        symbol: '✓',
        beschreibung: 'Angenommener Antrag'
    }
};

// --- Datei: Launchweb/visuals/render-garne.js ---

// visual/render-garne.js — Version: Σ.v∞.garn.verbindung.symbolisch

import * as d3 from 'd3';
import { Farben } from './colors.js';

/**
 * Zeichnet dauerhafte Garnverbindungen zwischen Knoten (z. B. durch Zusagen)
 */
export function renderGarne(svg, projection, daten) {
  const garne = daten.filter(w => w.typ === 'garn' && w.zustand !== 'verblasst');

  const verbindungen = svg.selectAll('.garn').data(garne, d => d.id);
  verbindungen.exit().remove();

  const neu = verbindungen.enter()
    .append('path')
    .attr('class', 'garn');

  neu.merge(verbindungen)
    .attr('d', d => {
      const [x1, y1] = projection([d.quelle.lng, d.quelle.lat]);
      const [x2, y2] = projection([d.ziel.lng, d.ziel.lat]);
      return `M${x1},${y1} L${x2},${y2}`;
    })
    .attr('stroke', d => {
      const farbe = Farben.garn[d.zustand] || Farben.garn.zusage;
      return farbe;
    })
    .attr('stroke-width', d => 3 + (d.intensität || 0))
    .attr('stroke-dasharray', '1,3') // Zwirn-Stil
    .attr('opacity', 0.9)
    .attr('fill', 'none');
}

// --- Datei: Launchweb/visuals/render-webkasse.js ---

// visual/render-webkasse.js — Version: Σ.v∞.symbol.gold.circle

import { Farben } from './colors.js';

/**
 * Zeichnet die kollektive Webkasse als Kreis mit Goldfarbe
 */
export function renderWebkasse(selection, projection, data, showTooltip, hideTooltip) {
  const pos = projection({ lat: 53.56, lng: 10.03 }); // feste Position
  const stand = data.webkasse?.kontostand || 0;
  const radius = Math.sqrt(stand) * 0.05 + 10;

  const topf = selection.selectAll('.webkasse').data([stand]);

  topf.enter()
    .append('circle')
    .attr('class', 'webkasse')
    .merge(topf)
    .attr('cx', pos.x)
    .attr('cy', pos.y)
    .attr('r', radius)
    .attr('fill', Farben.webkasse)
    .attr('fill-opacity', 0.8)
    .attr('stroke', '#222')
    .attr('stroke-width', 1.5)
    .on('mouseover', e => showTooltip(`Webkasse: ${stand.toFixed(2)} €`, e.pageX, e.pageY))
    .on('mouseout', hideTooltip);

  topf.exit().remove();
}

// --- Datei: Launchweb/visuals/render-base.js ---

// render-base.js — Version: Σ.v∞.style.core

export const RenderBase = {
    fadenStyle(farbe, dicke = 2, transparenz = 0.5) {
        return {
            stroke: farbe,
            'stroke-width': dicke,
            'stroke-opacity': transparenz,
            fill: 'none'
        };
    },
    garnStyle(farbe) {
        return {
            stroke: farbe,
            'stroke-dasharray': '5,2',
            'stroke-width': 3,
            'stroke-opacity': 0.9,
            fill: 'none'
        };
    },
    antragRandStyle(farbe) {
        return {
            stroke: farbe,
            'stroke-width': 3,
            fill: 'none'
        };
    }
};

// --- Datei: Launchweb/visuals/render-antraege.js ---

// visual/render-antraege.js — Version: Σ.v∞.antrag.statusfarben.klar

import * as d3 from 'd3';
import { Farben } from './colors.js';

/**
 * Zeichnet alle Anträge mit Farbcodierung je nach Status
 */
export function renderAntraege(svg, projection, daten) {
  const antraege = daten.filter(w => w.typ === 'antrag' && w.zustand !== 'verblasst');

  const verbindungen = svg.selectAll('.antrag')
    .data(antraege, d => d.id);

  verbindungen.exit().remove();

  const neu = verbindungen.enter()
    .append('path')
    .attr('class', 'antrag');

  neu.merge(verbindungen)
    .attr('d', d => {
      const [x1, y1] = projection([d.quelle.lng, d.quelle.lat]);
      const [x2, y2] = projection([d.ziel.lng, d.ziel.lat]);
      return `M${x1},${y1} L${x2},${y2}`;
    })
    .attr('stroke', d => Farben.antrag[d.status] || Farben.antrag.gestellt)
    .attr('stroke-width', 3)
    .attr('stroke-dasharray', '2,4')
    .attr('opacity', 0.9)
    .attr('fill', 'none')
    .attr('filter', d => d.kategorie === 'goldantrag' ? 'url(#goldrand)' : null);
}

// --- Datei: Launchweb/visuals/colors.js ---

// visual/colors.js – Version: Σ.v2.klare-farben

export const Farben = {
  // Fäden
  faden: {
    wortbeitrag: '#888',
    antrag: '#0077cc',
    einspruch: '#8e44ad',
    angenommen: '#27ae60',
    abgelehnt: '#c0392b',
    verblasst: '#ccc'
  },

  // Garne
  garn: {
    zusage: '#d35400',
    vergangen: '#95a5a6'
  },

  // Knoten
  knoten: {
    standard: '#000',
    individuell: '#444'
  },

  // Anträge mit Goldrand
  rand: {
    gold: '#ffd700'
  },

  // UI / Hilfselemente
  ui: {
    highlight: '#f39c12',
    hintergrund: '#fefefe'
  }
};

// --- Datei: Launchweb/visuals/render-faeden.js ---

// visual/render-faeden.js — Version: Σ.v∞.faeden.typisiert

import { select } from 'd3-selection';
import { Farben } from './colors.js';
import { SystemMeta } from '../system-meta.js';

/**
 * Zeichnet temporäre Verbindungen („Fäden“) z. B. Wortbeiträge, Anträge etc.
 */
export function renderFaeden(svg, projection, daten) {
  if (!SystemMeta.istLayerAktiv('faeden')) return;

  const faeden = daten.webungen.filter(w => w.typ === 'faden' && w.zustand !== 'verblasst');

  const layer = svg.selectAll('.faden').data(faeden, d => d.id);

  layer.enter()
    .append('line')
    .attr('class', 'faden')
    .attr('x1', d => projection(d.von)[0])
    .attr('y1', d => projection(d.von)[1])
    .attr('x2', d => projection(d.zu)[0])
    .attr('y2', d => projection(d.zu)[1])
    .style('stroke', d => Farben.faden[d.subtyp] || Farben.faden.wortbeitrag)
    .style('stroke-width', d => Math.max(1, d.stärke || 1))
    .style('opacity', d => d.transparenz || 0.4);

  layer.exit().remove();
}

// --- Datei: Launchweb/visuals/render-knoten.js ---

// render-knoten.js — Version: Σ.v∞.svg.symbol.farbenbasiert

import { Farben } from './colors.js';

export function renderKnoten(selection, projection, bounds, data, showTooltip, hideTooltip) {
  const getLatLng = e =>
    Array.isArray(e.koordinaten)
      ? [e.koordinaten[0], e.koordinaten[1]]
      : [e.koordinaten.lat, e.koordinaten.lng];

  const visible = data.knoten.filter(e => bounds.contains(getLatLng(e)));

  const groups = selection.selectAll('.knoten').data(visible, d => d.id);

  const enter = groups.enter().append('g').attr('class', 'knoten');

  enter.merge(groups)
    .attr('transform', d => {
      const [lat, lng] = getLatLng(d);
      const p = projection({ lat, lng });
      return `translate(${p.x},${p.y})`;
    })
    .each(function (d) {
      const g = d3.select(this);
      const r = d.typ === 'person' ? 10 : 12;
      const fill = Farben.knoten[d.typ] || Farben.knoten.standard;

      g.selectAll('circle')
        .data([d])
        .join('circle')
        .attr('r', r)
        .attr('fill', fill)
        .attr('stroke', '#000')
        .attr('stroke-width', 1.5);

      g.on('mouseover', e => showTooltip(d.titel || 'Knoten', e.pageX, e.pageY))
       .on('mouseout', hideTooltip);
    });

  groups.exit().remove();
}

// --- Datei: Launchweb/visuals/render-fadenlegende.js ---

// render-fadenlegende.js — Version: Σ.v1.fadenlegende

import * as d3 from 'd3';
import { FADENFARBEN, FADENSTILE } from './colors.js';

export function renderFadenlegende(containerId) {
    const fadenTypen = [
        { label: 'Gesprächsbeitrag', farbe: FADENFARBEN.gespräch, stil: FADENSTILE.normal },
        { label: 'Gesprächseröffnung', farbe: FADENFARBEN.gesprächStart, stil: FADENSTILE.normal },
        { label: 'Zusage (Garn)', farbe: FADENFARBEN.garn, stil: FADENSTILE.garn },
        { label: 'Antrag', farbe: FADENFARBEN.antrag, stil: FADENSTILE.normal },
        { label: 'Einspruch', farbe: FADENFARBEN.einspruch, stil: FADENSTILE.normal },
        { label: 'Abgelehnt', farbe: FADENFARBEN.abgelehnt, stil: FADENSTILE.normal },
        { label: 'Angenommen', farbe: FADENFARBEN.angenommen, stil: FADENSTILE.normal },
        { label: 'Goldantrag', farbe: FADENFARBEN.antrag, stil: FADENSTILE.gold },
        { label: 'Vergangen', farbe: FADENFARBEN.vergangen, stil: FADENSTILE.verblassend }
    ];

    const container = d3.select(`#${containerId}`);
    container.html(''); // Reset

    const svg = container.append('svg')
        .attr('width', 300)
        .attr('height', fadenTypen.length * 30);

    const einträge = svg.selectAll('g')
        .data(fadenTypen)
        .enter()
        .append('g')
        .attr('transform', (_, i) => `translate(10, ${i * 30 + 10})`);

    einträge.append('line')
        .attr('x1', 0)
        .attr('y1', 5)
        .attr('x2', 60)
        .attr('y2', 5)
        .attr('stroke', d => d.farbe)
        .attr('stroke-width', d => d.stil === 'garn' ? 4 : 2)
        .attr('stroke-dasharray', d => d.stil === 'verblassend' ? '2,2' : (d.stil === 'gold' ? '4,1' : ''))
        .attr('opacity', d => d.stil === 'verblassend' ? 0.3 : 1);

    einträge.append('text')
        .attr('x', 70)
        .attr('y', 9)
        .text(d => d.label)
        .attr('font-size', '12px')
        .attr('fill', '#333');
}

// --- Datei: Launchweb/data/persistence-services.server.js ---

// persistence-service.server.js — Version: Σ.server.fs

import fs from 'fs/promises';
import path from 'path';

export const PersistenceServer = {
    basePath: './weltweberei-data',

    async ensureDir() {
        await fs.mkdir(this.basePath, { recursive: true });
    },

    filePath(name) {
        return path.join(this.basePath, `${name}.json`);
    },

    async loadAll(name) {
        try {
            const content = await fs.readFile(this.filePath(name), 'utf-8');
            return JSON.parse(content);
        } catch (err) {
            if (err.code === 'ENOENT') return [];
            throw err;
        }
    },

    async write(name, data) {
        await this.ensureDir();
        await fs.writeFile(this.filePath(name), JSON.stringify(data, null, 2));
    },

    async store(name, entry) {
        const data = await this.loadAll(name);
        data.push(entry);
        await this.write(name, data);
    },

    async delete(name, id) {
        const data = await this.loadAll(name);
        const filtered = data.filter(e => e.id !== id);
        await this.write(name, filtered);
    }
};

// --- Datei: Launchweb/data/data-model.js ---

// data-model.js — Version: Σ.v1.modelstruktur

export const Model = {
    webung: {
        id: null,
        vonRollenId: null,
        typ: 'faden' | 'garn' | 'antrag',
        zuKnotenId: null,
        text: '',
        erstelltAm: null,
        verblasstAm: null,
        farbe: '', // optisch gesteuert über Typ & Status
        status: '', // aktiv | verblasst | angenommen | abgelehnt
    },

    knoten: {
        id: null,
        erstelltVon: null,
        erstelltAm: null,
        koordinaten: { lat: 0, lng: 0 },
        text: '',
        visual: 'knotenstandard',
        ereigniszeitpunkt: null // optional
    },

    antrag: {
        id: null,
        vonRollenId: null,
        knotenId: null,
        gestelltAm: null,
        typ: '', // 'gold' | 'veränderung' | 'anschaffung'
        text: '',
        status: 'offen' | 'einspruch' | 'abgelehnt' | 'angenommen',
        einspruchsDatum: null,
        entscheidungsDatum: null
    },

    rolle: {
        id: null,
        name: '',
        wohnort: { lat: 0, lng: 0 }
    }
};

// --- Datei: Launchweb/data/data-finanz.js ---

// data/data-finanz.js — Version: Σ.v∞.1.webkasse.core

import { generateUID } from '../utils.js';

let webkasse = {
    kontostand: 0,
    buchungen: [] // { id, betrag, von, zweck, zeitpunkt, quelle }
};

// Buchungstypen: spende, zusage, auszahlung, umbuchung, goldfaden

export function aktuelleWebkasse() {
    return {
        kontostand: webkasse.kontostand,
        buchungen: [...webkasse.buchungen]
    };
}

export function fuegeBuchungHinzu({ betrag, von, zweck, quelle = 'unbekannt' }) {
    const buchung = {
        id: generateUID(),
        betrag,
        von,
        zweck,
        quelle,
        zeitpunkt: new Date().toISOString()
    };
    webkasse.buchungen.push(buchung);
    webkasse.kontostand += betrag;
    return buchung;
}

export function macheAuszahlung({ betrag, an, zweck = 'auszahlung' }) {
    if (webkasse.kontostand >= betrag) {
        return fuegeBuchungHinzu({ betrag: -betrag, von: 'webkasse', zweck, quelle: 'auszahlung:' + an });
    } else {
        throw new Error("Nicht genügend Mittel in der Webkasse");
    }
}

export function filtereBuchungen(filterFn) {
    return webkasse.buchungen.filter(filterFn);
}

export function resetWebkasse() {
    webkasse = {
        kontostand: 0,
        buchungen: []
    };
}

// --- Datei: Launchweb/data/data-diskurs.js ---

// data/data-diskurs.js — Version: Σ.v2.diskursstruktur.raumgestützt

export const diskursData = {
    räume: [], // Jeder Raum: { id, typ, referenzId, gespräche: [ { id, beitrag, typ, autor, zeit } ] }

    addRaum(raum) {
        this.räume.push(raum);
    },

    findRaum(id) {
        return this.räume.find(r => r.id === id);
    },

    addGespräch(raumId, gespräch) {
        const raum = this.findRaum(raumId);
        if (raum) {
            raum.gespräche.push(gespräch);
        }
    },

    getGespräche(raumId) {
        const raum = this.findRaum(raumId);
        return raum ? raum.gespräche : [];
    },

    getGesprächeMitTyp(raumId, typ) {
        const raum = this.findRaum(raumId);
        return raum ? raum.gespräche.filter(g => g.typ === typ) : [];
    },

    deleteGespräch(raumId, gesprächId) {
        const raum = this.findRaum(raumId);
        if (raum) {
            raum.gespräche = raum.gespräche.filter(g => g.id !== gesprächId);
        }
    },

    deleteRaum(id) {
        this.räume = this.räume.filter(r => r.id !== id);
    },

    getAlleRäume() {
        return this.räume;
    }
};

// --- Datei: Launchweb/data/persistence-services.client.js ---

// persistence-service.client.js — Version: Σ.client.localStorage

export const PersistenceClient = {
    loadAll(key) {
        const raw = localStorage.getItem(key);
        return raw ? JSON.parse(raw) : [];
    },

    save(key, data) {
        localStorage.setItem(key, JSON.stringify(data));
    },

    store(key, entry) {
        const data = this.loadAll(key);
        data.push(entry);
        this.save(key, data);
    },

    delete(key, id) {
        const data = this.loadAll(key).filter(e => e.id !== id);
        this.save(key, data);
    },

    clear(key) {
        localStorage.removeItem(key);
    }
};

// --- Datei: Launchweb/data/data-knoten.js ---

// data/data-knoten.js — Version: Σ.v∞.1.knotenstruktur.core

import { generateUID } from '../utils.js';

const knotenStore = [];

export function createKnoten({ titel, beschreibung, koordinaten, erstellerId, zeitpunkt = null, typ = 'allgemein' }) {
    const neuerKnoten = {
        id: generateUID(),
        titel,
        beschreibung,
        koordinaten,
        erstellerId,
        zeitpunkt,
        typ,
        erstelltAm: new Date().toISOString(),
        verbunden: [],
        aktiv: true
    };
    knotenStore.push(neuerKnoten);
    return neuerKnoten;
}

export function getAlleKnoten() {
    return knotenStore.filter(k => k.aktiv);
}

export function findeKnotenNachId(knotenId) {
    return knotenStore.find(k => k.id === knotenId && k.aktiv);
}

export function verknuepfeMitKnoten(knotenId, webungId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten && !knoten.verbunden.includes(webungId)) {
        knoten.verbunden.push(webungId);
    }
}

export function entferneVerknuepfung(knotenId, webungId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten) {
        knoten.verbunden = knoten.verbunden.filter(id => id !== webungId);
        if (knoten.verbunden.length === 0) {
            knoten.aktiv = false;
        }
    }
}

export function loescheKnoten(knotenId) {
    const knoten = findeKnotenNachId(knotenId);
    if (knoten) {
        knoten.aktiv = false;
    }
}

// --- Datei: Launchweb/data/persistence-services.js ---

// persistence-service.js — Version: Σ.v2.contextaware

let speicher;

if (typeof window !== 'undefined' && window.localStorage) {
    // Client-basiert
    import('./persistence-service.client.js').then(mod => {
        speicher = mod.Speicher;
    });
} else {
    // Server-basiert (Node.js)
    import('./persistence-service.server.js').then(mod => {
        speicher = mod.Speicher;
    });
}

// Async-Wartefunktion, bis das Modul geladen ist
async function bereitstellen() {
    if (!speicher) {
        await new Promise(resolve => setTimeout(resolve, 10)); // minimal warten
        return bereitstellen(); // rekursiv warten
    }
    return speicher;
}

// Exporte als Proxy-Funktionen
export const Speicher = {
    async ladeAlle(name) {
        const s = await bereitstellen();
        return s.ladeAlle(name);
    },

    async schreibe(name, daten) {
        const s = await bereitstellen();
        return s.schreibe(name, daten);
    },

    async speichere(name, eintrag) {
        const s = await bereitstellen();
        return s.speichere(name, eintrag);
    },

    async loesche(name, id) {
        const s = await bereitstellen();
        return s.loesche(name, id);
    }
};

// --- Datei: Launchweb/services/api-knoten.js ---

// api-knoten.js — Version: Σ.v1.knotenservice

import { Knotenerkennung } from '../core/knotenerkennung.js';
import { Speicher } from './persistence-service.js';

export const apiKnoten = {
    async erstelleKnoten(daten) {
        const knoten = Knotenerkennung.erstelleKnoten(daten);
        await Speicher.speichere('knoten', knoten);
        return knoten;
    },

    async pruefeUndLoescheVerwaiste() {
        const knotenListe = await Speicher.ladeAlle('knoten');
        const webungen = await Speicher.ladeAlle('webung');

        const geloeschte = [];

        for (const k of knotenListe) {
            if (Knotenerkennung.loescheWennVerwaist(k, webungen)) {
                await Speicher.loesche('knoten', k.id);
                geloeschte.push(k.id);
            }
        }

        return geloeschte;
    }
};

// --- Datei: Launchweb/services/api-verblassen.js ---

// api-verblassen.js — Version: Σ.v1.verblass-service

import { Verblasslogik } from '../core/verblasslogik.js';
import { Speicher } from './persistence-service.js';

export const apiVerblassen = {
    async verblasseAlle() {
        const webungen = await Speicher.ladeAlle('webung');
        const knotenListe = await Speicher.ladeAlle('knoten');

        for (const w of webungen) {
            const knoten = knotenListe.find(k => k.id === w.zuKnotenId);
            Verblasslogik.setzeVerblasstStatus(w, knoten?.ereigniszeitpunkt);
        }

        await Speicher.schreibe('webung', webungen);
    }
};

// --- Datei: Launchweb/services/api-webung.js ---

// api-webung.js — Version: Σ.v1.api

import express from 'express';
import { WebungsEngine } from './webungsengine.js';
import { persistenceService } from './persistence-service.js';

export const webungApi = express.Router();

webungApi.post('/webung', async (req, res) => {
    try {
        const newWebung = await WebungsEngine.neueWebung(req.body);
        res.status(201).json(newWebung);
    } catch (err) {
        res.status(400).json({ error: err.message });
    }
});

webungApi.get('/webungen', async (req, res) => {
    const webungen = await persistenceService.getAll('webungen');
    res.json(webungen);
});

// --- Datei: Launchweb/services/auth-service.js ---

// services/auth-service.js — v1

let eingeloggterWeber = null;

export const AuthService = {
    login(userId, name, wohnort) {
        eingeloggterWeber = { id: userId, name, wohnort };
    },
    logout() {
        eingeloggterWeber = null;
    },
    getUser() {
        return eingeloggterWeber;
    },
    isLoggedIn() {
        return !!eingeloggterWeber;
    }
};

// --- Datei: Launchweb/services/websocket-service.js ---

// services/websocket-service.js — v1

class WebSocketService {
    constructor(url) {
        this.url = url;
        this.socket = null;
        this.listeners = new Set();
    }

    connect() {
        if (this.socket) return;

        this.socket = new WebSocket(this.url);

        this.socket.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            this.listeners.forEach(fn => fn(msg));
        };

        this.socket.onopen = () => {
            console.log('WebSocket verbunden');
        };

        this.socket.onclose = () => {
            this.socket = null;
            setTimeout(() => this.connect(), 1000);
        };

        this.socket.onerror = () => {
            this.socket?.close();
        };
    }

    send(msg) {
        if (this.socket?.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify(msg));
        }
    }

    subscribe(fn) {
        this.listeners.add(fn);
    }
}

export const WebSocketServiceInstance = new WebSocketService('ws://localhost:8080');

// --- Datei: Launchweb/services/api-antrag.js ---

// api-antrag.js — Version: Σ.v1.antrag-service

import { Antragslogik } from '../core/antragslogik.js';
import { Speicher } from './persistence-service.js';

export const apiAntrag = {
    async pruefeAlleAntraege() {
        const antraege = await Speicher.ladeAlle('antrag');

        for (const a of antraege) {
            Antragslogik.pruefeEntscheidung(a, a.einspruchsDatum);
        }

        await Speicher.schreibe('antrag', antraege);
    },

    async stelleAntrag(antrag) {
        Antragslogik.initialisiereAntrag(antrag);
        if (antrag.kategorie === 'gold') {
            Antragslogik.kennzeichneGoldantrag(antrag);
        }

        await Speicher.speichere('antrag', antrag);
        return antrag;
    },

    async markiereEinspruch(antragId) {
        const antraege = await Speicher.ladeAlle('antrag');
        const antrag = antraege.find(a => a.id === antragId);
        if (antrag) {
            Antragslogik.markiereEinspruch(antrag);
            antrag.einspruchsDatum = new Date().toISOString();
        }
        await Speicher.schreibe('antrag', antraege);
    }
};

// --- Datei: Launchweb/services/websocket-integration.js ---

// websocket-integration.js — Version: Σ.v1.0.webung.sync.full

import { websocketService } from './websocket-service.js';
import { loadInitialData } from './startup-loader.js';
import { renderVisuals } from './leaflet-setup.js';

export class WebsocketIntegration {
    constructor(map) {
        this.map = map;
        websocketService.registerMessageHandler(this.handleMessage.bind(this));
        websocketService.connect();
    }

    async handleMessage(msg) {
        const { type } = msg;

        if (['webung_created', 'knoten_created', 'antrag_started', 'einspruch', 'abstimmung'].includes(type)) {
            const freshData = await loadInitialData();
            renderVisuals(this.map, freshData);
        } else if (type === 'ping') {
            // optional: heartbeat received
        } else {
            console.warn('WebsocketIntegration: Unbekannter Nachrichtentyp', type);
        }
    }
}

// --- Datei: Launchweb/services/file-storage.js ---

// services/file-storage.js — v1

import fs from 'fs/promises';
import path from 'path';

export const FileStorage = {
    baseDir: './weltweberei-data',

    async ensureDir() {
        await fs.mkdir(this.baseDir, { recursive: true });
    },

    async read(file) {
        const full = path.join(this.baseDir, file);
        try {
            const content = await fs.readFile(full, 'utf-8');
            return JSON.parse(content);
        } catch (err) {
            if (err.code === 'ENOENT') return [];
            throw err;
        }
    },

    async write(file, data) {
        await this.ensureDir();
        const full = path.join(this.baseDir, file);
        await fs.writeFile(full, JSON.stringify(data, null, 2));
    }
};

// --- Datei: __MACOSX/Launchweb/._index.html ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._system-meta.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._merged-weltweb.txt ---

// Fehler: 'utf-8' codec can't decode byte 0xb0 in position 45: invalid start byte


// --- Datei: __MACOSX/Launchweb/._weltweb.txt ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._startup-loader.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._layer-manager.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._leaflet-setup.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._strukturbaum.txt ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._init-events.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._style.css ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._engine-events.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/._main.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-login.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-ereignis.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-interactions.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-finanz.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-themenfilter.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/._ui-core.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._ui-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._knoten-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/knoten/._knoten-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._antrag-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._ui-antrag.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._render-antraege.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/antrag/._antrag-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._diskurs-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._ui-diskurs.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/diskurs/._diskurs-form.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/layer/._ui-layer-advanced.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/layer/._ui-layer-toggle.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-naehstuebchen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-zeitreise.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._ui-webrat.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/ui/extras/._zeitleiste.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._webung-engine.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._antragszyklus.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._verblasslogik.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._zeitlogik.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._manifest.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/core/._knotenerkennung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._form-components.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utility-core.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._validation.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utility-tooltip.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/utils/._utils.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._user-model.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._knotentypen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/models/._webung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-base.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-antraege.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-faeden.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._colors.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-fadenlegende.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-garne.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/visuals/._render-webkasse.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-finanz.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-model.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.client.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._persistence-services.server.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/data/._data-diskurs.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._websocket-service.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-verblassen.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._websocket-integration.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-antrag.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._file-storage.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._auth-service.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-knoten.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte


// --- Datei: __MACOSX/Launchweb/services/._api-webung.js ---

// Fehler: 'utf-8' codec can't decode byte 0xb1 in position 37: invalid start byte
