# üåê Weltgewebe v14.3 ‚Äî Vollst√§ndige Blaupause mit direkter Demokratie, strukturellen Ankerpunkten & Peer-Verifikation

## 0) Leitplanken & Prinzipien (unverhandelbar)

**Philosophische Grundlagen:**
- **Alles ist Event**: Append-only, unver√§nderlich; Hash-Kette pro Aggregat mit ed25519-Signaturen f√ºr Byzantine-tolerante Konsistenz[1][2]
- **Radikale Transparenz**: Jede Aktion erzeugt Events ‚Äì inkl. Fehler (EventRejected) und Admin-Aktionen (AdminActionExecuted) mit vollst√§ndigem Audit-Trail
- **Sichtbarkeit ist aktionsbezogen**: Rollen rotieren 7 Sekunden nach jeder Webungsaktion (Edit, Faden, Antrag, Verzwirnen, Entzwirnen, Spende)[1]
- **Fadenpflicht**: Jede aktive Nutzeraktion an einem Karten-Knoten erzeugt automatisch einen Faden von dessen Rolle zum Handlungsort (Subtyp je Aktion)
- **Strukturknoten als Ankerpunkte**: Gewebekonto, Webrat und N√§hst√ºbchen sind permanente, fixierte Kartenelemente mit spezieller Semantik[2]
- **Sichtbarkeit ist W√§hrung**: Sichtbares Engagement, Ressourcen und Spenden bilden den Wert. Passive Betrachtung bleibt neutral
- **Peer-Verifikation & Autonomie**: Ed25519-signierte Events, Byzantine-tolerante Konsistenz, Datenschutz by Design, DSGVO-konform[2]
- **Global skalierbar**: Von Nachbarschaft bis weltweites Myzel mit R√ºckrufbarkeit aller Delegierten

**Technische Leitplanken:**
- **Small-Team-Ops**: 1-2 Personen betreibbar, MTTR ‚â§15 min, automatisierte Runbooks, Healthchecks (/health/live, /health/ready)
- **Kostenarm**: Ziel <‚Ç¨0,01/1.000 Events; Echtzeit-Kosten-Metrik im Dashboard
- **JetStream-Kern mit Peer-Network**: NATS JetStream als unverr√ºckbarer Event-Backbone, Redis f√ºr Fallback & Speed-Layer, Leafnodes f√ºr F√∂deration[1][2]
- **Community-First**: Phase A liefert vollst√§ndige lokale Weberei-Erfahrung ab Tag 1

**Visualsprache:**
- **Faden** = verg√§nglich (7-Tage Fade), farbkodiert nach Subtyp
- **Garn** = verzwirnte F√§den (permanent, sichtbar verzwirnt), sch√ºtzt Knoten vor Verfall
- **Goldfaden** = Spenden (Finanzfluss, goldfarbig)
- **Strukturknoten** = Gewebekonto (gold), Webrat (rot), N√§hst√ºbchen (blau) als permanente Kartenelemente[2]
- **Mehrfachf√§den** = intelligente √úberlappung bei mehreren F√§den zwischen gleichen Punkten
- **Webungs-Rotation** = 7s-Drehung der Garnrolle nach jeder Webungsaktion (global sichtbar)

***

## 1) UX & Informationsarchitektur

### 1.1 Karten-Zentralansicht (MapLibre GL) mit Strukturknoten

**Standardzustand:** Vollbild-Karte mit mobile-first Design und permanenten strukturellen Ankerpunkten.

**Strukturknoten (immer sichtbar, nie verfallend):**[2]
- **Gewebekonto** (goldenes Kassensymbol): Zentraler Finanzknoten f√ºr alle Goldfaden-Str√∂me
- **Webrat** (rotes Parlamentssymbol): Governance-Hub f√ºr Antr√§ge und Abstimmungen  
- **N√§hst√ºbchen** (blaues Kommunikationssymbol): Ortsunabh√§ngiger Diskussions-Raum

**Pull-Tabs (ausziehbare Drawer):**
- **Links**: "Webrat & N√§hst√ºbchen" (360px desktop, modal mobile)
  - **Integrierter Governance- und Chat-Bereich** verkn√ºpft mit Strukturknoten[2]
  - Thread-Liste (pinnable, zuletzt aktiv), Rich-Text Editor
  - Live-Abstimmungs-Interface f√ºr sofortige Partizipation[2]
- **Rechts**: "Filter & Ebenen" (300px desktop)
  - Toggles: Knotenarten, Zeitfenster (24h/7d/Snapshots), Delegationen, Goldf√§den, Governance-Marker
  - **Fadenarten-Filter**: Erweiterte Toggles f√ºr jeden Subtyp (Gespr√§ch, Gestaltung, Ver√§nderung, Antrag, Abstimmung, Gold, Delegation)
  - **Mehrfachf√§den-Toggle**: Ein/Aus f√ºr √ºberlappende Darstellung mit progressiver √úberlappungslogik[1][2]
  - **Strukturknoten-Filter**: Spezielle Kontrollen f√ºr Gewebekonto/Webrat/N√§hst√ºbchen-Verbindungen
  - Fadenarten-Legende (farbkodiert), H3-Aufl√∂sung adaptiv zu Zoom-Level
- **Oben Mitte**: "Gewebekonto-Visualisierung" (verkn√ºpft mit Strukturknoten)[2]
  - Dashboard mit Live-Saldo/Bewegungen, ausstehende SEPA/FinTS
  - CSV/JSON-Export, vollst√§ndige Transparenz-Links
  - Goldfaden-Routing zu/von Gewebekonto-Strukturknoten
- **Oben rechts**: "Konto-Zugriff mit Peer-Verifikation"[2]
  - **Eingeloggt**: Eigene Garnrolle in Profilfarbe mit **Webungs-Rotation** + **Peer-Verifikations-Haken** ‚Üí √∂ffnet Profil-Drawer
  - **Ausgeloggt**: Graues Rollen-Icon mit "+" Badge ‚Üí √∂ffnet Login-Drawer
  - **Ed25519-Peer-Verifikation** (2-von-N Quorum), Benachrichtigungen, Datenschutz, Feature-Flags

**Faden-Verbindungen:** F√§den verbinden Rollen (am Wohnsitz) mit Karten-Knoten und Strukturknoten.

### 1.2 Erweiterte Mehrfachf√§den-Visualisierung mit progressiver √úberlappung

**Intelligente √úberlappung** f√ºr mehrere F√§den zwischen gleichen Punkten mit verbesserter Logik:[1][2]

```typescript
// Enhanced progressive overlap calculation
function calculateProgressiveOverlap(count: number, maxSpread: number = 24): number[] {
  if (count === 1) return [0];
  
  // Progressive overlap factor - mehr F√§den = mehr √úberlappung f√ºr Kompaktheit
  const overlapFactor = Math.min(0.8, Math.pow((count - 1) / 15, 0.7)); 
  const effectiveSpread = maxSpread * (1 - overlapFactor);
  const step = count === 1 ? 0 : effectiveSpread / (count - 1);
  
  return Array.from({length: count}, (_, i) => 
    -effectiveSpread/2 + i * step
  );
}

// Optimized MapLibre implementation with deterministic sorting
class StructuralAwareFadenRenderer {
  async renderFadenBundles(viewport: ViewportBounds) {
    const bundles = await this.getFadenBundles(viewport);
    
    // Strukturknoten-aware Sortierung f√ºr Tile-Stabilit√§t
    bundles.sort((a, b) => {
      // Strukturknoten-Verbindungen haben Priorit√§t
      const aStructural = this.isStructuralConnection(a);
      const bStructural = this.isStructuralConnection(b);
      if (aStructural !== bStructural) return bStructural ? 1 : -1;
      
      // Standard deterministische Sortierung
      if (a.from_rolle !== b.from_rolle) return a.from_rolle.localeCompare(b.from_rolle);
      if (a.to_knoten !== b.to_knoten) return a.to_knoten.localeCompare(b.to_knoten);
      return a.latest_created_at.localeCompare(b.latest_created_at);
    });
    
    for (const bundle of bundles) {
      if (bundle.faden_count > 1) {
        this.renderMehrfachBundle(bundle);
      } else {
        this.renderSingleFaden(bundle.faeden_data, bundle.isStructural);
      }
    }
    
    this.applyStructuralAwareOverdrawGuard();
  }
  
  private isStructuralConnection(bundle: any): boolean {
    const structuralTypes = ['gewebekonto', 'webrat', 'naehstuebchen'];
    return structuralTypes.includes(bundle.to_knoten_type);
  }
}

// MapLibre Integration mit Strukturknoten-Styling
map.addLayer({
  id: `faden-${groupKey}-${i}`,
  type: 'line',
  source: 'faeden',
  paint: {
    'line-color': bundle.isStructural 
      ? this.getStructuralFadenColor(bundle.to_knoten_type, faden.subtype)
      : this.getFadenColor(faden.subtype),
    'line-width': bundle.isStructural ? 3 : 2, // Strukturknoten-F√§den dicker
    'line-opacity': ['get','opacity'],
    'line-offset': offsets[i]
  }
});
```

**Visuelle Implementierung:**
- **Z-Index-Staffelung**: Strukturknoten-F√§den oben, dann nach timestamp
- **Strukturknoten-Styling**: Dickere Linien (3px vs 2px) und spezielle Farbkodierung
- **Transparenz-Gradient**: Untere F√§den leicht transparenter (opacity: 0.7-1.0)
- **Hover-Hervorhebung**: Bei Hover hebt sich der entsprechende Faden hervor
- **Strukturknoten-Toggle**: Separate Sichtbarkeitskontrolle f√ºr strukturelle Verbindungen

### 1.3 Webungs-Rotation mit Peer-Verifikations-Status

**Konzept:** Jede Webungsaktion triggert eine sichtbare **7-Sekunden-Drehung** der Garnrolle mit Peer-Status-Anzeige:[1][2]

```svelte
<script>
  import { onMount } from 'svelte';
  import { socket } from '$lib/socket';
  import { peerConsensus } from '$lib/peer-verification';
  
  export let rolle;
  
  let spinning = false;
  let peerStatus = 'verified'; // 'verified' | 'pending' | 'unverified'
  let spinTimer;
  
  function triggerSpin(ms = 7000, actionType = 'unknown') {
    clearTimeout(spinTimer);
    spinning = true;
    
    // Peer-Status w√§hrend Rotation aktualisieren
    peerStatus = 'pending';
    
    spinTimer = setTimeout(() => {
      spinning = false;
      peerStatus = 'verified'; // Nach erfolgreicher Rotation
    }, ms);
  }
  
  // Lokale Aktion (optimistisch): sofort drehen
  export function onLocalAction(actionType) {
    triggerSpin(7000, actionType);
  }
  
  onMount(() => {
    // Standard Webungs-Rotation Events
    socket.on('role-action', (msg) => {
      if (msg.rolleId === rolle.id) {
        triggerSpin((msg.durationSec ?? 7) * 1000, msg.aktionTyp);
      }
    });
    
    // Peer-Consensus Events f√ºr Verifikations-Status
    socket.on('peer-consensus', (msg) => {
      if (msg.rolleId === rolle.id) {
        peerStatus = msg.status; // 'verified' | 'pending' | 'failed'
      }
    });
  });
</script>

<div 
  class="rolle-marker {spinning ? 'spin' : ''} peer-{peerStatus}" 
  aria-label="Rolle {rolle.name} {spinning ? '(k√ºrzlich aktiv)' : ''} - Peer-Status: {peerStatus}"
>
  <div class="garnrolle" style="background: {rolle.farbe}">
    <!-- Peer-Verifikations-Indikator -->
    <div class="peer-indicator" class:verified={peerStatus === 'verified'}>
      {#if peerStatus === 'verified'}
        <span class="verified-icon">‚úì</span>
      {:else if peerStatus === 'pending'}
        <span class="pending-icon">‚è≥</span>
      {:else}
        <span class="unverified-icon">‚ö†Ô∏è</span>
      {/if}
    </div>
  </div>
</div>

<style>
.rolle-marker { 
  width: 32px; /* Erweitert f√ºr Peer-Indikator */
  height: 32px; 
  border-radius: 50%; 
  position: relative; 
}

.garnrolle { 
  width: 100%; 
  height: 100%; 
  border-radius: 50%; 
  background: radial-gradient(#c28a3a,#8a5a1a); 
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  position: relative;
}

.peer-indicator {
  position: absolute;
  top: -2px;
  right: -2px;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  border: 2px solid;
}

.peer-indicator.verified {
  border-color: #28a745;
  color: #28a745;
}

.peer-indicator:not(.verified) {
  border-color: #ffc107;
  color: #ffc107;
}

@media (prefers-reduced-motion: no-preference) {
  .spin .garnrolle { 
    animation: rollspin 7s linear; 
  }
  
  @keyframes rollspin {
    from { transform: rotate(0deg) }
    to   { transform: rotate(3600deg) } /* 10 Umdrehungen in 7s */
  }
}

/* A11y fallback: kurzer Glanz statt Rotation */
@media (prefers-reduced-motion: reduce) {
  .spin .garnrolle { 
    animation: glow 800ms ease-out; 
  }
  
  @keyframes glow {
    0% { box-shadow: 0 0 0 0 rgba(255,215,0,.7) }
    100% { box-shadow: 0 0 0 12px rgba(255,215,0,0) }
  }
}

/* Strukturknoten-spezifisches Styling */
.rolle-marker.structural .garnrolle {
  background: linear-gradient(45deg, #d4af37, #ffd700); /* Gold f√ºr Strukturknoten-Interaktionen */
}
</style>
```

### 1.4 Knotenr√§ume mit Strukturknoten-Integration

**Automatik:** Jeder Knoten erzeugt automatisch bei Kn√ºpfung seinen Raum, **Strukturknoten haben erweiterte Interfaces:**[1][2]
- **Standard-Knoten**: Info | Threads | Gestalten | Teilnehmende | Historie
- **Gewebekonto-Raum**: + Finanzdashboard, SEPA-Integration, Transparenz-Export[2]
- **Webrat-Raum**: + Antrags√ºbersicht, aktive Abstimmungen, Delegations-Management[2]
- **N√§hst√ºbchen-Raum**: + Moderations-Tools, Thread-Archiv, Community-Guidelines[2]

**√ñffnen**: Tap/Klick auf Knoten ‚Üí kontextueller Raum-Typ √∂ffnet sich
**Threading**: Live-Sync via WebSocket, Offline Outbox (Dexie), **Peer-synchronisiert**[2]
**Markdown**: Rich-Text, @Erw√§hnungen, Anh√§nge, Verzwirnen-Button

### 1.5 Karte & Faden-Visualisierung mit Strukturknoten

**Fadenarten (sichtbar, farbkodiert; erweiterte Legende in rechter Drawer-Leiste):**[1]
- **Gespr√§ch** (blau): Beitrag/Kommentar
- **Gestaltung** (gr√ºn): Kn√ºpfen/√úberarbeiten eines Knotens  
- **Ver√§nderung** (orange): Bestehendes √§ndern
- **Antrag** (rot): Antrag stellen/begleiten ‚Üí **prim√§r zu Webrat-Strukturknoten**[2]
- **Abstimmung** (violett): Stimme abgegeben ‚Üí **Webrat-Verbindung**[2]
- **Goldfaden** (gold): Spende/Finanzfluss ‚Üí **prim√§r zu/von Gewebekonto**[2]
- **Delegation** (grau): Immer sichtbar, Stimm√ºbertragung transparent

**Strukturknoten-spezifische Visualisierung:**[2]
- **Gewebekonto-F√§den**: Goldf√§den konvergieren hier, dickere Darstellung
- **Webrat-F√§den**: Antrags- und Abstimmungsf√§den, r√∂tliche T√∂nung
- **N√§hst√ºbchen-F√§den**: Gespr√§chsf√§den, bl√§uliche T√∂nung

**Alpha-Verfall:** F√§den verblassen linear √ºber 7 Tage (Opacity 1.0 ‚Üí 0.0), **au√üer Strukturknoten-Verbindungen**[2]

**Garn:** Sichtbar verzwirnt (2-3 parallele Str√§nge), dicker, permanent

**Goldf√§den mit Gewebekonto-Integration:**[1][2]
- Zoom-Out: Aggregiert als Heat/Flows zum Gewebekonto
- Zoom-In: Linien Rolle ‚Üí Gewebekonto-Strukturknoten ‚Üí Ziel-Knoten
- Tooltip: Betrag + Status (Initiated/Pending/Settled)
- Statusfarben: initiated (gestrichelt), pending (durchgezogen), settled (glow)

**Delegationsf√§den:** Immer sichtbar als graue Pfeile, Tooltip: Stimmgewicht, letzte Aktivit√§t, Ablaufzeit

### 1.6 Login & Authentifizierung mit Peer-Verifikation

**Login-Drawer mit Ed25519-Integration:**[2]
```svelte
<div class="login-drawer">
  <h3>Weberei-Zugang ‚Äì kryptographisch gesichert</h3>
  <p>Ed25519-Peer-Verifikation f√ºr Byzantine-tolerante Sicherheit.<br>
     Du bestimmst, was sichtbar ist. Vollst√§ndige Privatsph√§re-Kontrolle.</p>
  
  <button class="passkey-btn" on:click={loginWithPasskey}>
    üîê Mit Passkey anmelden (Ed25519)
  </button>
  
  <div class="magic-link">
    <input type="email" placeholder="E-Mail f√ºr Krypto-Link" bind:value={email} />
    <button on:click={sendCryptoMagicLink}>Signierten Link senden</button>
  </div>
  
  {#if FF_OIDC}
    <button class="oidc-btn" on:click={loginWithOIDC}>Mit SSO anmelden</button>
  {/if}
  
  <div class="peer-status">
    <h4>Peer-Network Status</h4>
    <div class="peer-indicators">
      {#each activePeers as peer}
        <span class="peer-indicator {peer.status}">{peer.name}</span>
      {/each}
    </div>
  </div>
  
  <button class="anonymous-btn" on:click={continueAnonymous}>Weiter ohne Konto</button>
</div>
```

### 1.7 Erweiterte Interaktive Onboarding-Tour

```svelte
<script>
  import { onMount } from 'svelte';
  import { tourState } from '$lib/stores/tour';
  
  const enhancedTourSteps = [
    { target: '[data-testid="karte"]', text: 'Herzlich willkommen! Dies ist deine Weberei-Karte mit strukturellen Ankerpunkten.' },
    { target: '[data-testid="gewebekonto"]', text: 'Das Gewebekonto (gold) ist der zentrale Finanzknoten f√ºr alle Goldf√§den.' },
    { target: '[data-testid="webrat"]', text: 'Der Webrat (rot) ist dein Governance-Hub f√ºr direkte Demokratie.' },
    { target: '[data-testid="naehstuebchen"]', text: 'Das N√§hst√ºbchen (blau) verbindet dich ortsunabh√§ngig mit der Community.' },
    { target: '[data-testid="webrat-tab"]', text: 'Hier diskutiert und entscheidet ihr demokratisch ‚Äì sofort und direkt!' },
    { target: '[data-testid="filter-tab"]', text: 'Filtere nach Fadenarten, Strukturknoten-Verbindungen und Zeitr√§umen.' },
    { target: '[data-testid="mehrfach-toggle"]', text: 'Progressive Mehrfachf√§den-√úberlappung f√ºr kompakte Darstellung.' },
    { target: '[data-testid="knoten-knuepfen"]', text: 'Kn√ºpfe deinen ersten Knoten ‚Äì er erzeugt automatisch einen Gestaltungsfaden!' },
    { target: '[data-testid="verzwirnen-button"]', text: 'Verzwirnte F√§den werden zu dauerhaftem Garn und sch√ºtzen Knoten granular.' },
    { target: '[data-testid="garnrolle"]', text: 'Nach deiner Webung dreht sich deine Rolle 7 Sekunden ‚Äì mit Peer-Verifikations-Status!' },
    { target: '[data-testid="peer-indicator"]', text: 'Der Peer-Status zeigt die Ed25519-Verifikation deiner Aktionen an.' }
  ];

  onMount(() => {
    if (localStorage.getItem('tourCompleted') === null && $tourState.enabled) {
      startInteractiveTour(enhancedTourSteps);
    }
  });
</script>
```

### 1.8 Erweiterte Suche, A11y & Offline mit Peer-Sync

**Erweiterte Suche:** Volltextsuche √ºber knoten.title, antraege.title, rollen.name + **Fadenarten-Filter** + **Strukturknoten-Filter** (z.B. "Nur Gewebekonto-Verbindungen"); bei Treffer Highlighting + entfernungsbasierte durchklickbare Liste.

**A11y Features:**
- ARIA-Live-Regionen f√ºr Karten-Updates mit **dynamischen Labels** f√ºr Fade-Animationen und **Strukturknoten-Status**
- **Webungs-Rotation-Labels** f√ºr Screenreader ("Rolle XY ist k√ºrzlich aktiv, Peer-Status: verifiziert")[1][2]
- **Strukturknoten-Ank√ºndigung**: "Gewebekonto mit 15 Goldf√§den, Webrat mit 3 aktiven Abstimmungen"[2]
- Vollst√§ndige Keyboard-Steuerung der Drawer (Tab, Enter, ESC)
- Mobile Swipe + Tastatur-√Ñquivalente
- Kontrastierte Fadenfarben + Linien-Muster f√ºr Farbsehschw√§chen
- Focus-trap in Drawern

**Erweiterte Offline-Unterst√ºtzung mit Peer-Konfliktl√∂sung:**[2]
```javascript
// Peer-aware Dexie-Outbox mit Ed25519-Signaturen
db.outbox.hook('creating', (primKey, obj) => {
  obj.conflictResolution = 'peer-consensus'; // Peer-basierte Konfliktl√∂sung
  obj.signature = signWithEd25519(obj, privateKey);
  obj.timestamp = Date.now();
  obj.retryCount = 0;
  obj.peerQuorum = [];
});

// Peer-Consensus Conflict Resolution
async function syncWithPeerConsensus() {
  const conflicts = await detectConflicts();
  if (conflicts.length > 0) {
    const peerResolution = await requestPeerConsensus(conflicts);
    await applyPeerResolution(peerResolution);
  }
}
```

***

## 2) Dom√§ne & Regeln

### 2.1 Automatik-Grundsatz mit Strukturknoten-Awareness

**Aktion ‚áí Faden + Webungs-Rotation + Peer-Verifikation:**[1][2]
- **Jede aktive Nutzeraktion** an einem Karten-Knoten erzeugt automatisch:
  1. Einen Faden von der Rolle zum Handlungsort (Subtyp je Aktion)
  2. **Eine 7s-Webungs-Rotation der Rolle** (global sichtbar)
  3. **Ed25519-signiertes Event f√ºr Peer-Verifikation**[2]
- **Strukturknoten-Aktionen** erzeugen spezielle F√§den mit erh√∂hter Sichtbarkeit[2]
- **Passive Aktionen** (ansehen/filtern) bleiben neutral
- **Login** ist eine System-Aktion ‚Üí erzeugt weder Faden noch Rotation

### 2.2 Erweiterte Verzwirn-Schutz (granulare Sperrung) mit Peer-Konsens

**Verzwirnung als einzige Quelle der Wahrheit mit Peer-Best√§tigung:**[1][2]
- **Grundregel**: Jeder darf jeden Knoten bearbeiten
- **Schutz**: Verzwirnte Bereiche sind editiersicher
- **Granularit√§t**: Verzwirnung gilt f√ºr spezifische JSON-Pointer-Pfade (z.B. `/title`, `/sections/2`)
- **Vollschutz**: Verzwirnung mit Scope `"full"` sperrt den gesamten Knoten
- **Strukturknoten-Schutz**: Kritische Strukturknoten-Eigenschaften sind per Default verzwirnt[2]
- **Peer-Validierung**: Verzwirnungen erfordern 2-von-N Peer-Best√§tigung f√ºr Validit√§t[2]

```sql
-- Erweiterte Verzwirnungen-Tabelle mit Peer-Konsens
CREATE TABLE verzwirnungen (
  id UUID PRIMARY KEY,
  knoten_id UUID NOT NULL REFERENCES knoten(id) ON DELETE CASCADE,
  rolle_id UUID NOT NULL REFERENCES rollen(id),
  scope JSONB NOT NULL, -- "full" oder ["/title", "/sections/2"]
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  peer_signatures JSONB DEFAULT '[]', -- Ed25519-Signaturen der best√§tigenden Peers
  consensus_achieved BOOLEAN DEFAULT FALSE,
  is_structural BOOLEAN DEFAULT FALSE -- Strukturknoten-spezifische Verzwirnung
);

-- Strukturknoten-Schutz-View
CREATE OR REPLACE VIEW structural_protection_view AS
SELECT
  k.id AS knoten_id,
  k.typ AS knoten_typ,
  CASE 
    WHEN k.is_structural THEN 
      COALESCE(v.scope, '["/.type", "/.coords", "/.title"]'::jsonb)
    ELSE v.scope
  END AS protected_paths
FROM knoten k
LEFT JOIN verzwirnungen v ON v.knoten_id = k.id AND v.consensus_achieved = true;
```

### 2.3 Knoten-Lebenszyklus mit Strukturknoten-Permanenz

**Strukturknoten sind permanent:**[2]
- **Gewebekonto, Webrat, N√§hst√ºbchen** verfallen niemals
- **Standard-Knoten** folgen Garn-Schutz-Regeln: Solange mindestens ein Garn zu einem Knoten f√ºhrt, bleibt er aktiv
- **Verfall startet erst**, wenn letzter Faden/Garn entkn√ºpft/verblasst ist ‚Üí **KnotenStartetVerfall**, expires_at = now()+7d
- **Fade**: UI-Opacity steigt linear 0 ‚Üí 100% in 7 Tagen; dann **KnotenVerfallen** (Historie bleibt in Events/Timeline)
- **Strukturknoten-Verbindungen** beeinflussen Verfallsregeln: Knoten mit Strukturknoten-F√§den haben verl√§ngerte Lebensdauer

### 2.4 Direkte Demokratie mit sofortiger Partizipation

**Revolution√§res Governance-Prinzip:**[2]
- **Antr√§ge**: AntragGestellt erzeugt **Antragsfaden** Rolle ‚Üí **Webrat-Strukturknoten** (immer sichtbar); Timer 7 Tage sichtbar
- **Sofortige Abstimmungsf√§higkeit**: Einspruch aktiviert **sofortige Abstimmung ohne Wartezeit**[2]
  - **Einspruch-Limit**: Max. 1 Einspruch pro Rolle pro Antrag (verhindert Trolling)
- **Abstimmung**: AbstimmungGestartet sofort nach Einspruch; Voting-Fenster (7 Tage, per Instanz-Policy); StimmeAbgegeben erzeugt **Abstimmungsfaden zum Webrat + Webungs-Rotation**[2]
- **Abstimmungen sind immer g√ºltig**: Unabh√§ngig von der Beteiligung
- **Einfache Mehrheit**: Beschluss gilt bei mehr Ja- als Nein-Stimmen (Enthaltungen neutral)
- **Sofortige Ausf√ºhrung**: Nach Annahme l√∂st Server sofort `ActionExecuted` aus (idempotent, idempotencyKey = antragId)[2]
- **Delegation**: Phase A 1:1; Ablauf nach **4 Wochen Inaktivit√§t** des Delegierenden (Timer). Phase B (Flag): transitiv, Cycle-Check
- **Delegationsf√§den**: Immer sichtbar als graue Pfeile, oft zu Webrat-Strukturknoten[2]

```typescript
// Sofortige Abstimmungsaktivierung
async function processImmediateVoting(einspruchEvent: EinspruchEingegangen) {
  // Keine Wartezeit - sofortige Aktivierung!
  const abstimmungId = generateULID();
  
  await eventBus.publish({
    type: 'AbstimmungGestartet',
    aggregateId: einspruchEvent.antragId,
    payload: { 
      abstimmungId,
      startsAt: new Date().toISOString(), // SOFORT!
      deadline: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
      immediateActivation: true
    }
  });
  
  // Webungs-Rotation f√ºr Einsprechenden
  await webungsRotationManager.triggerWebungsRotation(
    einspruchEvent.meta.actor, 
    'einspruch',
    'webrat-strukturknoten'
  );
}

// Vereinfachter Governance-Flow mit sofortiger Wirksamkeit
async function processDirectVoteResult(abstimmungId: string) {
  const votes = await getVotesForAbstimmung(abstimmungId);
  
  const ja = votes.filter(v => v.choice === 'ja').length;
  const nein = votes.filter(v => v.choice === 'nein').length;
  
  let result: 'angenommen' | 'abgelehnt';
  if (ja > nein) {
    result = 'angenommen';
    
    // SOFORTIGE Ausf√ºhrung ohne weitere Verz√∂gerung
    const antrag = await getAntragByAbstimmung(abstimmungId);
    await executeActionImmediately(antrag.action, antrag.id);
  } else {
    result = 'abgelehnt';
  }
  
  await eventBus.publish({
    type: 'AbstimmungBeendet',
    payload: { 
      abstimmungId, 
      result, 
      stimmenJa: ja, 
      stimmenNein: nein,
      stimmenGesamt: ja + nein,
      immediateDemocracy: true
    }
  });
}
```

***

## 3) Event-Schema & Technische Architektur

### 3.1 Erweiterte Event-Schema mit Ed25519-Signaturen & Strukturknoten

```json
{
  "id": "01HZXY9ABCDEFGHIJK",           // ULID
  "type": "FadenGesponnen",
  "subtype": "gespr√§ch",               // gespraech|gestaltung|veraenderung|antrag|abstimmung|gold|delegation
  "aggregateId": "knoten-550e8400-e29b-41d4-a716-446655440000",
  "aggregateType": "knoten",           // knoten|faden|rolle|antrag|delegation|zahlung|account|session
  "ts": "2025-08-21T12:00:00.000Z",
  "subject": "wg.kleinroennau.social", // √ñffentlich | "wg.kleinroennau.auth" f√ºr Login-Events
  "signature": "ed25519:abc123def456789abcdef...", // Ed25519-Signatur f√ºr Byzantine-Toleranz
  "prev_hash": "sha256:abc123def456...",       // SHA256 des letzten Events f√ºr dieses Aggregat
  "payload": {
    "fromRolle": "rolle-uuid...",
    "toKnoten": "knoten-uuid...",
    "toStructuralType": "webrat",      // Neu: gewebekonto|webrat|naehstuebchen|null
    "content": "Das ist interessant!",
    "expiresAt": "2025-08-26T15:22:00.000Z",
    "h3": 599405658847379,
    "isStructuralConnection": true      // Neu: Flag f√ºr Strukturknoten-Verbindungen
  },
  "meta": {
    "actor": "rolle-uuid...",
    "msgId": "deterministic-dedup-key", // F√ºr Idempotenz
    "ipHash": "sha256(ip+salt)",         // Pseudonymisiert
    "uaHash": "sha256(ua+salt)",
    "peerQuorum": ["peer1-id", "peer2-id"], // Peer-Verifikation
    "consensusAchieved": true,          // Byzantine-Konsens Status
    "peerSignatures": {                 // Ed25519-Peer-Best√§tigungen
      "peer1-id": "ed25519:signature1...",
      "peer2-id": "ed25519:signature2..."
    }
  }
}
```

### 3.2 Peer-Verifikations-Events (√∂ffentlich mit Ed25519)[2]
```json
{
  "type": "PeerConsensusAchieved",
  "aggregateId": "event-uuid",
  "subject": "wg.kleinroennau.consensus",
  "ts": "2025-08-21T12:00:00Z",
  "signature": "ed25519:master-signature...",
  "payload": {
    "originalEventId": "original-event-uuid",
    "quorumPeers": ["peer1", "peer2", "peer3"],
    "consensusType": "byzantine-tolerant",
    "achievedAt": "2025-08-21T12:02:15Z",
    "validationResults": {
      "schemaValid": true,
      "signatureValid": true, 
      "chronologicalValid": true,
      "businessLogicValid": true
    }
  },
  "meta": { "consensusRound": 1, "totalPeers": 5 }
}
```

### 3.3 Strukturknoten-spezifische Events[2]
```json
{
  "type": "StrukturknotenInteraktion",
  "aggregateId": "strukturknoten-uuid",
  "subject": "wg.kleinroennau.structural",
  "payload": {
    "strukturknotenTyp": "gewebekonto", // gewebekonto|webrat|naehstuebchen
    "interaktionsTyp": "goldfaden_routing|antrag_einreichung|diskussion_start",
    "rolleId": "rolle-uuid",
    "targetKnoten": "ziel-knoten-uuid",
    "metadata": {
      "betrag": 1500,           // F√ºr Gewebekonto
      "antragId": "antrag-uuid", // F√ºr Webrat  
      "threadId": "thread-uuid"  // F√ºr N√§hst√ºbchen
    }
  }
}
```

### 3.4 Erweiterte Event-Typen mit Strukturknoten & Peer-Verifikation

**Strukturknoten-Events:**[2]
- `StrukturknotenErstellt{typ, coords, specialConfig}` (bei Setup)
- `GewebekontoTransaktion{betrag, fromRolle, toKnoten, routing}` (mit Goldf√§den)
- `WebratyAntragGerouted{antragId, fromRolle, targetKnoten}` (Antrag via Webrat)
- `NaehstuebchenThreadEroeffnet{threadId, topic, participants}`
- `StrukturknotenVerzwirnt{typ, scope, peerConsensus}` (mit erh√∂hten Anforderungen)

**Peer-Verifikations-Events:**[2]
- `PeerConsensusInitiated{eventId, requiredQuorum}` 
- `PeerValidationReceived{peerId, eventId, validationResult, signature}`
- `PeerConsensusAchieved{eventId, finalQuorum, achievedAt}` 
- `PeerConsensusFailed{eventId, reason, partialQuorum}`
- `ByzantineFaultDetected{suspiciousPeerId, evidenceHash}`

**Erweiterte Webungs-Rotation (√∂ffentlich) mit Peer-Status:**
- `RolleWebtAktionMitPeerStatus{rolleId, aktionTyp, knotenId, strukturknotenTyp?, peerStatus, durationSec}` (√∂ffentlich)

**Erweiterte F√§den mit Strukturknoten-Awareness:**
- `FadenGespannenStrukturell{subtype, fromRolle, toStructuralKnoten, strukturTyp}` ‚Üí l√∂st Webungs-Rotation aus
- `FadenVerzwirntMitPeerKonsens{fadenIds[], scope, peerSignatures}` ‚Üí wird Garn (permanent) ‚Üí l√∂st Webungs-Rotation aus
- `StrukturellesFadenRouting{fromRolle, viaStrukturknoten, toKnoten, routingTyp}`

**Direkte Demokratie-Events:**[2]
- `AntragSofortAktiviert{antragId, einspruchRolleId, immediateVoting: true}` (revolution√§r!)
- `AbstimmungSofortGestartet{antragId, startsAt: 'now', deadline}` ‚Üí l√∂st Webungs-Rotation aus
- `SofortigeBeschlussAusfuehrung{antragId, executedAt: 'immediately', result}`

### 3.5 Erweiterte Aktion‚ÜíEvent‚ÜíFaden‚ÜíRotation Mapping mit Strukturknoten

| Benutzeraktion | Event(s) | Automatischer Faden | Webungs-Rotation | Fadenart | Strukturknoten |
|---|---|---|---|---|---|
| Kommentar in Raum | `FadenGesponnen{gespr√§ch}` + `RolleWebtAktion` | Ja | **7s** | Gespr√§chsfaden | ‚Üí N√§hst√ºbchen (bei Chat) |
| Knoten kn√ºpfen | `KnotenGeknuepft` + `FadenGesponnen{gestaltung}` + `RolleWebtAktion` | Ja | **7s** | Gestaltungsfaden | - |
| **Antrag stellen** | `AntragGestellt` + `FadenGespannenStrukturell{antrag}` + `RolleWebtAktion` | Ja | **7s** | **Antragsfaden ‚Üí Webrat** |
| **Sofort-Einspruch** | `EinspruchEingegangen` + `AbstimmungSofortGestartet` + `RolleWebtAktion` | - | **7s** | - | **Webrat** |
| **Sofort-Abstimmung** | `StimmeAbgegeben` + `FadenGespannenStrukturell{abstimmung}` + `RolleWebtAktion` | Ja | **7s** | **Abstimmungsfaden ‚Üí Webrat** |
| **Spenden** | `GoldfadenInitiated` + `FadenGespannenStrukturell{gold}` + `RolleWebtAktion` | Ja | **7s** | **Goldfaden ‚Üí Gewebekonto** |
| Delegieren | `DelegationErteilt` + `FadenGesponnen{delegation}` + `RolleWebtAktion` | Ja | **7s** | **Delegationsfaden** | oft ‚Üí Webrat |
| Verzwirnen mit Peers | `FadenVerzwirntMitPeerKonsens` + `RolleWebtAktion` | - | **7s** | Garn-Upgrade | Enhanced Security |
| **Peer-Verifikation** | `PeerConsensusAchieved` + `RolleWebtAktion` | - | **3s** | - | **Consensus Layer** |

***

## 4) System-Architektur & Implementation

### 4.1 Erweiterte System-√úbersicht mit Peer-Network

```
[SvelteKit PWA + MapLibre + ServiceWorker + Dexie + Ed25519-Crypto]
   ‚îÇ  HTTPS/WSS (TLS 1.3, CSP strict, Ed25519 WebAuthn)
   ‚ñº
[NGINX + Varnish] ‚îÄ‚îÄ‚Üí [Fastify API + @fastify/websocket + Peer-Consensus-Manager]
   ‚îÇ                      ‚îÇ  Zod-Validation, Commands‚ÜíEvents, Ed25519-Verification
   ‚îÇ                      ‚îÇ  Auth: WebAuthn + Magic-Link + Session + **Peer-Auth**
   ‚îÇ                      ‚îÇ  üÜï Strukturknoten-Manager + Byzantine-Consensus
   ‚îÇ                      ‚îÇ  üÜï Sofortige-Demokratie-Engine + Webungs-Rotation-Manager
   ‚îÇ                      ‚ñº
   ‚îÇ              [Enhanced EventBus Adapter mit Peer-Sync]
   ‚îÇ                ‚îú‚îÄ‚Üí [NATS JetStream + Leafnodes] (Primary SoR, peer-federated)
   ‚îÇ                ‚îî‚îÄ‚Üí [Redis Streams + Consensus-Cache] (Auto-Fallback + Sessions + Peer-State)
   ‚îÇ                      ‚îÇ
   ‚îÇ                      ‚îú‚îÄ‚Üí [worker-projection-enhanced] (scale: 1-3, strukturknoten-aware)
   ‚îÇ                      ‚îÇ     ‚îî‚îÄ‚Üí [PostgreSQL + PostGIS + Strukturknoten-Views + Peer-Tables]
   ‚îÇ                      ‚îÇ
   ‚îÇ                      ‚îî‚îÄ‚Üí [worker-jobs-plus] (scale: 1, enhanced timers)
   ‚îÇ                            ‚îú‚îÄ‚Üí [BullMQ Timer] (7d/4w expiry + session sweep + rotation cleanup)
   ‚îÇ                            ‚îú‚îÄ‚Üí [FinTS Poller Enhanced] (4h + backoff + Gewebekonto-Integration)
   ‚îÇ                            ‚îî‚îÄ‚Üí [Peer-Consensus Worker] (Byzantine validation + signature verification)
   ‚îÇ
   ‚îî‚îÄ‚Üí [Prometheus + Grafana + Alertmanager + Enhanced Dashboards]
         ‚îú‚îÄ‚Üí [Peer-Health-Monitoring] (Consensus latency, Byzantine fault detection)
         ‚îú‚îÄ‚Üí [Strukturknoten-Metrics] (Usage patterns, Goldfaden-Flows, Abstimmungs-Rates)
         ‚îî‚îÄ‚Üí [Signal/Matrix Webhook + Strukturknoten-Alerts]
```

### 4.2 Erweiterte Webungs-Rotation-Manager mit Peer-Awareness

```typescript
class EnhancedWebungsRotationManager {
  private activeRotations = new Map<string, {
    triggeredAt: Date;
    broadcasted: boolean;
    aktionTyp: string;
    strukturknotenTyp?: string;
    peerStatus: 'pending' | 'verified' | 'failed';
  }>();
  
  private peerConsensusManager: PeerConsensusManager;
  private batchInterval: NodeJS.Timeout;
  
  constructor(
    private websocketManager: WebSocketManager,
    peerConsensusManager: PeerConsensusManager
  ) {
    this.peerConsensusManager = peerConsensusManager;
    this.batchInterval = setInterval(this.flushRotations.bind(this), 2000);
  }
  
  async triggerWebungsRotation(
    rolleId: string, 
    aktionTyp: string, 
    knotenId?: string,
    strukturknotenTyp?: string
  ) {
    const now = new Date();
    
    // Enhanced 7s Window mit Strukturknoten-Awareness
    const existing = this.activeRotations.get(rolleId);
    if (existing && now.getTime() - existing.triggeredAt.getTime() < 7000) {
      // Strukturknoten-Aktionen k√∂nnen bestehende Rotationen erweitern
      if (strukturknotenTyp && !existing.strukturknotenTyp) {
        existing.strukturknotenTyp = strukturknotenTyp;
        existing.peerStatus = 'pending';
      }
      return; 
    }
    
    // Neue Drehung mit Peer-Status
    this.activeRotations.set(rolleId, {
      triggeredAt: now,
      broadcasted: false,
      aktionTyp,
      strukturknotenTyp,
      peerStatus: 'pending'
    });
    
    // Enhanced Event f√ºr Audit-Trail (√∂ffentlich)
    const event = await eventBus.publish({
      type: 'RolleWebtAktionMitPeerStatus',
      aggregateId: rolleId,
      subject: 'wg.kleinroennau.social',
      payload: { 
        rolleId, 
        aktionTyp,
        knotenId,
        strukturknotenTyp,
        peerStatus: 'pending',
        durationSec: strukturknotenTyp ? 9 : 7 // Strukturknoten-Aktionen 2s l√§nger
      }
    });
    
    // Peer-Consensus f√ºr wichtige Aktionen
    if (strukturknotenTyp || ['verzwirren', 'antrag.stellen'].includes(aktionTyp)) {
      this.requestPeerConsensus(event, rolleId);
    }
  }
  
  private async requestPeerConsensus(event: any, rolleId: string) {
    try {
      const consensus = await this.peerConsensusManager.processEvent(event);
      const rotation = this.activeRotations.get(rolleId);
      
      if (rotation) {
        rotation.peerStatus = consensus.status === 'finalized' ? 'verified' : 'failed';
      }
    } catch (error) {
      console.error('Peer consensus failed:', error);
      const rotation = this.activeRotations.get(rolleId);
      if (rotation) rotation.peerStatus = 'failed';
    }
  }
  
  private async flushRotations() {
    const toUpdate: Array<{
      rolleId: string, 
      shouldSpin: boolean, 
      aktionTyp?: string,
      strukturknotenTyp?: string,
      peerStatus?: string
    }> = [];
    const now = new Date();
    
    for (const [rolleId, rotation] of this.activeRotations.entries()) {
      const duration = rotation.strukturknotenTyp ? 9000 : 7000; // Erweiterte Dauer f√ºr Strukturknoten
      const elapsed = now.getTime() - rotation.triggeredAt.getTime();
      
      if (elapsed >= duration) {
        // Drehung beendet
        this.activeRotations.delete(rolleId);
        toUpdate.push({ rolleId, shouldSpin: false });
      } else if (!rotation.broadcasted) {
        // Neue Drehung starten
        rotation.broadcasted = true;
        toUpdate.push({ 
          rolleId, 
          shouldSpin: true, 
          aktionTyp: rotation.aktionTyp,
          strukturknotenTyp: rotation.strukturknotenTyp,
          peerStatus: rotation.peerStatus
        });
      } else if (rotation.peerStatus !== 'pending') {
        // Peer-Status-Update
        toUpdate.push({
          rolleId,
          shouldSpin: true,
          peerStatus: rotation.peerStatus
        });
      }
    }
    
    if (toUpdate.length > 0) {
      await this.websocketManager.broadcast('enhanced-role-action', {
        updates: toUpdate,
        timestamp: now.getTime(),
        hasPeerUpdates: toUpdate.some(u => u.peerStatus),
        hasStructuralUpdates: toUpdate.some(u => u.strukturknotenTyp)
      });
    }
  }
}
```

### 4.3 Erweiterte Database Schema mit Strukturknoten & Peer-Verifikation

```sql
-- Erweiterte Enums f√ºr Strukturknoten
CREATE TYPE knoten_typ AS ENUM (
  'idee','veranstaltung','ressource','schlafplatz',
  'gewebekonto','webrat','naehstuebchen' -- Neue Strukturknoten-Typen
);

CREATE TYPE faden_subtype AS ENUM (
  'gespr√§ch','gestaltung','ver√§nderung','antrag','abstimmung','gold','delegation'
);

CREATE TYPE strukturknoten_typ AS ENUM ('gewebekonto','webrat','naehstuebchen');

-- Core Tables mit Strukturknoten-Support
CREATE TABLE knoten (
  id UUID PRIMARY KEY,
  typ knoten_typ NOT NULL,
  title TEXT NOT NULL,
  content JSONB,
  coords GEOGRAPHY(POINT) NOT NULL,
  h3 BIGINT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  kind TEXT CHECK (kind IN ('standard','gewebekonto','webrat','naehstuebchen')),
  is_structural BOOLEAN DEFAULT FALSE, -- Strukturknoten sind permanent
  fade_started_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ,
  last_linked_at TIMESTAMPTZ,
  has_garn BOOLEAN DEFAULT FALSE,
  peer_signatures JSONB DEFAULT '[]' -- Ed25519-Signaturen f√ºr kritische Knoten
);

-- Strukturknoten haben spezielle Constraints
ALTER TABLE knoten ADD CONSTRAINT strukturknoten_permanent 
  CHECK (NOT is_structural OR (is_structural AND expires_at IS NULL));

-- Erweiterte F√§den-Tabelle mit Strukturknoten-Awareness
CREATE TABLE faeden (
  id UUID PRIMARY KEY,
  from_rolle UUID REFERENCES rollen(id) NOT NULL,
  to_knoten UUID REFERENCES knoten(id) NOT NULL,
  subtype faden_subtype NOT NULL,
  content TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  expires_at TIMESTAMPTZ NOT NULL,
  is_garn BOOLEAN DEFAULT FALSE,
  is_structural_connection BOOLEAN DEFAULT FALSE, -- Verbindung zu Strukturknoten
  structural_type strukturknoten_typ, -- Typ des Ziel-Strukturknotens
  routing_metadata JSONB, -- Zus√§tzliche Routing-Info f√ºr Strukturknoten
  peer_verified BOOLEAN DEFAULT FALSE,
  peer_signatures JSONB DEFAULT '[]'
);

-- Erweiterte Verzwirn-Schutz mit Peer-Konsens
CREATE TABLE verzwirnungen (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  knoten_id UUID NOT NULL REFERENCES knoten(id) ON DELETE CASCADE,
  rolle_id UUID NOT NULL REFERENCES rollen(id),
  scope JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  peer_signatures JSONB DEFAULT '[]',
  consensus_achieved BOOLEAN DEFAULT FALSE,
  is_structural BOOLEAN DEFAULT FALSE,
  required_peer_count INTEGER DEFAULT 2,
  
  CONSTRAINT verzwirnungen_scope_format CHECK (
    (jsonb_typeof(scope) = 'object' AND scope ? 'full') OR
    (jsonb_typeof(scope) = 'array' AND jsonb_array_length(scope) > 0)
  ),
  
  -- Strukturknoten erfordern erh√∂hte Peer-Anzahl
  CONSTRAINT structural_peer_requirement CHECK (
    NOT is_structural OR required_peer_count >= 3
  )
);

-- Peer-Network-Tabellen
CREATE TABLE peers (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  endpoint TEXT NOT NULL, -- NATS-Endpoint
  public_key TEXT NOT NULL, -- Ed25519 Public Key
  is_active BOOLEAN DEFAULT TRUE,
  last_seen TIMESTAMPTZ DEFAULT now(),
  trust_score FLOAT DEFAULT 1.0, -- Byzantine-Toleranz-Metric
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE peer_consensus_log (
  id UUID PRIMARY KEY,
  event_id UUID NOT NULL,
  peer_id UUID REFERENCES peers(id),
  validation_result JSONB NOT NULL,
  signature TEXT NOT NULL, -- Ed25519-Signatur
  responded_at TIMESTAMPTZ DEFAULT now(),
  is_byzantine_suspect BOOLEAN DEFAULT FALSE
);

-- Enhanced Mehrfachf√§den-View mit Strukturknoten-Priorit√§t
CREATE MATERIALIZED VIEW enhanced_mehrfach_faeden AS
SELECT 
  from_rolle, 
  to_knoten,
  array_agg(id ORDER BY 
    CASE WHEN is_structural_connection THEN 0 ELSE 1 END,
    created_at
  ) as faden_ids,
  array_agg(subtype ORDER BY 
    CASE WHEN is_structural_connection THEN 0 ELSE 1 END,
    created_at
  ) as subtypen,
  count(*) as faden_count,
  max(created_at) as latest_created_at,
  bool_or(is_structural_connection) as has_structural_connection,
  (SELECT structural_type FROM faeden f2 WHERE f2.from_rolle = faeden.from_rolle 
   AND f2.to_knoten = faeden.to_knoten AND f2.is_structural_connection LIMIT 1) as structural_type
FROM faeden 
WHERE expires_at > now() OR is_garn = true
GROUP BY from_rolle, to_knoten
HAVING count(*) > 1;

-- Direkte Demokratie-Tabellen (erweitert)
CREATE TABLE antraege (
  id UUID PRIMARY KEY,
  titel TEXT NOT NULL,
  inhalt TEXT NOT NULL,
  antragsteller UUID REFERENCES rollen(id) NOT NULL,
  status antrag_status NOT NULL DEFAULT 'offen',
  weavery_h3 BIGINT NOT NULL,
  action JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  einspruch_bis TIMESTAMPTZ, -- Kann NULL sein f√ºr sofortige Abstimmungen
  abstimmung_start TIMESTAMPTZ,
  abstimmung_ende TIMESTAMPTZ,
  sofortige_demokratie BOOLEAN DEFAULT FALSE, -- Neues Feature!
  peer_signatures JSONB DEFAULT '[]'
);

-- Strukturknoten-spezifische Tabellen
CREATE TABLE strukturknoten_interaktionen (
  id UUID PRIMARY KEY,
  strukturknoten_id UUID REFERENCES knoten(id) NOT NULL,
  strukturknoten_typ strukturknoten_typ NOT NULL,
  rolle_id UUID REFERENCES rollen(id) NOT NULL,
  interaktions_typ TEXT NOT NULL, -- 'goldfaden_routing', 'antrag_routing', 'diskussion_start'
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT now(),
  peer_verified BOOLEAN DEFAULT FALSE
);

-- Gewebekonto-spezifische Erweiterungen
CREATE TABLE gewebekonto_transaktionen (
  id UUID PRIMARY KEY,
  gewebekonto_id UUID REFERENCES knoten(id) NOT NULL,
  von_rolle UUID REFERENCES rollen(id),
  zu_knoten UUID REFERENCES knoten(id),
  betrag_cents INTEGER NOT NULL,
  beschreibung TEXT,
  goldfaden_id UUID REFERENCES faeden(id),
  status zahlung_status DEFAULT 'initiated',
  created_at TIMESTAMPTZ DEFAULT now(),
  peer_signatures JSONB DEFAULT '[]'
);

-- Performance-Indizes
CREATE INDEX IF NOT EXISTS idx_faeden_structural ON faeden(is_structural_connection, structural_type);
CREATE INDEX IF NOT EXISTS idx_knoten_structural ON knoten(is_structural, typ);
CREATE INDEX IF NOT EXISTS idx_peer_consensus_event ON peer_consensus_log(event_id);
CREATE INDEX IF NOT EXISTS idx_strukturknoten_interaktionen_typ ON strukturknoten_interaktionen(strukturknoten_typ, created_at);
```

### 4.4 Erweiterte API-Endpoints mit Strukturknoten & Peer-Verifikation

```typescript
// Enhanced Guards mit Strukturknoten-Awareness
async function guardPatchWithStructuralConsensus(
  knotenId: string, 
  patchOps: any[], 
  etag: string,
  requirePeerConsensus: boolean = false
) {
  // Standard ETag-Pflicht
  if (!etag) {
    throw new HTTPError(428, { 
      code: 'missing_etag',
      hint: 'Include If-Match header with current ETag'
    });
  }
  
  const knoten = await db.knoten.findUnique({
    where: { id: knotenId },
    include: { 
      verzwirnungen: true,
      strukturknoten_interaktionen: knoten.is_structural 
    }
  });
  
  if (!knoten) {
    throw new HTTPError(404, { code: 'knoten_not_found' });
  }
  
  // ETag-Check
  const currentETag = generateKnotenEtag(knoten);
  if (etag !== currentETag) {
    throw new HTTPError(409, {
      code: 'version_conflict',
      serverETag: currentETag,
      clientETag: etag,
      hint: 'Fetch latest version and retry'
    });
  }
  
  // Enhanced Verzwirn-Schutz mit Strukturknoten-Logik
  const verzwirntePfade = extractVerzwirntePfade(knoten.verzwirnungen);
  
  // Strukturknoten haben erweiterten Schutz
  if (knoten.is_structural) {
    const structuralProtectedPaths = ['/.type', '/.coords', '/.title'];
    verzwirntePfade.push(...structuralProtectedPaths);
  }
  
  for (const op of patchOps) {
    if (isVerzwirnt(op.path, verzwirntePfade)) {
      throw new HTTPError(409, {
        code: 'locked_by_verzwirnung',
        lockedPath: op.path,
        isStructural: knoten.is_structural,
        paths: verzwirntePfade.filter(p => isVerzwirnt(op.path, [p]))
      });
    }
  }
  
  // Strukturknoten-√Ñnderungen erfordern Peer-Konsens
  if (knoten.is_structural && requirePeerConsensus) {
    const peerResult = await peerConsensusManager.requestConsensus({
      type: 'strukturknoten_change',
      knotenId,
      patchOps,
      etag
    });
    
    if (!peerResult.consensusAchieved) {
      throw new HTTPError(409, {
        code: 'peer_consensus_required',
        peerStatus: peerResult.status,
        requiredQuorum: peerResult.requiredQuorum
      });
    }
  }
  
  return knoten;
}

// PATCH /api/knoten/:id (erweitert f√ºr Strukturknoten)
app.patch('/api/knoten/:id', async (req, reply) => {
  const { id } = req.params as { id: string };
  const patchOps = req.body as any[];
  const etag = req.headers['if-match'];
  const forcePeerConsensus = req.headers['x-require-peer-consensus'] === 'true';
  
  try {
    const knoten = await guardPatchWithStructuralConsensus(
      id, 
      patchOps, 
      etag, 
      forcePeerConsensus
    );
    
    // JSON Patch anwenden
    const updated = applyPatch(knoten, patchOps);
    
    await db.knoten.update({
      where: { id },
       {
        content: updated.content,
        updated_at: new Date()
      }
    });
    
    // Enhanced Event mit Strukturknoten-Info
    const event = await eventBus.publish({
      type: knoten.is_structural ? 'StrukturknotenGeaendert' : 'KnotenGeaendert',
      aggregateId: id,
      payload: { 
        patch: patchOps,
        isStructural: knoten.is_structural,
        strukturknotenTyp: knoten.is_structural ? knoten.typ : null
      },
      meta: { actor: req.user.rolleId }
    });
    
    // Enhanced Webungs-Rotation mit Strukturknoten-Typ
    await webungsRotationManager.triggerWebungsRotation(
      req.user.rolleId, 
      'knoten.patch',
      id,
      knoten.is_structural ? knoten.typ : undefined
    );
    
    const newETag = generateKnotenEtag(updated);
    reply.header('ETag', newETag);
    reply.send({ 
      success: true, 
      etag: newETag,
      isStructural: knoten.is_structural,
      peerVerified: forcePeerConsensus
    });
    
  } catch (error) {
    if (error instanceof HTTPError) {
      reply.code(error.statusCode).send(error.payload);
    } else {
      reply.code(500).send({ code: 'internal_error' });
    }
  }
});

// POST /api/antraege (Sofortige Demokratie)
app.post('/api/antraege', async (req, reply) => {
  const { titel, inhalt, action, sofortige_abstimmung } = req.body;
  const idempotencyKey = req.headers['idempotency-key'];
  
  if (!idempotencyKey) {
    return reply.code(400).send({ code: 'missing_idempotency_key' });
  }
  
  const antrag = await db.antraege.create({
     {
      titel,
      inhalt,
      action,
      antragsteller: req.user.rolleId,
      weavery_h3: req.body.weavery_h3,
      sofortige_demokratie: sofortige_abstimmung === true,
      // Sofortige Abstimmung aktiviert bei entsprechendem Flag
      abstimmung_start: sofortige_abstimmung ? new Date() : undefined,
      abstimmung_ende: sofortige_abstimmung 
        ? new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) 
        : undefined
    }
  });
  
  // Event + Strukturknoten-Faden zum Webrat
  await eventBus.publish({
    type: sofortige_abstimmung ? 'AntragSofortAktiviert' : 'AntragGestellt',
    aggregateId: antrag.id,
    payload: { 
      antragId: antrag.id,
      titel,
      sofortigeDemokratie: sofortige_abstimmung,
      webratRouting: true
    },
    meta: { actor: req.user.rolleId }
  });
  
  // Struktureller Antragsfaden zum Webrat-Knoten
  const webratKnoten = await getWebratStrukturknoten();
  await createStructuralFaden(
    req.user.rolleId,
    webratKnoten.id,
    'antrag',
    { antragId: antrag.id, sofortig: sofortige_abstimmung }
  );
  
  // Enhanced Webungs-Rotation f√ºr Antragsstellung
  await webungsRotationManager.triggerWebungsRotation(
    req.user.rolleId, 
    'antrag.stellen',
    webratKnoten.id,
    'webrat'
  );
  
  reply.send({ 
    success: true, 
    antrag,
    sofortigeDemokratie: sofortige_abstimmung,
    webratConnected: true
  });
});

// POST /api/strukturknoten/:typ/interact (Neue API f√ºr Strukturknoten-Interaktionen)
app.post('/api/strukturknoten/:typ/interact', async (req, reply) => {
  const { typ } = req.params as { typ: strukturknoten_typ };
  const { interaktionsTyp, metadata } = req.body;
  
  const strukturknoten = await getStrukturknotenByTyp(typ);
  if (!strukturknoten) {
    return reply.code(404).send({ code: 'strukturknoten_not_found' });
  }
  
  // Spezifische Logik je Strukturknoten-Typ
  let result;
  switch (typ) {
    case 'gewebekonto':
      result = await handleGewebekontoInteraktion(
        strukturknoten.id,
        req.user.rolleId,
        interaktionsTyp,
        metadata
      );
      break;
    case 'webrat':
      result = await handleWebratInteraktion(
        strukturknoten.id,
        req.user.rolleId,
        interaktionsTyp,
        metadata
      );
      break;
    case 'naehstuebchen':
      result = await handleNaehstuebchenInteraktion(
        strukturknoten.id,
        req.user.rolleId,
        interaktionsTyp,
        metadata
      );
      break;
  }
  
  // Struktureller Faden zur Interaktion
  await createStructuralFaden(
    req.user.rolleId,
    strukturknoten.id,
    getSubtypeForInteraktion(interaktionsTyp),
    metadata
  );
  
  // Webungs-Rotation mit Strukturknoten-Kontext
  await webungsRotationManager.triggerWebungsRotation(
    req.user.rolleId,
    `${typ}.${interaktionsTyp}`,
    strukturknoten.id,
    typ
  );
  
  reply.send({
    success: true,
    result,
    strukturknotenTyp: typ,
    fadenCreated: true
  });
});
```

***

## 5) Performance & Monitoring

### 5.1 Enhanced Prometheus Metriken mit Strukturknoten & Peer-Verifikation

```typescript
export const enhancedMetrics = {
  // Strukturknoten-spezifische Metriken
  strukturknotenInteraktionen: new Counter({
    name: 'wg_strukturknoten_interactions_total',
    help: 'Interaktionen mit Strukturknoten',
    labelNames: ['strukturknoten_typ', 'interaktions_typ']
  }),
  
  gewebekontoTransaktionen: new Counter({
    name: 'wg_gewebekonto_transactions_total', 
    help: 'Goldfaden-Transaktionen √ºber Gewebekonto',
    labelNames: ['status', 'betrag_range']
  }),
  
  webratAktivitaet: new Gauge({
    name: 'wg_webrat_active_votes',
    help: 'Aktive Abstimmungen im Webrat'
  }),
  
  naehstuebchenThreads: new Gauge({
    name: 'wg_naehstuebchen_active_threads',
    help: 'Aktive Diskussions-Threads im N√§hst√ºbchen'  
  }),
  
  // Peer-Verifikations-Metriken
  peerConsensusLatency: new Histogram({
    name: 'wg_peer_consensus_duration_ms',
    help: 'Zeit f√ºr Peer-Consensus-Prozess',
    buckets: [50, 100, 250, 500, 1000, 2000]
  }),
  
  peerQuorumSuccess: new Counter({
    name: 'wg_peer_quorum_achieved_total',
    help: 'Erfolgreich erreichte Peer-Quoren',
    labelNames: ['event_type', 'quorum_size']
  }),
  
  byzantineFaults: new Counter({
    name: 'wg_byzantine_faults_detected_total',
    help: 'Erkannte Byzantine-Faults',
    labelNames: ['fault_type', 'peer_id']
  }),
  
  peerNetworkHealth: new Gauge({
    name: 'wg_peer_network_health_score',
    help: 'Peer-Network-Gesundheits-Score (0-1)'
  }),
  
  // Enhanced Webungs-Rotation Metriken
  strukturelleRotationen: new Counter({
    name: 'wg_structural_rotations_total',
    help: 'Webungs-Rotationen f√ºr Strukturknoten-Interaktionen',
    labelNames: ['strukturknoten_typ', 'aktion_typ']
  }),
  
  rotationsDurationByType: new Histogram({
    name: 'wg_rotation_duration_by_type_ms',
    help: 'Rotations-Dauer nach Typ (7s standard, 9s strukturell)',
    labelNames: ['rotation_type'],
    buckets: [6000, 7000, 8000, 9000, 10000]
  }),
  
  // Direkte Demokratie-Metriken  
  sofortigeAbstimmungen: new Counter({
    name: 'wg_immediate_democracy_votes_total',
    help: 'Sofortig aktivierte Abstimmungen',
    labelNames: ['trigger_type']
  }),
  
  demokratieLatenz: new Histogram({
    name: 'wg_democracy_response_time_ms', 
    help: 'Zeit von Antrag bis Abstimmungsstart',
    buckets: [0, 1000, 5000, 10000, 60000] // 0ms f√ºr sofortige Demokratie!
  }),
  
  abstimmungsBeteiligung: new Histogram({
    name: 'wg_vote_participation_rate',
    help: 'Beteiligungsrate bei Abstimmungen (0-1)',
    buckets: [0.1, 0.2, 0.3, 0.5, 0.7, 0.9, 1.0]
  }),
  
  // Enhanced Mehrfachf√§den-Metriken
  strukturelleMehrfachfaeden: new Gauge({
    name: 'wg_structural_multi_threads',
    help: 'Mehrfachf√§den zu Strukturknoten',
    labelNames: ['strukturknoten_typ']
  }),
  
  fadenRoutingEffizienz: new Histogram({
    name: 'wg_faden_routing_efficiency_ms',
    help: 'Effizienz des Faden-Routings √ºber Strukturknoten',
    buckets: [10, 25, 50, 100, 250]
  }),
  
  // System-Performance mit Peer-Awareness
  eventVerificationLatency: new Histogram({
    name: 'wg_event_verification_latency_ms',
    help: 'Ed25519-Signatur-Verifikations-Zeit',
    buckets: [1, 5, 10, 25, 50, 100]
  }),
  
  strukturknotenRenderTime: new Histogram({
    name: 'wg_strukturknoten_render_duration_ms', 
    help: 'Render-Zeit f√ºr Strukturknoten-Visualisierung',
    buckets: [50, 100, 200, 500, 1000]
  })
};
```

### 5.2 Erweiterte Alerting Rules mit Strukturknoten & Peer-Network

```yaml
# enhanced-alerts.yml
groups:
- name: weltgewebe-enhanced.rules
  rules:
  
  # Strukturknoten-Alerts
  - alert: StrukturknotenNichtErreichbar
    expr: up{job="strukturknoten"} == 0
    for: 2m
    labels:
      severity: critical
    annotations:
      summary: "Strukturknoten {{ $labels.strukturknoten_typ }} nicht erreichbar"
      description: "Kritische Infrastruktur ausgefallen"
      
  - alert: GewebekontoTransaktionsStau
    expr: rate(wg_gewebekonto_transactions_total[5m]) == 0 and wg_gewebekonto_pending_count > 5
    for: 10m
    labels:
      severity: warning
    annotations:
      summary: "Gewebekonto-Transaktionen stocken"
      description: "{{ $value }} Transaktionen warten"
      
  - alert: WebratAbstimmungsr√ºckstand
    expr: wg_webrat_active_votes > 10
    for: 1h
    labels:
      severity: info
    annotations:
      summary: "Viele offene Abstimmungen im Webrat"
      description: "{{ $value }} Abstimmungen brauchen Aufmerksamkeit"
  
  # Peer-Network-Alerts
  - alert: PeerConsensusLatenzHoch
    expr: histogram_quantile(0.95, wg_peer_consensus_duration_ms) > 2000
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "Peer-Consensus zu langsam"
      description: "P95 Consensus-Zeit: {{ $value }}ms"
      
  - alert: ByzantineFaultErkannt
    expr: increase(wg_byzantine_faults_detected_total[10m]) > 0
    for: 0s
    labels:
      severity: critical
    annotations:
      summary: "Byzantine Fault im Peer-Network erkannt!"
      description: "Peer {{ $labels.peer_id }} verd√§chtig"
      
  - alert: PeerNetworkGesundheitNiedrig
    expr: wg_peer_network_health_score < 0.7
    for: 15m
    labels:
      severity: warning
    annotations:
      summary: "Peer-Network-Gesundheit niedrig"
      description: "Health Score: {{ $value }}"
      
  - alert: QuorumNichtErreichbar
    expr: rate(wg_peer_quorum_achieved_total[5m]) == 0 and rate(wg_events_total[5m]) > 0
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "Peer-Quorum nicht erreichbar"
      description: "Events werden erstellt aber nicht consensus-verifiziert"

  # Direkte Demokratie-Alerts
  - alert: DemokratieLatenzZuHoch
    expr: histogram_quantile(0.95, wg_democracy_response_time_ms) > 10000
    for: 10m
    labels:
      severity: warning
    annotations:
      summary: "Demokratie-Responsivit√§t zu niedrig"
      description: "P95 Antrag-zu-Abstimmung Zeit: {{ $value }}ms"
      
  - alert: NiedrigeBeteiligung
    expr: avg_over_time(wg_vote_participation_rate[1h]) < 0.2
    for: 2h
    labels:
      severity: info
    annotations:
      summary: "Niedrige Abstimmungsbeteiligung"
      description: "Durchschnittliche Beteiligung: {{ $value | humanizePercentage }}"

  # Enhanced Performance-Alerts
  - alert: StrukturknotenRenderingLangsam
    expr: histogram_quantile(0.95, wg_strukturknoten_render_duration_ms) > 500
    for: 10m
    labels:
      severity: warning
    annotations:
      summary: "Strukturknoten-Rendering langsam"
      description: "P95 Render-Zeit: {{ $value }}ms"
      
  - alert: FadenRoutingIneffizient
    expr: histogram_quantile(0.95, wg_faden_routing_efficiency_ms) > 100
    for: 15m
    labels:
      severity: info
    annotations:
      summary: "Faden-Routing √ºber Strukturknoten ineffizient"
      
  - alert: Ed25519VerifikationLangsam
    expr: histogram_quantile(0.95, wg_event_verification_latency_ms) > 50
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "Ed25519-Signatur-Verifikation zu langsam"
      description: "P95 Verifikations-Zeit: {{ $value }}ms"
```

***

## 6) Implementierungsplan & Phasen

### 6.1 Phase A: Vollst√§ndige Lokale Weberei mit Strukturknoten (0-10 Wochen)

**Sprint 1-2: Strukturknoten-Fundament (Wochen 1-2)**
- ‚úÖ Strukturknoten-Typen (Gewebekonto, Webrat, N√§hst√ºbchen) als permanente Kartenelemente
- ‚úÖ Erweiterte Event-Schema mit strukturellen Flags
- ‚úÖ Database-Migration f√ºr Strukturknoten-Support
- ‚úÖ Strukturknoten-spezifische API-Endpoints

**Sprint 3-4: Peer-Verifikation & Ed25519 (Wochen 3-4)**
- ‚úÖ Ed25519-Signatur-Integration in Event-System  
- ‚úÖ Peer-Consensus-Manager mit Byzantine-Toleranz
- ‚úÖ Peer-Network-Tabellen und -API
- ‚úÖ WebAuthn-Integration mit Ed25519-Support

**Sprint 5-6: Direkte Demokratie-Revolution (Wochen 5-6)**
- ‚úÖ Sofortige Abstimmungsaktivierung nach Einspruch
- ‚úÖ Webrat-Integration f√ºr Governance-Workflows
- ‚úÖ Enhanced Governance-UI mit Live-Abstimmungen
- ‚úÖ Antragsf√§den zu Webrat-Strukturknoten

**Sprint 7-8: Erweiterte Webungs-Rotation & Mehrfachf√§den (Wochen 7-8)**
- ‚úÖ Strukturknoten-aware Webungs-Rotation (9s f√ºr strukturelle Aktionen)
- ‚úÖ Progressive Mehrfachf√§den-√úberlappung mit Strukturknoten-Priorit√§t
- ‚úÖ MapLibre-Performance-Optimierungen
- ‚úÖ Peer-Status in Garnrollen-Visualisierung

**Sprint 9-10: Integration & Polish (Wochen 9-10)**
- ‚úÖ Gewebekonto-Goldfaden-Integration  
- ‚úÖ N√§hst√ºbchen-Thread-Management
- ‚úÖ Erweiterte Observability mit Strukturknoten-Metriken
- ‚úÖ Vollst√§ndige A11y-Integration
- ‚úÖ Enhanced E2E-Tests f√ºr alle neuen Features

**Qualit√§ts-Gates:**
- **Strukturknoten**: Permanente Sichtbarkeit, spezifische Interaktions-UIs
- **Peer-Verifikation**: <100ms Ed25519-Verifikation, Byzantine-Toleranz bei 2/3 ehrlichen Peers
- **Direkte Demokratie**: 0ms Latenz von Einspruch zu Abstimmungsstart
- **Webungs-Rotation**: <50ms WebSocket-Latenz, korrekte 9s-Dauer f√ºr Strukturknoten
- **Mehrfachf√§den**: P95 Render-Zeit <200ms auch bei strukturellen Verbindungen
- **Performance**: Alle bestehenden Gates + strukturelle Erweiterungen

### 6.2 Phase B: Resilienz & Erweiterte Features (11-16 Wochen)

**Enhanced Features mit Strukturknoten-Integration:**
- NATS 3-Node-Cluster mit Leafnodes f√ºr Peer-F√∂deration
- PostgreSQL High-Availability mit Strukturknoten-Replikation
- WebPush-Benachrichtigungen (strukturknoten-spezifisch filterbar)
- Transitive Delegationen mit Webrat-Integration
- WebGL-Layer f√ºr >1000 aktive F√§den (inkl. Strukturknoten-Verbindungen)
- Multi-Rollen-Accounts mit struktureller Berechtigung

### 6.3 Phase C: F√∂derierte Peer-Democracy (17-24 Wochen)

**Peer-Network-Produktion:**
- Produktive Leafnode-F√∂deration mit Ed25519-Mutual-Auth
- Cross-Federation-Strukturknoten-Synchronisation  
- F√∂derierte Peer-Verifikation mit global verteilten Peers
- DNS-SRV-Discovery f√ºr Peer-Network (`_peers._tcp.weltgewebe.net`)
- F√∂derierte Webrat-Abstimmungen √ºber Instanz-Grenzen
- Cross-Instance Gewebekonto-Transaktionen

**Skalierungs-Ziele:**
- 1000+ gleichzeitige Nutzer pro Instanz
- <500ms Cross-Federation-Latenz  
- 99.9% Byzantine-Konsistenz-Rate
- Sub-‚Ç¨0.005/1000 Events bei f√∂deriertem Betrieb

***

## 7) Schlusswort & Vision

### 7.1 Revolution√§re Neuerungen v14.3

**üèõÔ∏è Strukturknoten als permanente Ankerpunkte**: Gewebekonto, Webrat und N√§hst√ºbchen schaffen sichtbare institutionelle Orientierung und erm√∂glichen strukturiertes kollektives Handeln[2].

**‚ö° Wahrhaft direkte Demokratie**: Die sofortige Abstimmungsaktivierung nach Einspruch eliminiert k√ºnstliche Verz√∂gerungen und maximiert demokratische Responsivit√§t - 0ms Latenz vom Einspruch zur Partizipation[2].

**üîí Byzantine-tolerante Peer-Verifikation**: Ed25519-basierte Konsistenz mit mathematischen Sicherheitsgarantien schafft Vertrauen ohne zentrale Autorit√§t[2].

**üéØ Strukturknoten-bewusste Performance**: Intelligente Mehrfachf√§den-Algorithmen mit Strukturknoten-Priorit√§t und erweiterte Webungs-Rotationen (9s f√ºr strukturelle Aktionen) skalieren elegant[1][2].

**üí° Ko-konstruktive Innovation**: Die Synthese aus v14.1 und v14.2 schafft ein koh√§rentes System aus sichtbarer Aktivit√§t, granularem Schutz und sofortiger Partizipation.

### 7.2 Technische Exzellenz-Evolution

**Event-Sourcing mit Kryptographie**: Jede Aktion wird unver√§nderlich, nachvollziehbar und kryptographisch signiert dokumentiert - von lokaler Einzelinstanz zu f√∂deriertem Peer-Network ohne Breaking Changes[1][2].

**Strukturknoten-Architektur**: Permanente Ankerpunkte schaffen semantische Klarheit und erm√∂glichen spezialisierten Workflow-Integration (Goldf√§den‚ÜíGewebekonto, Antr√§ge‚ÜíWebrat, Diskussionen‚ÜíN√§hst√ºbchen)[2].

**Progressive Enhancement**: Alle Funktionen arbeiten lokal und f√∂deriert - mit graceful degradation bei Peer-Network-Ausf√§llen[2].

**Accessibility & Inclusion**: Reduced-motion-Unterst√ºtzung, Strukturknoten-spezifische Screenreader-Labels und vollst√§ndige Keyboard-Navigation erm√∂glichen universelle Teilhabe[1][2].

### 7.3 Demokratie-Revolution durch Technologie

Das Weltgewebe v14.3 realisiert **direkte partizipative Demokratie ohne Wartezeiten** durch pr√§zise technologische Implementation. Strukturknoten machen Institutionen sichtbar und verkn√ºpfbar. Peer-Verifikation schafft Byzantine-tolerantes Vertrauen. Webungs-Rotationen visualisieren lebendiges Engagement mit struktureller Awareness.

**Die Ko-Konstruktion aus granularem Schutz (v14.1), direkter Demokratie (v14.2) und struktureller Klarheit erreicht eine neue Qualit√§t kollektiver Intelligenz bei individueller Autonomie.**

Wo traditionelle Systeme k√ºnstliche Verz√∂gerungen und zentrale Kontrolle einbauen, erm√∂glicht das Weltgewebe **sofortige Reaktion und dezentrale Konsistenz**. Die Strukturknoten werden zu lebendigen Organen einer selbstorganisierenden Gesellschaft.

### 7.4 Vision: Lebendiger Organismus kollektiven Handelns

Das Weltgewebe v14.3 ist mehr als Software - es ist **lebende Infrastruktur f√ºr eine Gesellschaft, die sich selbst webt**. Jede Webung wird durch Rotation sichtbar, jede Verzwirnung sch√ºtzt granular, jeder Antrag kann sofort zur Abstimmung, jeder Strukturknoten organisiert kollektive Intelligenz.

**‚à¥ Wo Webungen Aktivit√§t zeigen, Strukturen Orientierung geben, Peers Vertrauen schaffen und Demokratie sofort wirkt ‚Äì das Weltgewebe als selbstwirkender Organismus kollektiven Handelns von der Nachbarschaft bis zum globalen Myzel! üßµ‚ö°üèõÔ∏èüîí**

***

*v14.3 ‚Äì Ko-konstruktive Vollendung: Strukturelle Klarheit trifft direkte Demokratie mit Byzantine-toleranter Sicherheit*

*Die Weltweberei wird direkter, sichtbarer, strukturierter und sicherer ‚Äì jede Webung dreht die Rolle, jede Verzwirnung bewahrt Wertvolles, jeder Antrag wirkt sofort, jeder Strukturknoten organisiert Kollektiv-Intelligenz, jeder Peer verifiziert Vertrauen!*


hier ist der ‚Äûkomplette DSGVO‚ÄëPatch‚Äú f√ºr v14_3, strikt eventbasiert (keine In‚Äëplace‚Äë√Ñnderungen), mobile‚Äëfirst und im Einklang mit eurer Logik (Rollen als Marker auf der Karte, F√§den/Garn, Strukturknoten, 7‚ÄëTage‚ÄëAlpha‚ÄëVerfall, Sofort‚ÄëAbstimmung etc.). Ich markiere nur die Stellen, die ihr erg√§nzen m√ºsst.

# 1) Neue Events (Append‚Äëonly)

```jsonc
// Einwilligung & Transparenz
{ "type":"ConsentGiven", "aggregateId":"rolle-uuid", "payload": { "scope":"profile_public|geo_public|graph_public|donation_public|analytics_min", "policyVersion":"2025-08-21", "lang":"de" }, "meta":{...} }
{ "type":"ConsentWithdrawn", "aggregateId":"rolle-uuid", "payload": { "scope":"..." }, "meta":{...} }

// Betroffenenrechte
{ "type":"DSR_AccessRequested", "aggregateId":"rolle-uuid", "payload":{ "channel":"inapp" }, "meta":{...} }
{ "type":"DSR_DataExportReady", "aggregateId":"rolle-uuid", "payload":{ "url":"signed://export.json", "expiresAt":"..." }, "meta":{...} }
{ "type":"DSR_RectificationApplied", "aggregateId":"rolle-uuid", "payload":{ "fields":["name","address"] }, "meta":{...} }

// Anonymisierung / ‚ÄûRollenl√∂schung‚Äú (l√∂scht PII, erh√§lt Graph & Verortung)
{ "type":"RolePseudonymizationRequested", "aggregateId":"rolle-uuid", "payload":{ "reason":"erasure_request" }, "meta":{...} }
{ "type":"RolePseudonymized", "aggregateId":"rolle-uuid", "payload":{
    "displayName":"Anonym‚ÄëRolle‚Äë9Q3",            // generiert
    "avatar":"anon", 
    "geoMode":"h3_generalized",                  // H3 auf gr√∂bere Aufl√∂sung
    "h3Resolution":6,
    "linkToPII":"removed"                        // Mapping entfernt
  }, "meta":{...} }

// Volle Account‚ÄëBeendigung (kein neuer Faden mehr)
{ "type":"RoleTombstoned", "aggregateId":"rolle-uuid", "payload":{ "reason":"user_request" }, "meta":{...} }

// Pflicht: Audit
{ "type":"DSR_ErasureCompleted", "aggregateId":"rolle-uuid", "payload":{ "method":"key_wipe|row_delete", "at":"..." }, "meta":{...} }
```

Warum passt das zu v14_3? Ihr bleibt bei ‚ÄûAlles ist Event‚Äú (Append‚Äëonly), F√§den bleiben als Events bestehen, Sofort‚ÄëAbstimmungen etc. unver√§ndert. Die Projektionen entscheiden nur, **wie** etwas dargestellt/aufgel√∂st wird, nicht **ob** ein Event existiert. Rollen sind weiterhin als Marker verortet; nur die PII‚ÄëBindung wird gel√∂st und die H3‚ÄëAufl√∂sung ggf. vergr√∂bert (Karte + F√§den/Garn bleiben konform zu eurer UI‚ÄëBeschreibung mit Strukturknoten, Alpha‚ÄëVerfall, Webungs‚ÄëRotation usw.).

# 2) Storage‚ÄëTrennung & Migration

**Ziel:** Pseudonyme Event‚ÄëIDs im Log; PII in separatem Store, der l√∂sch‚Äë/entkoppelbar ist.

```sql
-- PII getrennt (l√∂schen/anonymisieren m√∂glich)
CREATE TABLE personal_identity (
  rolle_id UUID PRIMARY KEY,
  full_name TEXT,
  street TEXT,
  zip TEXT,
  city TEXT,
  country TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Einwilligungen versioniert
CREATE TABLE consent_log (
  id BIGSERIAL PRIMARY KEY,
  rolle_id UUID NOT NULL,
  scope TEXT NOT NULL,                 -- z.B. 'geo_public'
  granted BOOLEAN NOT NULL,
  policy_version TEXT NOT NULL,
  at TIMESTAMPTZ DEFAULT now()
);

-- Erasure/Audit
CREATE TABLE dsr_audit (
  id BIGSERIAL PRIMARY KEY,
  rolle_id UUID,
  kind TEXT NOT NULL,                  -- access|export|rectification|erasure
  status TEXT NOT NULL,                -- requested|done|rejected
  note TEXT,
  at TIMESTAMPTZ DEFAULT now()
);

-- Projektion: Rollenmarker (was die Karte liest)
CREATE TABLE role_projection (
  rolle_id UUID PRIMARY KEY,
  display_name TEXT,
  avatar TEXT,
  h3 BIGINT,                           -- ggf. generalisiert
  h3_resolution INT,                   -- original vs generalisiert
  anonymized BOOLEAN DEFAULT FALSE,
  tombstoned BOOLEAN DEFAULT FALSE
);
```

**Erasure‚ÄëPfad (PII):**

- `DELETE FROM personal_identity WHERE rolle_id = $1;`
- `UPDATE role_projection SET anonymized = TRUE, display_name = 'Anonym‚ÄëRolle‚Äë‚Ä¶', avatar='anon', h3_resolution = GREATEST(h3_resolution, 6) WHERE rolle_id = $1;`
- `INSERT DSR_ErasureCompleted ‚Ä¶`

Damit ist die **Re‚ÄëIdentifizierbarkeit** aus den √∂ffentlich sichtbaren Layers stark reduziert, der √∂ffentliche Graph bleibt nutzbar (F√§den/Garn + Strukturknoten‚ÄëBez√ºge bleiben funktional).

# 3) Projektions‚ÄëRegeln (Renderer & API)

**Map/Renderer:**

```ts
// Beim Laden der Rollen‚ÄëMarker
if (role.tombstoned) skip();                 // keine neuen Webungen
const center = h3ToGeo(role.h3);             // H3-Zellenmittelpunkt
drawMarker({ pos:center, avatar: role.anonymized ? 'anon' : role.avatar, label: role.display_name });

// F√§den von/an Rolle:
for (const faden of getF√§den(rolle_id)) {
  const from = center;                        // Start bleibt Zellenmittelpunkt
  const to   = resolveKnotenPos(faden.to);    // Knoten/Strukturknoten unver√§ndert
  drawFaden(from, to, faden.kind);            // Farben/Alpha wie gehabt
}
```

**API Check (Zugriff auf PII):**

```ts
GET /api/me/profile  // nur eigene PII
GET /api/me/export   // JSON-Export
POST /api/me/rectify // Teilkorrektur
POST /api/me/erase   // l√∂st RolePseudonymized + PII-Delete + Tombstone optional
POST /api/me/consent // ConsentGiven/Withdrawn
```

# 4) Logging & Minimierung

- IP/User‚ÄëAgent nur als **Hash mit rotierendem Salt** (t√§glicher Salt‚ÄëRoll; Retention 7 Tage), wie euer Event‚ÄëSchema schon andeutet (ipHash/uaHash).
- **Keine** Roh‚ÄëIP im Event‚ÄëLog; Serverlogs getrennt, kurzlebig.

# 5) Einwilligungen (granular, versioniert)

Scopes (Beispiele):

- `profile_public` (Name/Avatar √∂ffentlich)
- `geo_public` (wohnortverortete Rolle √∂ffentlich)
- `graph_public` (sichtbare F√§den/Garn von/zu der Rolle)
- `donation_public` (Goldf√§den sichtbar)
- `analytics_min` (rein technische, pseudonyme Nutzungsdaten)

UI (Drawer ‚ÄûDatenschutz & Sichtbarkeit‚Äú):

- Kippschalter je Scope + Link ‚ÄûDaten exportieren‚Äú, ‚ÄûDaten berichtigen‚Äú, ‚ÄûAnonymisieren‚Äú, ‚ÄûKonto beenden‚Äú (l√∂sen die Events aus).
- Standard: **Opt‚Äëin** f√ºr √∂ffentlich sichtbare PII/Geo. Anonyme Nutzung bleibt m√∂glich (‚ÄûWeiter ohne Konto‚Äú) ‚Äì existiert bei euch schon.

# 6) Recht auf L√∂schung ‚Äì Minimal‚ÄëKompromiss

- **‚ÄûGarnrollenl√∂schung‚Äú** = Pseudonymisierung + Entfernen des PII‚ÄëMappings + H3‚ÄëGeneralisation + optional Tombstone.
- Events bleiben unver√§ndert im Log (Unver√§nderlichkeit), Projektion zeigt aber **keine** personenbezogenen Daten mehr. Karte bleibt konsistent (Rolle bleibt verortet, nur generalisiert). Das ist genau der Weg, den du skizziert hast. (Rollen sind auf der Karte verortet; F√§den verbinden Rolle‚ÜîKnoten/Strukturknoten; Alpha‚ÄëVerfall/Garn unver√§ndert.)

# 7) Datenportabilit√§t & Auskunft

- `DSR_AccessRequested` ‚Üí In‚ÄëApp √úbersicht aller zugeordneten Events (rollenbezogen).
- `DSR_DataExportReady` ‚Üí signierter Download (JSON + evtl. CSV f√ºr Spenden/Goldf√§den).
- Threads/Abstimmungen/Delegationen sind im Export als **Referenzen** auf Knoten/Strukturknoten enthalten. (Eure Strukturknoten/Abstimmungslogik bleibt 1:1 erhalten.)

# 8) Kinderschutz / Altersgrenze

- Consent‚ÄëFlow mit Alter 16+ (DE/EU). Unter 16 ‚Üí belegte Einwilligung eines Sorgeberechtigten erforderlich (separater `ConsentGiven` mit `scope:"guardian_approval"`).

# 9) Datenschutz‚ÄëHinweise (Textbaustein, ersetzt den bisherigen Block)

> **Datenschutz in der Weberei**  
> Wir verarbeiten nur Daten, die du selbst eintr√§gst. Es gibt kein Tracking, keine versteckten Cookies, keine Profilbildung. Sichtbar ist nur, was du freigibst: Name, Wohnort‚ÄëVerortung, Verbindungen im Gewebe.  
> Du kannst deine Daten jederzeit exportieren, berichtigen, Einwilligungen widerrufen oder deine Rolle anonymisieren (PII‚ÄëL√∂schung, Rolle bleibt verortet auf gr√∂berer H3‚ÄëZelle). Server‚Äë und Sicherheitslogs sind kurzlebig und nur pseudonymisiert (rotierender Hash). Rechtsgrundlagen: Art. 6 Abs. 1 lit. a (Einwilligung) und lit. f DSGVO (berechtigtes Interesse an sicherer Gemeinschaftsorganisation). Verantwortlicher und Kontakt wie im Impressum. Fristen f√ºr Auskunft/L√∂schung: 30 Tage.

(Der Text passt zu eurem bestehenden Stil und ersetzt den kurzen Absatz in inhalt.md, der bereits ‚Äûkein Tracking‚Ä¶/Einverst√§ndnis & legitimes Interesse‚Äú sagt, nur pr√§ziser und mit Rechten.)

# 10) Warum ‚Äûkongruent‚Äú zu v14_3?

- **Sofort‚ÄëAbstimmung & Webrat**: Unangetastet (Events + UI bleiben).
- **Karte + F√§den/Garn**: bleiben, inkl. 7‚ÄëTage‚ÄëVerblassen & Strukturknoten; nur Startpunkt der Rolle kann generalisiert werden.
- **Event‚ÄëSchema**: Ihr nutzt ohnehin signierte Events mit Meta‚ÄëHashes; wir f√ºgen nur neue Eventtypen hinzu.

---

Alles klar ‚Äì hier der Kosten-Patch f√ºr v14_3, fokussiert auf das Thema Kostenreduktion durch gestufte Architektur


  

üìú Patch v14_3.kosten

  

  

  

Neue Sektion:¬†

Kosten- und Infrastrukturstrategie

  

  

Zur Sicherung der finanziellen Nachhaltigkeit des Projekts wird die Infrastruktur phasenweise entwickelt.

Ziel: unter 0,01 ‚Ç¨ pro 1.000 Events im Vollbetrieb ‚Äì mit einem Einstieg von < 300 ‚Ç¨ pro Monat.

  

  

Phase A ‚Äì MVP (Minimal Viable Product)

  

  

- Ein dedizierter Rootserver (Hetzner/OVH, 32‚Äì64 GB RAM, 2‚Äì4 TB NVMe, ca. 85‚Äì120 ‚Ç¨/Monat).
- Darauf laufen alle Kernkomponenten: Fastify API, PostgreSQL/PostGIS, Redis, NATS.
- Simuliertes Peer-Netzwerk: Konsens wird technisch abgebildet, jedoch noch nicht dezentral.
- Minimal-Monitoring: Netdata oder Healthchecks.io, kein voller Prometheus/Grafana-Stack.
- Domains & SSL: 5‚Äì15 ‚Ç¨/Monat.
- Zahlungsabwicklung: anfangs manuell per SEPA, keine API-Integration.
- Gesamtkosten Phase A: ~90‚Äì250 ‚Ç¨/Monat.

  

  

  

Phase B ‚Äì Hybrid Bootstrap

  

  

- Erg√§nzung durch 2‚Äì3 zus√§tzliche kleine Peer-Knoten (Community-Server, VPS, Vereins-Hardware).
- Einf√ºhrung von Light-Peers: g√ºnstige Mini-Knoten, die Validierung bezeugen, ohne volle Datenhaltung.
- Erste Automatisierungen (AIOps-Skripte) f√ºr Log-Analyse, Auto-Restarts, Alerting.
- Gesamtkosten Phase B: ~250‚Äì600 ‚Ç¨/Monat (verteilt √ºber Community).

  

  

  

Phase C ‚Äì Progressive Dezentralisierung

  

  

- Aufbau einer echten BFT-Konsens-Schicht.
- Peer-Knoten verteilt auf Vereine, Partner, Community.
- Archivierung alter Events auf g√ºnstigem Object-Storage (S3-kompatibel).
- Einf√ºhrung eines Anreizmodells (Spenden, Gewebekonto-Finanzierung, ggf. symbolisches Staking).
- Gesamtkosten Phase C: 600‚Äì2000 ‚Ç¨/Monat, aber auf viele Schultern verteilt.

  

  

  

  

  

‚à¥Patch-Kern

  

  

Die Kostenstrategie folgt einem drei-Phasen-Pfad:

  

1. billig & zentralisiert starten (ein Server),
2. hybrid verteilen,
3. voll dezentralisieren.

  

  

  

  

