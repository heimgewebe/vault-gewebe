#!/usr/bin/env bash
# cspell:disable
trap 'ec=$?; cmd=$BASH_COMMAND; line=${BASH_LINENO[0]}; fn=${FUNCNAME[1]:-MAIN}; \
  ((ec)) && printf "❌ wgx: Fehler in %s (Zeile %s): %s (exit=%s)\n" "$fn" "$line" "$cmd" "$ec" >&2' ERR
set -Eeuo pipefail
IFS=$'\n\t'
umask 077
shopt -s extglob nullglob
WGX_VERSION="1.22.0"

# --- schnelle Prüfung auf --version ---
if [[ "${1-}" == "--version" || "${1-}" == "-V" ]]; then
  printf "wgx v%s\n" "$WGX_VERSION"
  exit 0
fi

# --- einfache Ausgaben/Logging ---
warn(){ printf "⚠️  %s\n" "$*" >&2; }
ok(){ printf "✅ %s\n" "$*"; }
die(){ printf "❌ %s\n" "$*" >&2; exit 1; }
info(){ printf "• %s\n" "$*"; }

trim(){ local s="$*"; s="${s#"${s%%[![:space:]]*}"}"; printf "%s" "${s%"${s##*[![:space:]]}"}"; }
to_lower(){ tr '[:upper:]' '[:lower:]'; }

# Globale Defaults
: "${ASSUME_YES:=0}"; : "${DRYRUN:=0}"; : "${TIMEOUT:=0}"; : "${NOTIMEOUT:=0}";
: "${VERBOSE:=0}"; : "${OFFLINE:=0}"
: "${WGX_BASE:=main}"; : "${WGX_SIGNING:=auto}"; : "${WGX_PREVIEW_DIFF_LINES:=120}"
: "${WGX_PR_LABELS:=}"; : "${WGX_CI_WORKFLOW:=CI}"

# Umgebung/Plattform
PLATFORM="linux"
if uname | grep -qi darwin; then PLATFORM="darwin"; fi
is_termux(){ case "${PREFIX-}" in *com.termux*) return 0;; *) return 1;; esac; }
is_wsl(){ uname -r 2>/dev/null | grep -qiE 'microsoft|wsl2?'; }
is_codespace(){ [[ -n "${CODESPACE_NAME-}" ]]; }
has(){ command -v "$1" >/dev/null 2>&1; }
git_cfg(){ git config --get "$1"; }

# Repo-Root
ROOT(){
  local here="${BASH_SOURCE[0]}"
  if command -v greadlink >/dev/null 2>&1; then here="$(greadlink -f "$here")"
  elif command -v readlink >/dev/null 2>&1; then
    if readlink -f / >/dev/null 2>&1; then here="$(readlink -f "$here")"
    else
      local link
      while link="$(readlink "$here" 2>/dev/null)"; do
        case "$link" in /*) here="$link";; *) here="$(cd "$(dirname "$here")" && pwd -P)/$link";; esac
      done
    fi
  fi
  local fallback; fallback="$(cd "$(dirname "$here")/.." && pwd -P)"
  local r; r="$(git -C "${PWD}" rev-parse --show-toplevel 2>/dev/null || true)"
  [[ -n "$r" ]] && printf "%s" "$r" || printf "%s" "$fallback"
}
ROOT_DIR="$(ROOT)"

is_git_repo(){ git -C "$ROOT_DIR" rev-parse --is-inside-work-tree >/dev/null 2>&1; }
require_repo(){ is_git_repo || die "Nicht im Git-Repo (wgx benötigt ein Git-Repository)."; }

# Git-Helfer
git_branch(){ git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "HEAD"; }
git_in_progress(){ [[ -e .git/rebase-apply || -e .git/rebase-merge || -e .git/MERGE_HEAD ]]; }
_fetch_guard(){ (( OFFLINE )) && return 0; git fetch -q origin 2>/dev/null || true; }

git_ahead_behind(){
  local b="$1"
  _fetch_guard
  local ab; ab="$(git rev-list --left-right --count "origin/$b...$b" 2>/dev/null || echo "0 0")"
  local behind=0 ahead=0 IFS=' '; read -r behind ahead <<<"$ab" || true
  printf "%s %s\n" "${behind:-0}" "${ahead:-0}"
}

detect_web_dir(){ for d in apps/web web; do [[ -d "$d" ]] && { echo "$d"; return; }; done; echo ""; }
detect_api_dir(){ for d in apps/api api crates; do [[ -f "$d/Cargo.toml" ]] && { echo "$d"; return; }; done; echo ""; }

remote_host_path(){
  local u; u="$(git remote get-url origin 2>/dev/null || true)"; [[ -z "$u" ]] && { echo ""; return; }
  case "$u" in
    http*://*/*) echo "${u#*://}" ;;
    git@*:*/*)   echo "${u#git@}" | sed 's/:/ /; s/  */ /g' | awk '{print $1" "$2}' ;;
    *) echo "$u" ;;
  esac
}
compare_url(){
  local hp host path; hp="$(remote_host_path || true)"; [[ -z "$hp" ]] && { echo ""; return; }
  host="${hp%% *}"; path="${hp#* }"; path="${path%.git}"
  case "$host" in
    github.com) echo "https://github.com/$path/compare/${WGX_BASE}...$(git_branch)";;
    gitlab.com) echo "https://gitlab.com/$path/-/compare/${WGX_BASE}...$(git_branch)";;
    *) echo "";;
  esac
}

run_with_xargs0(){
  local title="$1"; shift
  if [[ -t 1 ]]; then info "$title"; fi
  if command -v xargs >/dev/null 2>&1; then
    xargs -0 "$@" || return $?
  else
    local buf=(); local IFS= read -r -d '' f || true
    while [[ -n "${f-}" ]]; do buf+=("$f"); IFS= read -r -d '' f || true; done
    (("$#">0)) && "$@" "${buf[@]}"
  fi
}
mktemp_portable(){ local p="${1:-wgx}"; local f="${TMPDIR:-/tmp}/${p}.$(date +%s).$$"; : > "$f" && printf "%s" "$f"; }

# .wgx.conf laden
if [[ -f ".wgx.conf" ]]; then
  while IFS='=' read -r k v; do
    [[ -z "$k" || "$k" =~ ^# ]] && continue
    eval "export ${k}='${v}'"
  done < ".wgx.conf"
fi

# ───────── Scope / Files ─────────
changed_files_cached(){ git diff --name-only --cached; }
changed_files_all(){ git diff --name-only; }
auto_scope(){
  local files scope="" pref
  while IFS= read -r file; do
    [[ -z "$file" ]] && continue
    pref="${file%%/*}"
    case "$pref" in
      devx|devops) scope="infra";;
      docs) scope="docs";;
      hooks) scope="build";;
      *) ;;
    esac
    [[ -n "$scope" ]] && break
  done <<<"$1"
  echo "${scope:-app}"
}

now_ts(){ date --iso-8601=seconds; }

# Style-Lint (Vale)
vale_maybe(){
  (( OFFLINE )) && return 0
  [[ -z "$1" ]] && return 0
  if has vale; then
    info "Stilprüfung (Vale)..."
    echo "$1" | xargs -0 -n1 vale
    return $?
  else
    warn "Vale nicht installiert – Stilprüfung übersprungen."
    return 0
  fi
}

# Preflight-Checks (guard)
guard_run(){
  require_repo
  local rc=0 br
  br="$(git_branch)"
  echo "=== Preflight (branch: $br, base: $WGX_BASE) ==="
  if git_in_progress; then
    echo "[BLOCKER] Rebase/Merge läuft – wgx heal --continue | --abort"
    rc=2
  fi
  [[ "$br" == "HEAD" ]] && { echo "[WARN] Detached HEAD – Branch anlegen."; ((rc==0)) && rc=1; }
  local behind=0 ahead=0 IFS=' '; read -r behind ahead < <(git_ahead_behind "$br") || true
  (( behind>0 )) && { echo "[WARN] $behind hinter @{u}"; (( rc==0 )) && rc=1; }
  # Konfliktmarker im Arbeitsbaum
  local with_markers=""
  while IFS= read -r -d '' f; do
    grep -Eq '<<<<<<<|=======|>>>>>>>' -- "$f" 2>/dev/null && with_markers+="$f"$'\n'
  done < <(git ls-files -m -z)
  [[ -n "$with_markers" ]] && { echo "[BLOCKER] Konfliktmarker gefunden:"; printf '%s' "$with_markers" | sed 's/^/  - /'; rc=2; }
  # Geheimnisse prüfen (grob)
  local secrets_file=".gitignore_secrets"
  if [[ -f ".gitignore" ]]; then
    sed 's!#.*!!' ".gitignore" | grep -E 'key|secret|password' > "$secrets_file" 2>/dev/null || true
  fi
  if [[ -s "$secrets_file" ]]; then
    echo "[BLOCKER] Verdächtige Einträge in .gitignore:"
    sed 's/^/  - /' "$secrets_file"
    rc=2
  fi
  rm -f "$secrets_file"
  case "$rc" in
    0) ok "Preflight sauber.";;
    1) warn "Preflight mit Warnungen.";;
    2) die "Preflight BLOCKER.";;
  esac
  printf "%s\n" "$rc"
}

# ───────── Status ─────────
status_cmd(){
  local in_repo=1; is_git_repo || in_repo=0
  echo "=== wgx status v$WGX_VERSION ==="
  echo "root  : $ROOT_DIR"
  if (( ! in_repo )); then echo "branch: (kein Repo)"; return 0; fi

  local br up behind=0 ahead=0 staged=0 changed=0 untracked=0 sign="unspecified" dirty="clean"
  br="$(git_branch)"
  if git rev-parse --abbrev-ref --symbolic-full-name '@{u}' >/dev/null 2>&1; then
    up="$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}')" || up=""
  else
    up="(kein Upstream)"
  fi
  IFS=' ' read -r behind ahead < <(git_ahead_behind "$br") || true

  # Arbeitsbaum prüfen
  while IFS= read -r line; do
    case "$line" in
      '?? '*) ((untracked++));;
      [AMD]?' '*) ((staged++));;
      ' ' [MD]*) ((changed++));;
    esac
  done < <(git status --porcelain 2>/dev/null || true)

  (( staged+changed+untracked > 0 )) && dirty="dirty"
  case "${WGX_SIGNING,,}" in off) sign="off";; auto) sign="auto";; gpg|ssh) sign="on($WGX_SIGNING)";; *) sign="$WGX_SIGNING";; esac

  local web api; web="$(detect_web_dir || true)"; api="$(detect_api_dir || true)"
  echo "branch: $br  base:$WGX_BASE  upstream:$up"
  echo "ahead : $ahead    behind:$behind"
  echo "tree  : $dirty  (staged:$staged changed:$changed untracked:$untracked)"
  echo "web   : ${web:-—}   api:${api:-—}"
  echo "sign  : $sign   offline:$OFFLINE   codespaces:$(is_codespace && echo yes || echo no)"

  # Remote prüfen
  if ! git ls-remote origin >/dev/null 2>&1; then warn "origin nicht erreichbar oder keine Credentials."; fi

  echo "compare: $(compare_url)"
}

# Hilfsfunktion: entscheide, ob git signieren soll
maybe_sign_flag(){
  case "${WGX_SIGNING}" in
    off|OFF|Off) return 1;;
    ssh|gpg|GPG|SSH) echo "-S"; return 0;;
    auto|AUTO) git config --get user.signingkey >/dev/null 2>&1 && { echo "-S"; return 0; } || return 1;;
    *) return 1;;
  esac
}

# ───────── Synchronisieren ─────────
sync_cmd(){
  require_repo
  local STAGED_ONLY=0 WIP=0 AMEND=0 SCOPE="auto" BASE="" signflag="" had_upstream=0 STRICT_SIGN=0 NO_VERIFY=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --staged-only) STAGED_ONLY=1;;
      --wip) WIP=1;;
      --amend) AMEND=1;;
      --scope) shift; SCOPE="${1-}";;
      --base) shift; BASE="${1-}";;
      --sign) signflag="-S";;
      --strict-sign) STRICT_SIGN=1;;
      --no-verify) NO_VERIFY=1;;
      *) warn "sync: Unbekannte Option: $1";;
    esac
    shift || true
  done
  [[ -n "$BASE" ]] && WGX_BASE="$BASE"
  [[ "$(git_branch)" == "HEAD" ]] && die "Detached HEAD – bitte Branch anlegen."
  (( STAGED_ONLY == 0 )) && git add -A
  [[ -f ".vale.ini" ]] && vale_maybe --staged || true

  # Identität sicherstellen (Container/Codespace)
  [[ -n "$(git_cfg user.name)" ]]  || git config --local user.name "alexdermohr"
  [[ -n "$(git_cfg user.email)" ]] || git config --local user.email "alexdermohr@users.noreply.github.com"

  local staged list scope n msg nf="files"
  staged="$(changed_files_cached || true)"; list="${staged:-$(changed_files_all || true)}"
  scope="$([[ "$SCOPE" == "auto" ]] && auto_scope "$list" || echo "$SCOPE")"
  n=0; [[ -n "$list" ]] && n=$(printf "%s\n" "$list" | wc -l | tr -d ' ')
  (( n == 1 )) && nf="file"
  msg="feat(${scope}): sync @ $(now_ts) [+${n} ${nf}]"
  (( WIP )) && msg="wip: ${msg}"

  # DRYRUN: simulieren, kein Commit/Push
  if (( DRYRUN )); then
    info "DRYRUN: Sync simuliert – Commit und Push übersprungen."
    return 0
  fi

  if [[ -n "$staged" ]]; then
    local commit_args=( ${AMEND:+--amend} )
    (( NO_VERIFY )) && commit_args+=(--no-verify)
    if (( STRICT_SIGN )); then
      git commit "${commit_args[@]}" -S -m "$msg" || die "Signierter Commit vorgeschrieben (--strict-sign) fehlgeschlagen."
    else
      local sf="${signflag:-$(maybe_sign_flag || true)}"
      if [[ -n "${sf-}" ]]; then
        if ! git commit "${commit_args[@]}" "$sf" -m "$msg"; then
          warn "Signierter Commit fehlgeschlagen – versuche unsigniert."
          git commit "${commit_args[@]}" --no-gpg-sign -m "$msg" || die "Commit fehlgeschlagen."
        fi
      else
        git commit "${commit_args[@]}" --no-gpg-sign -m "$msg" || die "Commit fehlgeschlagen."
      fi
    fi
  else
    info "Nichts zu committen."
  fi

  _fetch_guard
  git rev-parse --verify -q "origin/$WGX_BASE" >/dev/null || die "Basisbranch origin/$WGX_BASE nicht gefunden."

  # Rebase auf Basis-Branch
  if ! git rebase "origin/$WGX_BASE"; then
    warn "Rebase-Konflikt – wgx heal --continue | --abort"
    return 2
  fi

  # Push (ggf. --no-verify)
  if git rev-parse --abbrev-ref --symbolic-full-name '@{u}' >/dev/null 2>&1; then
    had_upstream=1
  else
    had_upstream=0
  fi

  if (( had_upstream )); then
    git push $([[ $NO_VERIFY -eq 1 ]] && echo --no-verify) || {
      warn "Push abgelehnt – versuche Rebase auf Upstream"
      git fetch origin || true
      git rebase '@{u}' || { warn "Rebase auf Upstream fehlgeschlagen – Konflikte?"; return 2; }
      git push $([[ $NO_VERIFY -eq 1 ]] && echo --no-verify) || die "Push fehlgeschlagen."
    }
  else
    git push --set-upstream origin "$(git_branch)" $([[ $NO_VERIFY -eq 1 ]] && echo --no-verify) || die "Push/Upstream fehlgeschlagen."
  fi

  ok "Sync erledigt."
  local behind=0 ahead=0 IFS=' '; read -r behind ahead < <(git_ahead_behind "$(git_branch)") || true
  info "Upstream: ahead=$ahead behind=$behind"
}

# ───────── PR/MR (GitHub/GitLab) ─────────
send_cmd(){
  require_repo
  local DRAFT=0 TITLE="" WHY="" TESTS="" NOTES="" SCOPE="auto" \
    LABELS="$WGX_PR_LABELS" ISSUE="" BASE="" SYNC_FIRST=1 SIGN=0 INTERACTIVE=0 \
    REVIEWERS="" TRIGGER_CI=0 OPEN_PR=0 AUTO_BRANCH=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --draft) DRAFT=1;;
      -i|--interactive) INTERACTIVE=1;;
      --title) shift; TITLE="${1-}";;
      --why) shift; WHY="${1-}";;
      --tests) shift; TESTS="${1-}";;
      --notes) shift; NOTES="${1-}";;
      --label) shift; LABELS="${LABELS:+$LABELS,}${1-}";;
      --issue|--issues) shift; ISSUE="${1-}";;
      --reviewers) shift; REVIEWERS="${1-}";;
      --scope) shift; SCOPE="${1-}";;
      --no-sync-first) SYNC_FIRST=0;;
      --sign) SIGN=1;;
      --base) shift; BASE="${1-}";;
      --ci) TRIGGER_CI=1;;
      --open) OPEN_PR=1;;
      --auto-branch) AUTO_BRANCH=1;;
      *) warn "send: Unbekannte Option: $1";;
    esac
    shift || true
  done
  [[ -n "$BASE" ]] && WGX_BASE="$BASE"

  local current; current="$(git_branch)"
  local AUTO_BRANCH_FLAG=$AUTO_BRANCH
  if [[ -z "${AUTO_BRANCH-}" && -n "${WGX_AUTO_BRANCH-}" ]]; then AUTO_BRANCH_FLAG=$WGX_AUTO_BRANCH; fi
  if [[ "$current" == "$WGX_BASE" ]]; then
    if (( AUTO_BRANCH_FLAG )); then
      local slug="auto-pr-$(date +%Y%m%d-%H%M%S)"
      info "Base-Branch ($WGX_BASE) erkannt → auto Branch: $slug"
      start_cmd "$slug" || die "auto-branch fehlgeschlagen"
    else
      die "send: Du stehst auf Base ($WGX_BASE). Erst \"wgx start <slug>\" oder nutze \"wgx send --auto-branch\"."
    fi
  fi

  git fetch -q origin "$WGX_BASE" >/dev/null 2>&1 || true
  if git rev-parse --verify -q "origin/$WGX_BASE" >/dev/null; then
    if git diff --quiet "origin/$WGX_BASE"...HEAD; then
      die "send: Kein Diff zu origin/$WGX_BASE – nichts zu senden."
    fi
  fi

  guard_run; local rc=$?; (( rc==1 && (ASSUME_YES || WGX_DRAFT_ON_WARN) )) && DRAFT=1
  if (( SYNC_FIRST )); then
    sync_cmd ${SIGN:+--sign} --scope "${SCOPE}" --base "$WGX_BASE" || { warn "Sync fehlgeschlagen – PR abgebrochen."; return 1; }
  fi

  local files scope short
  files="$(git diff --name-only "origin/$WGX_BASE"...HEAD 2>/dev/null || true)"
  scope="$([[ "$SCOPE" == "auto" ]] && auto_scope "$files" || echo "$SCOPE")"
  local last_subject; last_subject="$(git log -1 --pretty=%s 2>/dev/null || true)"
  short="${TITLE:-${last_subject:-"Änderungen an ${scope}"}}"
  local TITLE2="[${scope}] ${short}"

  local body; body="$(render_pr_body "$TITLE2" "$short" "${WHY:-"—"}" "${TESTS:-"—"}" "${ISSUE:-""}" "${NOTES:-""}")"
  if (( INTERACTIVE )); then
    local tmpf; tmpf="$(mktemp_portable wgx-pr)"
    printf "%s" "$body" > "$tmpf"
    bash -lc "${WGX_EDITOR:-${EDITOR:-nano}} $(printf '%q' "$tmpf")"
    body="$(cat "$tmpf")"; rm -f "$tmpf"
  fi
  [[ -z "$(printf '%s' "$body" | tr -d '[:space:]')" ]] && die "PR-Body ist leer – abgebrochen."

  local autoL; autoL="$(derive_labels "$scope")"
  [[ -n "$autoL" ]] && LABELS="${LABELS:+$LABELS,}$autoL"
  LABELS="$(_sanitize_csv "$LABELS")"

  case "$(host_kind)" in
    gitlab)
      if has glab; then
        glab auth status >/dev/null 2>&1 || warn "glab nicht eingeloggt – MR könnte scheitern."
        local args=(mr create --title "$TITLE2" --description "$body" --source-branch "$(git_branch)" --target-branch "$WGX_BASE")
        (( DRAFT )) && args+=(--draft)
        [[ -n "$ISSUE" ]] && args+=(--issue "$ISSUE")
        if [[ -n "$LABELS" ]]; then IFS=, read -r -a _labels <<<"$LABELS"; for _l in "${_labels[@]}"; do _l="$(trim "$_l")"; [[ -n "$_l" ]] && args+=(--label "$_l"); done; fi
        if [[ "$REVIEWERS" == "auto" ]]; then
          local rlist; rlist="$(printf "%s\n" "$files" | _codeowners_reviewers || true)"
          if [[ -n "$rlist" ]]; then
            local r
            while IFS= read -r r; do [[ -n "$r" ]] && args+=(--reviewer "$r"); done <<< "$rlist"
            info "Reviewer (auto): $(printf '%s' "$rlist" | tr '\\n' ' ')"
          fi
        elif [[ -n "$REVIEWERS" ]]; then
          IFS=, read -r -a rv <<<"$REVIEWERS"
          local r
          for r in "${rv[@]}"; do r="$(trim "$r")"; [[ -n "$r" ]] && args+=(--reviewer "$r"); done
        fi
        glab "${args[@]}" || die "glab mr create fehlgeschlagen."
        ok "Merge Request erstellt."
        (( OPEN_PR )) && glab mr view --web >/dev/null 2>&1 || true
      else
        warn "glab CLI nicht gefunden. MR manuell anlegen."
        echo "Vergleich: $(compare_url)"
      fi
      ;;
    github|*)
      if has gh; then
        gh auth status >/dev/null 2>&1 || warn "gh nicht eingeloggt – PR könnte scheitern."
        local args=(pr create --title "$TITLE2" --body "$body" --base "$WGX_BASE")
        (( DRAFT )) && args+=(--draft)
        if [[ -n "$LABELS" ]]; then IFS=, read -r -a L <<<"$LABELS"; for l in "${L[@]}"; do l="$(trim "$l")"; [[ -n "$l" ]] && args+=(--label "$l"); done; fi
        [[ -n "$ISSUE" ]] && args+=(--issue "$ISSUE")
        if [[ "$REVIEWERS" == "auto" ]]; then
          local rlist; rlist="$(printf "%s\n" "$files" | _codeowners_reviewers || true)"
          if [[ -n "$rlist" ]]; then
            local r
            while IFS= read -r r; do [[ -n "$r" ]] && args+=(--reviewer "$r"); done <<< "$rlist"
            info "Reviewer (auto): $(printf '%s' "$rlist" | tr '\\n' ' ')"
          else
            warn "CODEOWNERS ohne User-Reviewer."
          fi
        elif [[ -n "$REVIEWERS" ]]; then
          IFS=, read -r -a rvw2 <<<"$REVIEWERS"
          local r2
          for r2 in "${rvw2[@]}"; do r2="$(trim "$r2")"; [[ -n "$r2" ]] && args+=(--reviewer "$r2"); done
        fi
        gh "${args[@]}" || die "gh pr create fehlgeschlagen."
        local pr_url; pr_url="$(gh pr view --json url -q .url 2>/dev/null || true)"
        [[ -n "$pr_url" ]] && info "PR: $pr_url"
        ok "PR erstellt."
        (( TRIGGER_CI )) && gh workflow run "$WGX_CI_WORKFLOW" >/dev/null 2>&1 || true
        (( OPEN_PR )) && gh pr view -w >/dev/null 2>&1 || true
      else
        local url; url="$(compare_url)"
        echo "gh CLI nicht gefunden. PR manuell anlegen:"
        echo "URL: $url"
        echo "Labels: $LABELS"
        echo "--- PR Text ---"
        echo "$body"
      fi
      ;;
  esac
}

# ───────── Heal / Reload / Clean / Doctor / Init / Start ─────────
doctor_cmd(){
  local sub="${1-}"; shift || true
  case "$sub" in
    net) doctor_net;;
    heal) heal_cmd rebase;;
    clean) DRYRUN=1;
      echo "=== wgx doctor clean (Vorschau) ==="
      echo "(Nutze 'wgx clean --deep' für scharf)";;
    ""|*) status_cmd;;
  esac
}

init_cmd(){
  [[ -f ".wgx.conf" ]] && warn ".wgx.conf existiert bereits." || {
    cat > .wgx.conf <<EOF
WGX_BASE=${WGX_BASE}
WGX_SIGNING=${WGX_SIGNING}
WGX_PREVIEW_DIFF_LINES=${WGX_PREVIEW_DIFF_LINES}
WGX_PR_LABELS=${WGX_PR_LABELS}
WGX_CI_WORKFLOW=${WGX_CI_WORKFLOW}
EOF
    ok ".wgx.conf angelegt."
  }
  [[ -d ".wgx" ]] || { mkdir -p .wgx; ok ".wgx/ angelegt."; }
}

start_cmd(){
  require_repo
  local slug="${1-}"; [[ -z "$slug" ]] && die "Usage: wgx start <slug>"
  git fetch origin "$WGX_BASE" 2>/dev/null || true
  local base_ref="origin/$WGX_BASE"
  git rev-parse --verify -q "$base_ref" >/dev/null || base_ref="$WGX_BASE"
  git rev-parse --verify -q "$base_ref" >/dev/null || die "Basisbranch $WGX_BASE nicht gefunden."
  slug="${slug//[^a-zA-Z0-9._-]/-}"; slug="${slug//../.}"; slug="${slug##+(-)}"; slug="${slug%%+(-)}"
  [[ -z "$slug" ]] && die "Ungültiger Branch-Name."
  git check-ref-format --branch "$slug" || die "Ungültiger Branch-Name."
  git checkout -b "$slug" "$base_ref" || die "Branch konnte nicht erstellt werden."
  ok "Branch '$slug' von $base_ref erstellt."
}

lint_cmd(){ require_repo; ok "Lint (verkürzt) – setz hier deine Linter ein."; }
test_cmd(){ require_repo; ok "Tests (verkürzt) – setz hier deine Testläufe ein."; }

clean_cmd(){ require_repo; ok "Clean (verkürzt) – nutze 'git clean -xfd' bewusst."; }
reload_cmd(){ exec "$SHELL" -l; }

usage(){
  cat <<EOF
wgx – v${WGX_VERSION}
Neu:
  wgx status                 # Überblick: Branch/Base/Upstream, ahead/behind, dirty, sign, reachability, compare-URL
  wgx sync [--strict-sign] [--no-verify] [--staged-only] [--wip] [--amend] [--scope S] [--base B]
                             # Sync (Commit, Rebase, Push)
  wgx send [--title] [--why] [--tests] [--notes] [--label L] [--issue I] [--reviewers R] [--scope S] [--no-sync-first] [--ci] [--open]
                             # PR/MR erstellen (GitHub/GitLab)
  wgx release [--version vX.Y.Z|--auto-version patch|minor|major] [--push] [--sign-tag] [--notes FILE] [--latest]
                             # Release-Workflow (Tag/Release erstellen)
  wgx doctor net             # Netzwerk/Authentifizierung prüfen
  wgx diag                   # Diagnose-Report in /tmp speichern
  wgx fix common             # Reparatur (Identität, Upstream, Rebase, CRLF)
  wgx heal ff-only           # Fast-Forward rebase
  wgx open [compare|repo|pr] # Browser öffnen (Vergleichs-/Repo-URL oder PR)
  wgx stash [save|list|pop]   # Smarte Stashes
  wgx config guard           # Empfohlene Git-Settings setzen
Bestehend:
  wgx start <slug>           # neuen Branch vom Base erstellen
  wgx doctor                 # alias für 'wgx doctor net'
  wgx clean                  # Aufräumen (kurz)
  wgx lint                   # Lint-Checks (Platzhalter)
  wgx test                   # Tests (Platzhalter)
  wgx init                   # Einrichtung (.wgx.conf, .wgx-Verz.)
EOF
}

SUB="${1-}"; shift || true
case "$SUB" in
  status)   status_cmd "$@";;
  sync)     sync_cmd "$@";;
  send)     send_cmd "$@";;
  release)  release_cmd "$@";;
  doctor)   doctor_cmd "$@";;
  diag)     diag_cmd "$@";;
  fix)      [[ "${1-}" == "common" ]] || die "wgx fix common"; fix_common;;
  heal)     heal_cmd "$@";;
  open)     open_cmd "$@";;
  stash)    stash_cmd "$@";;
  config)   config_cmd "$@";;
  start)    start_cmd "$@";;
  lint)     lint_cmd "$@";;
  test)     test_cmd "$@";;
  init)     init_cmd "$@";;
  clean)    clean_cmd "$@";;
  reload)   reload_cmd "$@";;
  help|-h|--help|"") usage;;
  *) die "Unbekanntes Kommando: $SUB";;
esac

# cspell:enable