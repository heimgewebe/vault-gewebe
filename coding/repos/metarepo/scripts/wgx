#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")/.." && pwd)"
REPOS_YML="$ROOT_DIR/repos.yml"
REPO_CONFIG="$ROOT_DIR/scripts/repo_config.py"

# Flags / Env
DRYRUN=${DRYRUN:-0}
PLAN_LIMIT="${PLAN_LIMIT:-10}"
WGX_OWNER="${WGX_OWNER:-${GITHUB_OWNER:-}}"

# tmp handling
_tmp_dirs=()
cleanup(){ local d; for d in "${_tmp_dirs[@]:-}"; do [[ -n "$d" && -e "$d" ]] && rm -rf -- "$d"; done; }
trap cleanup EXIT INT TERM

log(){ printf "%s\n" "$*" >&2; }
die(){ echo "ERR: $*" >&2; exit 1; }
need(){ command -v "$1" >/dev/null 2>&1 || die "Fehlt: $1"; }

[[ -f "$REPOS_YML" ]] || die "repos.yml fehlt (erwartet: $REPOS_YML)"
[[ "$PLAN_LIMIT" =~ ^[0-9]+$ ]] || die "PLAN_LIMIT muss eine nicht-negative Ganzzahl sein"

# ---------- Repo config bridge (Python) ----------
mode()  { python3 "$REPO_CONFIG" --file "$REPOS_YML" mode; }
owner() {
  if [[ -n "$WGX_OWNER" ]]; then echo "$WGX_OWNER"; return; fi
  local o; o="$(python3 "$REPO_CONFIG" --file "$REPOS_YML" owner || true)"
  if [[ -n "$o" ]]; then echo "$o"; return; fi
  [[ -n "${GITHUB_OWNER:-}" ]] && { echo "$GITHUB_OWNER"; return; }
  die "Kein Owner gefunden (repos.yml github.owner, WGX_OWNER oder GITHUB_OWNER)."
}
default_branch_of(){ python3 "$REPO_CONFIG" --file "$REPOS_YML" default-branch "$1"; }

check_tools(){
  need rsync
  need git
  need python3
  local m; m="$(mode)"
  if [[ "$m" == "github" ]]; then
    need jq
    need gh
  fi
}
check_tools

# ---------- Repo sets ----------
repos_from_github() {
  local ow; ow="$(owner)"
  need gh; need jq
  gh repo list "$ow" --json name,isPrivate,isFork --limit 200 \
    | jq -r '.[] | select(.isFork==false) | select(.isPrivate==false) | .name'
}
repos_from_static(){ python3 "$REPO_CONFIG" --file "$REPOS_YML" repos || true; }
repos(){
  local m; m="$(mode)"
  if [[ "$m" == "github" ]]; then repos_from_github; else repos_from_static; fi
}
ordered_repos(){
  local m; m="$(mode)"
  if [[ "$m" == "github" ]]; then repos | sort; else python3 "$REPO_CONFIG" --file "$REPOS_YML" ordered-repos; fi
}

# ---------- Commands ----------
cmd_list(){
  echo "▶ Fleet-Repos:"
  python3 "$REPO_CONFIG" --file "$REPOS_YML" repo-rows \
    | while IFS=$'\t' read -r name branch url deps; do
        [[ -z "$name" ]] && continue
        local line=" - ${name}"
        [[ -n "$branch" ]] && line+=" [branch: ${branch}]"
        [[ -n "$url" ]] && line+=" → ${url}"
        if [[ -n "$deps" ]]; then
          local d="${deps//,/ , }"; d="${d// , /, }"
          line+=" (depends_on: ${d})"
        fi
        echo "$line"
      done
}

list_template_files(){
  [[ -d "$ROOT_DIR/templates" ]] || return 1
  ( cd "$ROOT_DIR/templates" && find . -type f -print | sed 's|^\./||' | LC_ALL=C sort )
}

cmd_plan(){
  echo "▶ Plan (ohne Klonen/Push):"
  if [[ ! -d "$ROOT_DIR/templates" ]]; then
    echo "  (keine templates/ gefunden)"; return 0
  fi
  local tmp files_count rest
  tmp="$(mktemp)"; _tmp_dirs+=("$tmp")
  if ! list_template_files >"$tmp"; then
    echo "  (keine Template-Dateien gefunden)"; return 0
  fi
  files_count="$(wc -l <"$tmp" | tr -d ' ')"
  if (( files_count == 0 )); then
    echo "  (keine Template-Dateien gefunden)"; return 0
  fi

  ordered_repos | while read -r repo; do
    [[ -z "$repo" ]] && continue
    echo " - $repo"
    echo "   files: $files_count"
    if (( PLAN_LIMIT > 0 )); then
      head -n "$PLAN_LIMIT" "$tmp" | sed 's/^/     - /'
      rest=$((files_count - PLAN_LIMIT))
      (( rest > 0 )) && printf '     … (+%d weitere)\n' "$rest"
    else
      sed 's/^/     - /' "$tmp"
    fi
  done
}

# Git commit/PR messages
COMMIT_MSG="chore(wgx): sync templates from metarepo"
PR_TITLE="chore(wgx): sync templates from metarepo"
PR_BODY="Automatischer WGX-Sync aus dem metarepo."

# Clone a repository using the best available method
clone_repo(){
  local repo_name="$1" workdir="$2"
  local ow gh_path
  ow="$(owner)"
  gh_path="$(command -v gh || true)"

  if [[ -n "$gh_path" && -n "${GH_TOKEN:-}" ]]; then
    log "Klonen via gh auf ${ow}/${repo_name}"
    "$gh_path" repo clone "${ow}/${repo_name}" "$workdir" -- --depth 1
    return
  fi

  local url_https="https://github.com/${ow}/${repo_name}.git"
  if [[ -n "${GH_TOKEN:-}" ]]; then
    log "Klonen via HTTPS (mit GH_TOKEN über temporären Credential-Helper) auf ${ow}/${repo_name}"
    local _wgx_cred_helper
    _wgx_cred_helper="$(mktemp "${TMPDIR:-/tmp}/wgx-gh-cred.XXXXXX")"
    _tmp_dirs+=("$_wgx_cred_helper")
    cat >"$_wgx_cred_helper" <<'EOS'
#!/usr/bin/env sh
set -eu
# Git credential helper: liest Anfrage (stdin) bis zur Leerzeile und antwortet
# mit Benutzer/Passwort aus der Umgebung. GH_TOKEN verbleibt in der ENV.
while IFS= read -r line; do
  [ -z "$line" ] && break
done
printf 'username=%s\n' "x"
[ -n "${GH_TOKEN:-}" ] || exit 1
printf 'password=%s\n' "$GH_TOKEN"
EOS
    chmod 700 "$_wgx_cred_helper"
    GIT_TERMINAL_PROMPT=0 GH_TOKEN="${GH_TOKEN}" \
      git -c "credential.helper=!\"$_wgx_cred_helper\"" \
          clone --depth 1 "$url_https" "$workdir"
    rm -f "$_wgx_cred_helper"
    return
  fi

  local url_ssh="git@github.com:${ow}/${repo_name}.git"
  if ssh -o BatchMode=yes -T git@github.com 2>&1 | grep -q "successfully authenticated"; then
    log "Klonen via SSH auf ${ow}/${repo_name}"
    git clone --depth 1 "$url_ssh" "$workdir"
  else
    log "Klonen via HTTPS auf ${ow}/${repo_name}"
    git clone --depth 1 "$url_https" "$workdir"
  fi
}

copy_templates_into_repo(){
  local r="$1"
  local tmp workdir; tmp="$(mktemp -d)"; _tmp_dirs+=("$tmp"); workdir="$(mktemp -d)"; _tmp_dirs+=("$workdir")

  if [[ ! -d "$ROOT_DIR/templates" ]]; then
    echo "Keine templates/ gefunden – skip $r"; return 0
  fi

  rsync -a --delete "$ROOT_DIR/templates/" "$tmp/"

  # {{REPO_NAME}} → repo (nur Textdateien; binär wird übersprungen via UnicodeDecodeError)
  python3 - "$tmp" "$r" <<'PY'
import sys
from pathlib import Path
root = Path(sys.argv[1]); repo = sys.argv[2]
for p in root.rglob('*'):
    if not p.is_file(): continue
    try:
        t = p.read_text(encoding='utf-8')
    except UnicodeDecodeError:
        continue
    if '{{REPO_NAME}}' in t:
        p.write_text(t.replace('{{REPO_NAME}}', repo), encoding='utf-8')
PY

  if ! clone_repo "$r" "$workdir"; then
    log "Klonen von $r fehlgeschlagen, übersprungen."
    return 1
  fi
  rsync -a "$tmp/." "$workdir/"

  pushd "$workdir" >/dev/null
    local branch="chore/wgx-sync-$(date +%Y%m%d-%H%M%S)"
    git checkout -b "$branch" || true
    git add -A
    if ! git diff --cached --quiet; then
      if (( DRYRUN == 1 )); then
        echo "DRY-RUN: Änderungen erkannt in $r (kein Commit/Push)."
        git status --short
      else
        git -c user.email="codex-bot@local" -c user.name="Codex Bot" commit -m "$COMMIT_MSG"
        git push -u origin "$branch"
        local gh_path; gh_path="$(command -v gh || true)"
        if [[ -n "$gh_path" ]]; then
          local base_branch; base_branch="$(default_branch_of "$r")"
          local gh_args=(pr create --fill --title "$PR_TITLE" --body "$PR_BODY" --base "${base_branch:-main}")
          [[ "${WGX_PR_DRAFT:-0}" == "1" ]] && gh_args+=(--draft)
          "$gh_path" "${gh_args[@]}" || true
        else
          echo "Hinweis: gh fehlt – PR bitte manuell öffnen."
        fi
      fi
    else
      echo "No changes for $r"
    fi
  popd >/dev/null
}

cmd_up(){
  cmd_plan
  if (( DRYRUN == 1 )); then
    echo "⚑ Dry-run aktiv – keine Commits oder Pushes."
  else
    read -p "Fortfahren? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo "Abgebrochen."
      exit 0
    fi
  fi

  local repos_to_sync; repos_to_sync=($(ordered_repos))
  local total=${#repos_to_sync[@]} i=0 success_count=0 fail_count=0
  for r in "${repos_to_sync[@]}"; do
    (( i++ ))
    echo "▸ [$i/$total] Sync $r"
    if copy_templates_into_repo "$r"; then
      (( success_count++ ))
    else
      (( fail_count++ ))
    fi
  done
  echo "✔︎ Sync abgeschlossen. Erfolg: $success_count, Fehler: $fail_count."
}

cmd_run(){
  local target="${1:-ci}"
  need gh
  local repos_to_run; repos_to_run=($(ordered_repos))
  local total=${#repos_to_run[@]} i=0
  for r in "${repos_to_run[@]}"; do
    (( i++ ))
    echo "▸ [$i/$total] $r → $target"
    if gh workflow list --repo "$(owner)/$r" --limit 200 | awk '{print $1}' | grep -qx "$target"; then
      if ! gh workflow run "$target" --repo "$(owner)/$r"; then
        echo "Workflow-Start in $r übersprungen oder fehlgeschlagen."
      fi
    else
      echo "⚠︎ Workflow '$target' existiert nicht in $r – übersprungen."
    fi
  done
}

cmd_validate(){
  echo "Check: repos.yml parse"
  python3 "$REPO_CONFIG" --file "$REPOS_YML" validate >/dev/null
  echo "OK."
}

cmd_doctor(){
  for bin in python3 rsync git; do command -v "$bin" >/dev/null || echo "WARN: $bin fehlt"; done
  if [[ "$(mode)" == "github" ]]; then
    for bin in jq gh; do command -v "$bin" >/dev/null || echo "WARN: $bin fehlt"; done
  fi
  echo "owner=$(owner)"
  echo "mode=$(mode)"
  echo "PLAN_LIMIT=${PLAN_LIMIT}"
  command -v gh >/dev/null 2>&1 && gh auth status || true
}

cmd_smoke(){
  local count; count="$(ordered_repos | sed '/^$/d' | wc -l | tr -d ' ')"
  echo "Repos in scope: ${count:-0}"
}

case "${1:-}" in
  list)      cmd_list ;;
  plan)      cmd_plan ;;
  up)        shift || true; old_dryrun=$DRYRUN
             if [[ -n "${1:-}" ]]; then
               case "$1" in 0|1) DRYRUN=$1; shift || true ;; *) echo "Usage: $0 up [0|1]" >&2; exit 2 ;; esac
             fi
             cmd_up; DRYRUN=$old_dryrun ;;
  run)       shift; cmd_run "${1:-ci}" ;;
  doctor)    cmd_doctor ;;
  validate)  cmd_validate ;;
  smoke)     cmd_smoke ;;
  *)         echo "Usage: $0 {list|plan|up [0|1]|run [workflow=ci]|doctor|validate|smoke}" >&2; exit 2 ;;
esac
