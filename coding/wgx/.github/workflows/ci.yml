name: CI (smart PR)

on:
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
  merge_group: {}
  workflow_dispatch: {}

permissions:
  pull-requests: write
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  changes:
    name: Detect changes
    runs-on: ubuntu-latest
    outputs:
      shell: ${{ steps.filter.outputs.shell }}
      docs: ${{ steps.filter.outputs.docs }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            shell:
              - 'wgx'
              - '**/*.sh'
              - '**/*.bash'
            tests:
              - 'tests/**/*.bats'
              - 'tests/**/*.sh'
            docs:
              - '**/*.md'
              - 'docs/**'

  lint_shell:
    name: Shell lint (shfmt + shellcheck)
    needs: changes
    if: |
      github.event_name == 'merge_group' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request' &&
        github.event.pull_request.draft == false &&
        (
          needs.changes.outputs.shell == 'true' ||
          contains(github.event.pull_request.labels.*.name, 'full-ci') ||
          contains(github.event.pull_request.labels.*.name, 'lint')
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v4
      - name: Find changed shell files
        id: shell_files
        env:
          FORCE_FULL: ${{ github.event_name != 'pull_request' || contains(github.event.pull_request.labels.*.name, 'full-ci') || contains(github.event.pull_request.labels.*.name, 'lint') }}
          PR_BASE_SHA: ${{ github.event.pull_request.base.sha || '' }}
        run: |
          set -euo pipefail
          base="$PR_BASE_SHA"
          head="${GITHUB_SHA}"
          declare -a candidates=()
          if [[ "$FORCE_FULL" == 'true' ]]; then
            mapfile -t candidates < <(git ls-files '*.sh' '*.bash' 'wgx' 2>/dev/null || true)
          elif [[ -n "$base" ]]; then
            if git fetch --no-tags --depth=50 origin "$base"; then
              mapfile -t candidates < <(git diff --name-only "$base" "$head" 2>/dev/null || true)
            else
              echo "git fetch failed; falling back to full shell file list" >&2
              mapfile -t candidates < <(git ls-files '*.sh' '*.bash' 'wgx' 2>/dev/null || true)
            fi
          else
            mapfile -t candidates < <(git ls-files '*.sh' '*.bash' 'wgx' 2>/dev/null || true)
          fi

          declare -a shell_files=()
          for file in "${candidates[@]}"; do
            [[ -z "$file" ]] && continue
            if [[ -f "$file" ]]; then
              case "$file" in
                *.sh|*.bash|wgx)
                  shell_files+=("$file")
                  ;;
              esac
            fi
          done

          {
            echo 'files<<EOF'
            printf '%s\n' "${shell_files[@]}"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
      - name: Install shell tooling
        run: |
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends shellcheck shfmt jq
      - name: bash -n (syntax check)
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh --per-file "No shell files to check." bash -n <<'EOF'
${{ steps.shell_files.outputs.files }}
EOF
      - name: shfmt (check)
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh "No shell files to format." shfmt -d <<'EOF'
${{ steps.shell_files.outputs.files }}
EOF
      - name: shellcheck
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh "No shell files to lint." shellcheck -S style <<'EOF'
${{ steps.shell_files.outputs.files }}
EOF

  bats_tests:
    name: Bats tests
    needs: changes
    if: |
      github.event_name == 'merge_group' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request' &&
        github.event.pull_request.draft == false &&
        (
          needs.changes.outputs.shell == 'true' ||
          needs.changes.outputs.tests == 'true' ||
          contains(github.event.pull_request.labels.*.name, 'full-ci') ||
          contains(github.event.pull_request.labels.*.name, 'tests') ||
          contains(github.event.pull_request.labels.*.name, 'bats')
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v4
      - name: Run bats test suites
        # Pin to v1.8.0, the latest published release of bats-core/bats-action.
        uses: bats-core/bats-action@v1.8.0
        with:
          helpers: |
            bats-support
            bats-assert

  docs_lint:
    name: Docs lint (Markdown + Links)
    needs: changes
    if: |
      github.event_name == 'merge_group' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request' &&
        (
          needs.changes.outputs.docs == 'true' ||
          contains(github.event.pull_request.labels.*.name, 'full-ci')
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v4
      - name: Find changed docs and script files
        id: changed_docs
        env:
          FORCE_FULL: ${{ github.event_name != 'pull_request' || contains(github.event.pull_request.labels.*.name, 'full-ci') }}
          PR_BASE_SHA: ${{ github.event.pull_request.base.sha || '' }}
        run: |
          set -euo pipefail
          base="$PR_BASE_SHA"
          head="${GITHUB_SHA}"
          declare -a candidates=()
          if [[ "$FORCE_FULL" == 'true' ]]; then
            mapfile -t candidates < <(git ls-files '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
          elif [[ -n "$base" ]]; then
            if git fetch --no-tags --depth=50 origin "$base"; then
              mapfile -t candidates < <(git diff --name-only "$base" "$head" -- '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
            else
              echo "git fetch failed; falling back to full docs file list" >&2
              mapfile -t candidates < <(git ls-files '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
            fi
          else
            mapfile -t candidates < <(git ls-files '*.md' '*.mdx' '*.sh' '*.bash' 2>/dev/null || true)
          fi

          declare -a markdown_files=()
          declare -a vale_files=()
          for file in "${candidates[@]}"; do
            [[ -z "$file" ]] && continue
            if [[ -f "$file" ]]; then
              case "$file" in
                *.md|*.mdx)
                  markdown_files+=("$file")
                  vale_files+=("$file")
                  ;;
                *.sh|*.bash)
                  vale_files+=("$file")
                  ;;
              esac
            fi
          done

          {
            echo 'markdown_files<<EOF'
            printf '%s\n' "${markdown_files[@]}"
            echo 'EOF'
            echo 'vale_files<<EOF'
            printf '%s\n' "${vale_files[@]}"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - name: Install Vale
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VALE_VERSION: latest
        run: |
          set -euo pipefail
          owner="errata-ai"
          repo="vale"
          version="${VALE_VERSION:-latest}"
          release_json=""

          # Use authenticated GitHub API requests to avoid low rate limits
          accept_header="Accept: application/vnd.github+json"
          api_ver_header="X-GitHub-Api-Version: 2022-11-28"

          curl_headers=(
            -H "$accept_header"
            -H "$api_ver_header"
          )

          if [[ -n "${GITHUB_TOKEN:-}" ]]; then
            curl_headers+=(
              -H "Authorization: Bearer ${GITHUB_TOKEN}"
            )
          fi

          if [[ -n "${version}" && "${version}" != "latest" ]]; then
            if ! release_json=$(curl --retry 5 --retry-all-errors -fsSL \
              "${curl_headers[@]}" \
              "https://api.github.com/repos/${owner}/${repo}/releases/tags/${version}"); then
              echo "Unable to fetch release metadata for ${version}; falling back to the latest release" >&2
              release_json=""
            fi
          fi

          if [[ -z "${release_json}" ]]; then
            release_json=$(curl --retry 5 --retry-all-errors -fsSL \
              "${curl_headers[@]}" \
              "https://api.github.com/repos/${owner}/${repo}/releases/latest")
            version=$(printf '%s' "${release_json}" | python3 - <<'PY'
import json, sys
data = json.load(sys.stdin)
tag = data.get('tag_name')
if not tag:
    raise SystemExit('Latest release tag_name not found')
print(tag)
PY
)
          fi

          if [[ -z "${release_json}" ]]; then
            echo "Failed to retrieve release metadata for Vale" >&2
            exit 1
          fi

          readarray -t asset_info < <(printf '%s' "${release_json}" | python3 - <<'PY'
import json, sys

data = json.load(sys.stdin)
preferred_suffixes = (
    'Linux_64-bit.tar.gz',
    'Linux_amd64.tar.gz',
)

for suffix in preferred_suffixes:
    for asset in data.get('assets', []):
        name = asset.get('name') or ''
        if name.endswith(suffix):
            print(name)
            print(asset.get('browser_download_url') or '')
            sys.exit(0)

raise SystemExit('No suitable Linux tarball found in release assets')
PY
)

          if [[ "${#asset_info[@]}" -lt 2 ]]; then
            echo "Failed to determine Vale asset download information" >&2
            exit 1
          fi

          asset_name="${asset_info[0]}"
          asset_url="${asset_info[1]}"

          checksums_url=$(printf '%s' "${release_json}" | python3 - <<'PY'
import json, sys

data = json.load(sys.stdin)
for asset in data.get('assets', []):
    name = asset.get('name') or ''
    if name.endswith('checksums.txt'):
        print(asset.get('browser_download_url') or '')
        sys.exit(0)

raise SystemExit('checksums.txt not found in release assets')
PY
)

          curl --retry 5 --retry-all-errors -fsSL "${asset_url}" -o vale.tar.gz
          curl --retry 5 --retry-all-errors -fsSL "${checksums_url}" -o checksums.txt

          EXPECTED_SHA256=$(awk -v file="${asset_name}" '$2 == file {print $1; exit}' checksums.txt)
          if [[ -z "${EXPECTED_SHA256:-}" ]]; then
            echo "Unable to determine expected checksum for ${asset_name}" >&2
            exit 1
          fi

          ACTUAL_SHA256=$(sha256sum vale.tar.gz | awk '{print $1}')
          if [[ "${EXPECTED_SHA256}" != "${ACTUAL_SHA256}" ]]; then
            echo "SHA256 checksum mismatch for vale.tar.gz" >&2
            echo "Expected: ${EXPECTED_SHA256}" >&2
            echo "Actual:   ${ACTUAL_SHA256}" >&2
            exit 1
          fi

          tar -xzf vale.tar.gz
          test -f vale && echo "vale binary extracted" || (echo "vale missing" && exit 1)
          sudo install -m 0755 vale /usr/local/bin/vale
          echo "Installed Vale ${version} (${asset_name})"
          vale --version
          rm -f vale vale.tar.gz checksums.txt
      - name: Markdownlint (changed only)
        run: |
          set -euo pipefail
          npm i -g markdownlint-cli2@0.12.1
          ./etc/ci/run-with-files.sh "No Markdown files to lint." markdownlint-cli2 <<'EOF'
${{ steps.changed_docs.outputs.markdown_files }}
EOF
      - name: Vale lint (changed only)
        run: |
          set -euo pipefail
          ./etc/ci/run-with-files.sh "No files for Vale." vale --minAlertLevel=warning <<'EOF'
${{ steps.changed_docs.outputs.vale_files }}
EOF
      - name: Link check (Lychee)
        if: steps.changed_docs.outputs.markdown_files != ''
        uses: lycheeverse/lychee-action@v2
        with:
          args: >-
            --no-progress
            --accept 200,206,429
            --max-concurrency 8
            --retry-wait-time 2
            --timeout 30
            --max-retries 2
            --exclude-path 'node_modules|.git'
            --exclude 'localhost|127\.0\.0\.1|badge\.fury\.io|shields\.io'
            ${{ steps.changed_docs.outputs.markdown_files }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  profile_contracts:
    name: Profile contracts
    needs: changes
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'merge_group' ||
      (
        github.event_name == 'pull_request' &&
        contains(github.event.pull_request.labels.*.name, 'full-ci')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      fail-fast: false
      matrix:
        repo:
          - https://github.com/alexdermohr/weltgewebe
          - https://github.com/alexdermohr/hauski
          # ggf. weitere Repos ergänzen
    steps:
      - uses: actions/checkout@v4
      - name: Configure git safe.directory
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"
      - name: Validate ${{ matrix.repo }}
        env:
          GIT_ASKPASS: /bin/true
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          repo="${{ matrix.repo }}"
          name="${repo##*/}"
          target="$repo"
          if [[ "$repo" == https://github.com/* && -n "${GH_TOKEN:-}" ]]; then
            target="https://x-access-token:${GH_TOKEN}@github.com/${repo#https://github.com/}"
          fi
          ./wgx validate --json "$target" --out "validate_${name}.json"
      - name: Upload JSON results
        uses: actions/upload-artifact@v4
        with:
          name: profile-contracts-json
          path: validate_*.json
